<div xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/1999/xhtml ../../schema/fhir-xhtml.xsd" xmlns="http://www.w3.org/1999/xhtml">

	[%stu-note%]
	<p>TODO</p>
	<ol>
		<li>
			<p>Updates to "Managing Subscriptions and Errors"</p>
			<ul>
				<li>Discuss error codes (Extensible Codeable Concept)</li>
				<li>Define basic error codes here</li>
				<li>Need to discuss eventCount and error detection (insert appropriate examples/workflows)</li>
			</ul>
		</li>
		<li>
			<p>Updates to "Tracking Subscription Notifications" <b>SHOULD</b> define what the AuditEvent looks like</p>
		</li>
		<li>
			<p>Updates to "Channels" "Email/SMS" ...</p>
		</li>
		<li>
			<p>Updates to "Channels" "Messaging" ...</p>
		</li>
	</ol>
	[%end-note%]

	<a name="safety"/>
	<h2>
		Safety and Security
	</h2>
	<p>
		Servers are responsible for maintaining the security of patient data in accordance with their organizational policies.  Recommendations provided below are for informational purposes only and should be reviewed prior to implementation.
	</p>
	<p>
		Servers are responsible for verifying that any notification which includes PHI has been appropriately authorized and secured (e.g., a client MAY ask for information they are not authorized to view).  Servers SHOULD reject any <code>Subscription</code> request which does not meet their policy requirements.
	</p>
	<p>
		<code>Subscription</code> resources are not intended to be secure storage for secrets (e.g., OAuth Client ID or Tokens, etc.).  Implementers MAY use their judgement on including limited-use secrets (e.g., a token to verify that a message is from the desired source).
	</p>
	<p>
		Executing each of the channels documented in this specification involves the server sending a communication that MAY reveal information about the client and server relationship, and, if the entire resource is sent, administrative or clinical information that may be quite sensitive and/or protected under law. Servers are responsible for ensuring appropriate security is employed for each channel. The subscription resource does not address these concerns directly - it is assumed that these are administered by other configuration processes. For instance, a server might maintain a whitelist of acceptable servers for the rest-create/rest-update methods.
	</p>

	<a name="subscription-notification"/>
	<h2>
		Subscription Notification
	</h2>
	<p>The three types of notifications which a server is able to send to a client are the <em>Event</em>, <em>Handshake</em> and <em>Heartbeat</em> notification. All of the notification types are <a href="bundle.html#history">history Bundles</a> with added extensions on the <code>Bundle.meta</code> element to define Subscription notification specific details.</p>
	<p>
		<em>TODO: In the following sections provide specific guidance for each channel types this including for REST Hooks + Web Sockets</em>
	</p>
	<a name="event-notification"/>
	<h3>
		Event Notification
	</h3>
	<p>The primary notification is a notification about an event.</p>
	<ul>
		<li>
			<a href="subscription-example-notification-id-only.html">Example event notification</a>
		</li>
	</ul>
	<p>The client expectations upon receipt of receipt of a Handshake notification are defined by each implementation.</p>
	<a name="handshake-notification"/>
	<h3>
		Handshake Notification
	</h3>
	<p>When a connection to an Endpoint is established, the Server will send an empty History Bundle as a Handshake notification to the client.</p>
	<ul>
		<li>
			<a href="subscription-example-handshake.html">Example handshake notification</a>
		</li>
	</ul>
	<p>The client is not expected to take any special action in receipt of a Handshake notification beyond the channel requirements.</p>
	<a name="heartbeat-notification"/>
	<h3>
 		Heartbeat Notification
	</h3>
	<p>Servers may periodically send notifications across a channel to ensure that the connection is still alive and valid. The Heartbeat notification is an empty History Bundle sent without incrementing the subscription event count.</p>
	<ul>
		<li>
			<a href="subscription-example-heartbeat.html">Example heartbeat notification</a>
		</li>
	</ul>
	<p>The client is not expected to take any special action in receipt of a Heartbeat notification beyond the channel requirements.</p>
	<a name="bundle-extensions-for-subscriptions"/>
	<h3>
 		Bundle Extensions for Subscriptions
	</h3>
	<ul>
		<li>
			<p>The <a href="extension-subscription-event-count.html">subscription-event-count</a> extension is used to indicate the number of times a notification has been attempted on this Subscription PRIOR to this notification being sent.</p>
			<ul>
				<li>
					<p>In the case of a handshake, this count will always be zero (0).</p>
				</li>
				<li>
					<p>In the case of a heartbeat notification, this count will be the same as the last notification and will not be incremented due to the heartbeat notification.</p>
				</li>
				<li>
					<p>In the case of event notifications, the event count will be incremented by the number of notifications contained within this bundle (typically a single notification, though servers may choose to batch notifications within a short time interval).</p>
				</li>
			</ul>
		</li>
	</ul>
	<!-- end list -->
	<ul>
		<li>
			<p>The <a href="extension-bundle-event-count.html">bundle-event-count</a> extension represents the number of events ( event-notifications, notifications ??) within the Bundle. This is of particular interest in several ways:</p>
			<ul>
				<li>
					<p>Determining if a notification requires further processing (e.g., discarding handshake and heartbeat)</p>
				</li>
				<li>
					<p>Determining the number of events in <code>empty</code> payload scenarios</p>
				</li>
				<li>
					<p>Server batching (e.g., a server sending at max one notification per second)</p>
				</li>
				<li>
					<p>In the case of a handshake, this count will always be zero (0).</p>
				</li>
			</ul>
		</li>
	</ul>
	<!-- end list -->
	<ul>
		<li>
			<p>The <a href="extension-subscription-status.html">subscription-status</a> extension is used to represent the <a href="valueset-subscription-status.html">Subscription status values</a> at the time the notification is sent. Note that the status might change between the time the notification is sent and the time it is received/processed, and therefore this status recorded in the extension is not guaranteed to represent status of the Subscription at any time prior-to or after this notification is sent. The field is useful primarily as a hint to inform the client if the server has encountered errors in notifications immediately preceding this notification.</p>
		</li>
		<li>
			<p>The <a href="extension-subscription-topic-url.html">subscription-topic-url</a> extension references the Topic resource relevant to this notification. The URL is an absolute references to the resource on the server that generated the notification and <em>NOT</em> a reference its canonical URL.</p>
		</li>
		<li>
			<p>The <a href="extension-subscription-url.html">subscription-url</a> extension references the Subscription resource which triggered this notification. The URL is an absolute references to the resource on the server that generated the notification.</p>
		</li>
	</ul>
	<a name="payloads"/>
	<h3>
 		Payloads
	</h3>
	<p>There are three options available when specifying the contents of a Notification: <code>empty</code>,		<code>id-only</code>, and <code>full-resource</code>. These options change the amount of information conveyed in the notification bundle itself.</p>
	<p>When deciding which payload type to request, the client <b>SHOULD</b> consider both ease in processing and security of PHI. If any untrusted hosts are included in processing notifications, it is <em>STRONGLY</em> recommended to use an <code>empty</code> payload to protect confidential health information.</p>
	<p>Examples:</p>
	<ul>
		<li>
			<a href="subscription-example-notification-empty.html">empty</a>
		</li>
		<li>
			<a href="subscription-example-notification-id-only.html">id-only</a>
		</li>
		<li>
			<a href="subscription-example-notification-full-resource.html">full-resource</a>
		</li>
	</ul>
	<a name="channels"/>
	<h2>
		Channels
	</h2>
	<a name="rest-hook"/>
	<h3>
		REST Hook
	</h3>
	<p>When a Subscription is created for a REST Hook channel type, the server <b>SHALL</b> set initial status to <code>requested</code>, pending verification of the nominated endpoint URL. After a successful handshake notification has been sent and accepted, the server <b>SHALL</b> update the status to <code>active</code>. Any errors in the initial handshake <b>SHALL</b> result in the status being changed to <code>error</code>.
	</p>
	<p>When the server processes an event meeting the specified criteria, the server POSTs an event notification to the client's nominated endpoint URL (i.e. to the <code>Subscription.channel[type=rest-hook].endpoint</code>) as shown in the following examples. The content-type of the POST <b>SHALL</b> match the contentType (<code>Subscription.channel.payload.contentType</code>) requested during creation of the Subscription. Note that the server <b>SHALL</b> append the headers, if any are given, to the POST request that it makes to the client.</p>
	<p>For consistency, the rest of this document assumes <code>application/fhir+json</code> has been selected, and will be referred to as JSON.</p>
	<p>This example uses an event notification with an emp>ty payload to alert the subscriber that new results are available:</p>
	<p>Request:</p>
	<p>
		<code>POST to [client endpoint]</code>
	</p>
	<p>Request Payload</p>
	<pre fragment="Bundle" class="json">
{
  "resourceType": "Bundle",
  "id": "notification-empty",
  "meta": {
    "extension": [
      {
        "url": "http://hl7.org/fhir/StructureDefinition/subscription-event-count",
        "valueUnsignedInt": 1
      },
      {
        "url": "http://hl7.org/fhir/StructureDefinition/bundle-event-count",
        "valueUnsignedInt": 1
      },
      {
        "url": "http://hl7.org/fhir/StructureDefinition/subscription-status",
        "valueCode": "active"
      },
      {
        "url": "http://hl7.org/fhir/StructureDefinition/subscription-topic-url",
        "valueUrl": "https://example.org/baseR4/Topic/admission"
      },
      {
        "url": "http://hl7.org/fhir/StructureDefinition/subscription-url",
        "valueUrl": "https://example.org/Subscription/cb2dce51-a1f5-40b4-a98b-c934eae368e8"
      }
    ]
  },
  "type": "history",
  "timestamp": "2019-08-07T10:24:13.1882432-05:00"
}</pre>
	<p>Since the content element is set to <code>empty</code>, the data in the resources is only available through the REST API which helps consolidate authorization and authentication logic. When the subscriber receives a POST to its nominated endpoint it may queries the server to fetch all the relevant resources based on the Topic. The parameter <code>&amp;_since=:last</code> (where :last is replaced by the time at which the client last checked) may be appended to the query fetch the most recent resources. For example, in this example the topic is patient admission, and the subscriber may fetch the most recent Encounters for a patient or group of patients.</p>
	<p>In this example, the event notification contains the only the ids for resource. This provide the subscriber with the id for fetching the data.</p>
	<p>Request:</p>
	<p>
		<code>POST to [client endpoint]</code>
	</p>
	<p>Request Payload</p>
	<pre fragment="Bundle" class="json">
{
  "resourceType": "Bundle",
  "id": "notification-id-only",
  "meta": {
    "extension": [
      {
        "url": "http://hl7.org/fhir/StructureDefinition/subscription-event-count",
        "valueUnsignedInt": 2
      },
      {
        "url": "http://hl7.org/fhir/StructureDefinition/bundle-event-count",
        "valueUnsignedInt": 1
      },
      {
        "url": "http://hl7.org/fhir/StructureDefinition/subscription-status",
        "valueCode": "active"
      },
      {
        "url": "http://hl7.org/fhir/StructureDefinition/subscription-topic-url",
        "valueUrl": "https://example.org/baseR4/Topic/admission"
      },
      {
        "url": "http://hl7.org/fhir/StructureDefinition/subscription-url",
        "valueUrl": "https://example.org/Subscription/cb2dce51-a1f5-40b4-a98b-c934eae368e8"
      }
    ]
  },
  "type": "history",
  "timestamp": "2019-08-07T10:24:13.1882432-05:00",
  "entry": [
    {
      "fullUrl": "https://example.org/baseR4/Encounter/2",
      "request": {
        "method": "PUT",
        "url": "Encounter/2"
      },
      "response": {
        "status": "201"
      }
    }
  ]
}</pre>
	<p>Since the content element is set to <code>id-only</code>, like in the first scenario, the data in the resources is only available through the REST API which helps consolidate authorization and authentication logic. When the subscriber receives a POST to its nominated endpoint it may queries the server to fetch all the relevant resources using the supplied resource ids. For example, in this example the topic is patient admission, and the subscriber may fetch the Encounter(s) for a patient or group of patients.</p>
	<p>In this example, the event notification contains the the entire resource. This is usually appropriate for defining routing rules within a managed eco-system such as a healthcare institution.</p>
	<p>Request:</p>
	<p>
		<code>POST to [client endpoint]</code>
	</p>
	<p>Request Payload</p>
	<pre fragment="Bundle" class="json">
{
  "resourceType": "Bundle",
  "id": "notification-full-resource",
  "meta": {
    "extension": [
      {
        "url": "http://hl7.org/fhir/StructureDefinition/subscription-event-count",
        "valueUnsignedInt": 3
      },
      {
        "url": "http://hl7.org/fhir/StructureDefinition/bundle-event-count",
        "valueUnsignedInt": 1
      },
      {
        "url": "http://hl7.org/fhir/StructureDefinition/subscription-status",
        "valueCode": "active"
      },
      {
        "url": "http://hl7.org/fhir/StructureDefinition/subscription-topic-url",
        "valueUrl": "https://example.org/baseR4/Topic/admission"
      },
      {
        "url": "http://hl7.org/fhir/StructureDefinition/subscription-url",
        "valueUrl": "https://example.org/Subscription/cb2dce51-a1f5-40b4-a98b-c934eae368e8"
      }
    ]
  },
  "type": "history",
  "timestamp": "2019-08-07T10:24:13.1882432-05:00",
  "entry": [
    {
      "fullUrl": "https://example.org/baseR4/Encounter/3",
      "resource": {
        "resourceType": "Encounter",
        "id": "3",
        "meta": {
          "versionId": "1",
          "lastUpdated": "2019-08-07T10:49:22Z"
        },
        "status": "in-progress",
        "class": {
          "system": "http://terminology.hl7.org/CodeSystem/v3-ActCode",
          "code": "VR",
          "display": "virtual"
        },
        "subject": {
          "reference": "Patient/123"
        }
      },
      "request": {
        "method": "PUT",
        "url": "Encounter/3"
      },
      "response": {
        "status": "201"
      }
    }
  ]
}</pre>
	<p>This requests that a server forward a copy of any matching resource in JSON format to the nominated server as an <a href="http.html#update">Update operation</a> (i.e PUT) using the nominated URL as the <a href="http.html#root">service base</a>. In order to execute this channel, the server <b>SHALL</b> know how to authenticate appropriately with the destination server. This can be done by the subscription resource providing an authentication header for the server to use, or alternatively, the server may be specifically configured to be able to use the nominated server.</p>
	<a name="rest-hook-security"/>
	<h4>
		Channel Security Notes
	</h4>
	<p>
		Note that HTTP is not a secure or encrypted channel.  It is strongly recommended that implementations refuse requests to send notifications to URLs using the HTTP protocol (use HTTPS instead).
		Note that HTTP does not provide endpoint verification.  It is strongly recommended that implementations refuse requests to send notifications to URLs using the HTTP protocol (use HTTPS instead).
	</p>

	<a name="websockets"/>
	<h3>
 		WebSockets
	</h3>
	<p>Subscriptions are created exclusively via the FHIR REST API. But notifications need not occur via REST. Indeed, some subscribers may be unable to expose an outward-facing HTTP server to receive triggered notifications. For example, a pure client-side Web app or mobile app may want to subscribe to a data feed without polling using the /history operation. This can be accomplished using a websocket notification channel.</p>
	<p>A client can declare its intention to listen via Web Sockets:</p>
	<pre fragment="Subscription" class="json">
{
  "channel": {
    "type": {
      "coding": [
        {
          "system": "http://terminology.hl7.org/CodeSystem/subscription-channel-type",
          "code": "websocket"
        }
      ]
    }
  }
}</pre>
	<p>The subscriber would then initiate a Web Socket connection to the server, at a URL advertised in the FHIR server's Capability statement (subscriptions/webSocketUrl (todo)). A simple protocol is used to listen for notifications:</p>
	<ul>
		<li>Client connects a secure Web Socket to the server's webSocketUrl (see <a href="extension-capabilitystatement-websocket.html">websocket extension</a> in the server's <a href="capabilitystatement.html">CapabilityStatement</a>).
		</li>
		<li>Client authenticates to server using a server-specified Web socket protocol (e.g. OAuth bearer token presentation).</li>
		<li>Client sends a bind :id message over the socket (using the logical id of the subscription). For example, the client might issue: bind 123).</li>
		<li>Server responds with a "bound :id" message to acknowledge.</li>
		<li>Server sends a "ping :id" message to notify the client each time a new result is available</li>
	</ul>
	<p>
		[%stu-note%]
		Warning: The WebSocket channel type is being examined to provide functional parity with other channel types. In particular, the current system fails to address authentication and a desire for multiple subscriptions to be available to a single WebSocket connection. More work is required.
		[%end-note%]
	</p>
	<a name="websockets-security"/>
	<h4>
		Channel Security Notes
	</h4>
	<p>
		WebSocket security for FHIR Subscriptions is not yet well understood.  Implementers should be aware (at minimum) of the following areas:
	</p>
	<ul>
		<li>Authentication of WebSockets is not generically interoperable with JWT or other 'Authentication header' protocols - WS and WSS do NOT allow for the required headers.</li>
		<li>Given client limitations on concurrent WebSocket connections (commonly 6), it is recommended that a single connection be able to authenticate to multiple Subscription resources.</li>
		<li>Unlike HTTP/S requests, WebSockets can be long-lived.  Because of this, the case of revoking access of an active connection must be considered.</li>
	</ul>

	<a name="email-sms"/>
	<h3>
		Email/SMS
	</h3>
	<p>A client can register for its user to receive notifications by email:</p>
	<pre fragment="Subscription" class="json">
{
  "channel": {
    "type": {
      "coding": [
        {
          "system":"http://terminology.hl7.org/CodeSystem/subscription-channel-type",
          "code":"email"
        }
      ]
    },
    "endpoint":"mailto:mt-auburn-results@direct.biliwatch.com",
    "header":"A new bilirubin result has arrived!"
  }
}</pre>
	<p>The server would send a new message for each matching resource. The body of the email may be empty, or it may contain a reference to the search or the matching resource. It is at the discretion of the server as to how much information to provide. <code>Subscription.channel.header</code> sets the subject of the email. The email <b>SHOULD</b> be secured appropriately, such as using Direct, as specified by the rules of the applicable jurisdictions.</p>
	<p>SMS works very similarly:</p>
	<pre fragment="Subscription" class="json">
{
  "channel":{
    "type": {
      "coding":[
        {
          "system":"http://terminology.hl7.org/CodeSystem/subscription-channel-type",
          "code":"sms"
        }
      ]
    },
    "endpoint":"tel:+1555-345-5555"
  }
}</pre>
	<p>
		Note: SMS messages are extremely limited in size, so <code>channel.payload</code> will usually be omitted (signifying that no payload is to be sent). The recipient may be human, but this is not always the case. Irrespective of size, most servers will refuse to send payloads in SMS for security reasons, and may refuse to send emails unless encrypted.
	</p>
	<p>
		Emails <b>SHOULD</b> generally be secured using some technique such as <a href="http://directproject.org/">Direct</a>.
	</p>
	<p>A mime/type of text/plain can be useful for email and sms along with some extension describing how to convert resources to a text representation. This specification may provide supporting infrastructure for this in the future.</p>
	[%stu-note%]
	Warning: The Email/SMS channel types are not yet defined in a highly standardized way, and may not be consistently support by servers. More work is required.
	[%end-note%]
	<a name="messaging"/>
	<h3>
		Messaging
	</h3>
	<p>A client can register for its user to receive notifications by <a href="messaging.html">messaging</a>:
	</p>
	<pre fragment="Subscription" class="json">
{
  "channel": {
    "type": {
      "coding":[
          {
            "system":"http://terminology.hl7.org/CodeSystem/subscription-channel-type",
            "code":"sms"
          }
      ]
    },
    "endpoint":"tel:+1555-345-5555"
  }
}</pre>
	<p>For each matching resource, a server will send a message to the nominated end-point. Most servers will require that the end-point is white-listed prior to allowing these kinds of subscriptions.</p>
	[%stu-note%]
	Warning: The Messaging channel type is not yet defined in a highly standardized way, and may not be consistently support by servers. More work is required.
	[%end-note%]

	<a name="errors"/>
	<h2>
		Managing Subscriptions and Errors
	</h2>
	<p>The subscription resource is authored by the client with an initial status of "requested". A new subscription is created on the server using the RESTful create or update interaction. After a successful transaction, the client parses the Location header and saves the new Subscription's logical id for use in subsequent operations.</p>
	<p>When the server receives a subscription, it <b>SHOULD</b> check that it is prepared to accept/process the subscription. If it is, it sets the subscription to <code>requested</code> and process it like a normal <a href="http.html#create">create</a>. If it isn't, it <b>SHOULD</b> return an error with an <a href="operationoutcome.html">OperationOutcome</a> instead of processing the <code>create</code>.
	</p>
	<p>The criteria are subject to the same limitations as the client that created it, such as access to patient compartments etc. Note that the subscription remains active after the client access tokens expire.</p>
	<p>Once the server has activated the subscription, it sets the status to <code>active</code> (note: the server may do this as it accepts the resource if it wants).</p>
	<p>An appropriately authorized client can use search and/or history operations to see what subscriptions are currently active on the server. Once the subscription is no longer desired, the client deletes the subscription from the server.</p>
	<p>The server may retry the notification a fixed number of times and/or refer errors to its own alert logs. If the notification fails, the server <b>SHOULD</b> set the status to <code>error</code> and mark the error in the resource. If the notification succeeds, the server <b>SHOULD</b> update the status to <code>active</code> and may remove any error codes. If a subscription fails consistently a server may choose set the subscription status to <code>off</code> and stop trying to send notifications.</p>
	<p>This search will return all the AuditEvent resources that are about <a href="patient.html">Patient</a>
		<code>103</code>. At this time there is no deterministic way to tell say which of those AuditEvent resources come from the subscription sub-system that actually handles notifications. This is planned to be resolved in a future version of this specification. In the mean time, servers are encouraged to create AuditEvent records when performing notifications and document how clients can identify the relevant records when searching.</p>
	<p>If a subscription nominates a fixed end date, the server automatically deletes it at the specified time.</p>
	<a name="tracking"/>
	<h2>
 		Tracking Subscription Notifications
	</h2>
	<p>Applications that wish to track whether notifications have been sent for particular resources (or versions of resources) can look at the AuditEvent resources. For example:</p>
	<pre>
		<code>GET [base]/AuditEvent?entity=Patient/103
		</code>
	</pre>
	<p>In addition, servers might also create <a href="communication.html">Communication</a> resources for some of the notifications that are sent in response to a subscription, such as when sending emails.</p>
	<pre>
		<code>GET [base]/Communication?based-on=Subscription/103
		</code>
	</pre>
	<p>This returns a list of communications sent by a subscription. TODO: search on payload....</p>
</div>
