<div xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/1999/xhtml ../../schema/fhir-xhtml.xsd" xmlns="http://www.w3.org/1999/xhtml">

<h2>Scope of testing</h2>
<p>
The scope element defines what the TestPlan is testing. This serves no functional purpose during the execution
of the tests, but is used to provide context for the TestPlan and its tests. The scope can be one of the following:
</p>
<ul>
	<li><a href="actordefinition.html">ActorDefinition</a> - the TestPlan is intended to test a particular Actor system as defined somewhere</li>
	<li><a href="implementationguide.html">ImplementationGuide</a> - the TestPlan is testing the system(s) defined in the implementation guide</li>
	<li><a href="structuredefinition.html">StructureDefinition</a> - the TestPlan is testing the behavior associated with a particular Profile. Note that profiles don't specify behavior directly, so the relationship between the profile and what is being tested as at the discretion of the author</li>
	<li><a href="capabilitystatement.html">CapabilityStatement</a> - the TestPlan is testing the behavior of the applications that do (or should) conform to a set of expectations defined in a CapabilityStatement. Note that TestScript is intended and suitable for testing CapabilityStatements directly, so the anticipation is that a TestPlan is testing more than just what is specified in the CapabilityStatement</li>
	<li><a href="requirements.html">Requirements</a> - The TestPlan is testing systems that are intended to conform to a set of requirements. Again, there is no direct relationship
    between the requirements and testable systems, so the relationship is at the discretion of the author</li>
</ul>

<h2>Defining the Runner</h2>
<p>
The runner is identified by a URL that is used to define what is required to execute the tests in the TestPlan.
In general, the expectation is that the URL will resolve to a text description of the behavior of the runner. 
Note that there is no expectation that the behavior of the runner will be computably defined, though runners are
sometimes defined by referring to a GitHub repository that contains a reference implementation of the runner.
</p>	
<p>
What the runner description should contain is enough information about the runner to allow additional Implementations
of the runner. In particular, the runner description should make clear:
</p>
<ul>
	<li>What kind of tests the runner can perform</li>
	<li>What operation codes that tests in the plan can use, and what happens when they are executed</li>
	<li>What parameters are defined and what they mean, and for which operations they apply</li>			
	<li>The kind of inputs, outputs and assertions that the runner supports</li>
</ul>
<p>
Runners will need additional documentation such as how to invoke the runner, how to provide parameters and modes, 
where the output will be produced and what format it will have, etc. This documentation is not considered to be 
part of the formal definition of the runner, and the documentation for the runner should differentiate between
the different kinds of documentation.
</p>

<h2>Dependencies</h2>
<p>
Test Plans can nominate other Test Plans on which they depend - that is, it is only valid to test this 
test plan if the other test plans was successfully executed first, which means, every test in that plan 
executed with <b>errors</b>. Note that this requirement does not apply to the other test plans that the 
test plan nominates, as those referenced test plans are usually (but not always) the test plans that 
nominate their dependencies.
</p>

<h2>Inputs and Outputs</h2>
<p>
Suites and Tests can define inputs and expected outputs. Inputs are used to provide data to the tests, and 
expected outputs are used to specify rules against which the actual outputs of the tests are checked.
</p>
<p>
Both inputs and expected outputs have names and modes (see below for how modes work). There may be more than 
one input with the same name and mode - this signals multiple inputs with the same purpose. In general
there can only be one output with a given name. Inputs and expected outputs can be provided as either a 
direct inline resource, or as a file name that contains some input (usually, but not always) a FHIR resource.
</p>
<p>
Expected outputs are compared to the actual outputs of the test by name. Most - but not all - tests produce 
only a single output, but more than one can be produced. Which ones are produced is defined by the runner 
for the different operations it defines. If outputs are resources, then the expectation is that the runner
will look inside the resource to see if it's a <a href="https://build.fhir.org/ig/FHIR/ig-guidance/matchetypes.html">matchetype</a>, in which case matchetype 
rules are used, otherwise the actual output is compared to the expected as a binary, though runners may
choose to define alternative comparison rules for specific outputs.
</p>
<p>
Test Plans can also define assertions, which are used to check the actual outputs of the tests. An assertion
has the following properties:
</p>
<ul>
	<li><b>focus</b> - the name of the output to which that the assertion applies to</li>
	<li><b>mode</b> - the mode in which the assertion applies (or it always applies, if there's no mode)</li>
	<li><b>severity</b> - The severity for the assertions - error, warning or hint</li>
	<li><b>human</b> - Human description of the assertion</li>
	<li><b>expression</b> - The actual expression. The definition of the runner will define what expression languages etc are available, but FHIRPath is strongly recommended</li>
</ul>

<h2>Modes and Parameters</h2>
<p>
There is two kind of inputs to a test plan when it is executed: modes and parameters. 
They function differently:
</p>
<ul>
	<li><b>Modes</b> are used to determine which suites and tests are executed. They are defined by the TestPlan.</li>
	<li><b>Parameters</b> are used to control the details of the test execution. They are input to the runner, and defined by the runner. 
	The TestPlan does not define parameters; it only assigns values to those defined by the runner.</li>
</ul>
<p>
The TestPlan defines the set of modes that the test administrator can provide when executing the test plans. 
These decide which tests are executed, and which inputs, expected outputs and assertions are in scope. If any of 
the elements of the Test Plan don't nominate any modes, then they are always in scope; if they do nominate
one or more modes, they are only applicable when the mode is specified as internal input to the runner.
If a mode is specified on a named element, and the mode is not present, the named element with no mode 
applies; if a mode matching one of the named elements is provided, then only the matching named element
applies.
</p>
<p>
Modes are used to cater for differing input requirements while maintaining a single set of tests. 
As an example, consider the terminology ecosystem tests - some servers return heirarchical expansions 
in some circumstances, while others do not. Both sets of servers are considered conformant, but 
the difference cannot be ignored in the 1% of the tests that are affected by this. A mode is 
used to handle this difference. 
</p>
<p>
Parameters are defined by the runner, and passed to the runner from the TestPlan. The test plan can 
define the value of a parameter at any level (Test Plan, any suite, or a test) and the value 
of the parameter cascades down unless it's overriden at a lower level. 
</p>
<p>
Parameter values can be provided as constants (strings, numbers, booleans, dates, Codings and Quantities)
or a parameter can be defined by an expression. It's in the expression that the power of test plans 
truly comes to life. It's up to the runner to define how these expressions work, but the general 
expectation is that runners will support FHIRPath expressions, and that the inputs and expected outputs of 
other tests in the TestPlan can be referenced in the expressions. Runners MAY choose to use this
FHIRPath syntax for such references:
</p>
<pre>
{{%plan.suite('name').test('name').[data]('name').value}}
</pre>
<p>
The value is a direct reference to the root element in the whatever data is being referenced. 
<code>[data]</code> must be replaced with one of <code>input()</code>, <code>expected()</code> and <code>actual()</code>.
If the mode selects one particular input or expected output, then the 
correct instance will be selected transparently to the script. If the input or output is binary, then
there is no ability to use the FHIRPath expression, but most inputs and expected outputs are resources. 
</p>

<h2>Test Reports</h2>

<p>
The outcomes of a TestPlan execution MAY be reported using the <a href="testreport.html">TestReport</a> resource,
though this is not required. Runners MAY choose to report the results in any format they like.
</p>

</div>
