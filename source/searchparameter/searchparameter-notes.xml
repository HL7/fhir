<div xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/1999/xhtml ../../schema/fhir-xhtml.xsd" xmlns="http://www.w3.org/1999/xhtml">

<a name="naming-conventions"></a>
<h2>Naming Conventions for Search Parameters</h2>
<p>
HL7-defined search parameters follow these naming conventions:
</p>
<ul>
  <li>Use lowercase letters with hyphens for multi-word parameters (kebab-case)</li>
  <li>Prefer shorter, more common terms when possible</li>
  <li>Be consistent across resources when the same concept is searched (e.g., <code>authored</code> for authoring dates)</li>
  <li>Avoid abbreviations unless widely understood</li>
  <li>Use singular forms unless the concept is inherently plural</li>
  <li>Use of a prefix underscore character (<code>_</code>) compliant with the rules of the <a href="http.html#styleguide">Style Guide</a></li>
</ul>



<a name="notes"></a>
<h2>Notes</h2>
<ul>
  <li>
    If the extension's context specifies multiple resources, they are represented with multiple 
    elements in the <code>SearchParameter.base</code> array
  </li>
  <li>
    An expression like <code>Resource.descendents.extension('extension-url').value</code> is possible, but this 
    is a low performance option for a server to evaluate, and search parameter expressions are performance 
    sensitive
  </li>
</ul>

<a name="fhirpath"></a>
<h2>Use of FHIRPath in Expressions</h2>
<ul>
  <li>
    An expression like <code>Resource.descendents().extension('extension-url').value</code> is possible, but this 
    is a low performance option for a server to evaluate, and search parameter expressions are performance 
    sensitive
  </li>
  <li>
    While SearchParameter.expression allows for the full use of FHIRPath, including resolve() in a search
    parameter definition makes it difficult to support for transactional servers. For that reason, this
    specification does not define parameters that link across resource instance boundaries.<br/>
    This specification does use search parameters with resolve() to narrow types
    (e.g., Observation.subject.resolve() is Patient). We recommend that other specifications follow the
    same practice - chaining is the mechanism defined to search across resource boundaries.
  </li>
</ul>

<blockquote class="note-to-balloters">
  <p>
    Balloter feedback requested: We are seeking input on approaches to managing the balance between expressiveness and performance impact on servers from the use of various FHIRPath features in search parameter expressions.
  </p>
</blockquote>


<a name="srch"></a>
<h2>SearchParameters on Extensions</h2>
<p>
The SearchParameter resource may be used to define searches on extensions.
A simple definition defines the code, the base resource the extension can be 
found in, and a type, and an expression. Assume that the extension is <code>http://example.org/fhir/StructureDefinition/extension-thumb-length</code>
which has a value that is a quantity, and that is used on patient, then an appropriate SearchParameter would be:
</p>
<pre class="json">
   "code" : "thumb-length",
   "base" : ["Patient"],
   "type" : "quantity",
   "expression" : "Patient.extension('http://example.org/fhir/StructureDefinition/extension-thumb-length').value"
</pre>
<p>
Servers MAY attempt to process expressions that just select the extension without the <code>.value</code>, but this
is not required and may be discouraged or deprecated in the future. 
</p>
<p>
Extensions may have multiple types with different search behaviors, so the type can be specifically selected:
</p>
<pre class="json">
   "code" : "thumb-length-code",
   "base" : ["Patient"],
   "type" : "token",
   "expression" : "Patient.extension('http://example.org/fhir/StructureDefinition/extension-thumb-length').value.ofType(CodeableConcept)"
</pre>
<p>
This example would select coded thumb lengths and index them only for the <code>thumb-length-code</code> search parameter.
When an extension can have multiple types with incompatible search behavior, the search 
parameters have to do this. Note that is type casting the extension directly (e.g.
<code>Patient.extension('...').ofType(CodeableConcept)</code>) will lead to an empty index, 
since the extension is not a CodeableConcept itself.
</p>
<p>
When extensions can be used in multiple places, these places are enumerated in the expression:
</p>
<pre>
Patient.extension('http://example.org/fhir/StructureDefinition/extension-thumb-length').value
 | Patient.contact.extension('http://example.org/fhir/StructureDefinition/extension-thumb-length').value
 | Practitioner.extension('http://example.org/fhir/StructureDefinition/extension-thumb-length').value
</pre>

<a name="alias"></a>
<h4>Search Parameter Aliases</h4>

<p>
To support evolution toward consistent naming conventions while maintaining backward compatibility, <code>SearchParameter</code> resources 
MAY define one or more <code>aliasCode</code> values. These aliases represent suggested alternative codes that can be used to reference the search 
parameter in addition to the primary <code>code</code> value.
</p>

<p>
<b>Usage Guidelines:</b>
</p>
<ul>
  <li>Aliases should be used primarily for backward compatibility when standardizing parameter names</li>
  <li>Servers that declare support for a SearchParameter SHOULD accept all defined aliases in addition to the primary code</li>
  <li>New implementations SHOULD use the primary code rather than aliases</li>
  <li>Aliases are displayed in the SearchParameter registry and resource search parameter tables</li>
</ul>

<p>
<b>Example:</b> A search parameter previously named <code>authoredon</code> might be updated to use <code>authored</code> as the primary code (for consistency with other resources) while retaining <code>authoredon</code> as an alias for backward compatibility.
</p>

<a name="deriving"></a>
<h2>Deriving Search Parameters</h2>

<p>
When one SearchParameter has a <code>derivedFrom</code> referencing another SearchParameter, the following rules SHOULD be followed. 
Note that these rules are asserted as SHOULD rather than SHALL only because they were introduced after the resource became normative. 
Systems that fail to follow these rules are likely to result in unsafe interoperability.
</p>
<p>
A derived SearchParameter:
</p>
<ul>
  <li>SHOULD NOT have <code>experimental=false</code> if the original SearchParameter has <code>experimental=true</code></li>
  <li>SHOULD have the same <code>type</code> as the original SearchParameter</li>
  <li>SHOULD have the same <code>processingMode</code> as the original SearchParameter</li>
  <li>
    SHOULD NOT have values for <code>multipleOr</code> or <code>multipleAnd</code> that contradict a value stated in the original SearchParameter. 
    I.e. If the base does not declare these, the derived SearchParameter can. However, if the base does declare them, the derived SearchParameter SHOULD have the same values.
  </li>
  <li>SHOULD have a <code>target</code> that is equivalent to or a subset of the original SearchParameter <code>target</code></li>
  <li>SHOULD have <code>comparator</code> and <code>modifier</code> values that are the same as or a superset of those defined in the base.</li>
  <li>SHOULD have the same number of components listed in the same order, where the <code>definition</code> must be the same or a derived SearchParameter, and the <code>expression</code> must be the same.</li>
  <li>MAY add values for <code>chain</code> but SHOULD NOT remove or re-order values already listed in the base.</li>
</ul>

<blockquote class="ballot-note">
Request for ballot feedback: We would like the 'SHOULD' assertions above to become 'SHALL' assertions.
We are invoking our usual implementer outreach process to find out whether anyone else objects, but please file tickets for any rules you do not believe can be enforced that way.
</blockquote>

</div>
