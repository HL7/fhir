<div xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/1999/xhtml ../../schema/fhir-xhtml.xsd" xmlns="http://www.w3.org/1999/xhtml">

<a name="naming-conventions"></a>
<h2>Naming Conventions for Search Parameters</h2>
<p>
HL7-defined search parameters follow these naming conventions:
</p>
<ul>
  <li>Use lowercase letters with hyphens for multi-word parameters (kebab-case)</li>
  <li>Prefer shorter, more common terms when possible</li>
  <li>Be consistent across resources when the same concept is searched (e.g., <code>authored</code> for authoring dates)</li>
  <li>Avoid abbreviations unless widely understood</li>
  <li>Use singular forms unless the concept is inherently plural</li>
  <li>Use of a prefix underscore character (<code>_</code>) compliant with the rules of the <a href="http.html#styleguide">Style Guide</a></li>
</ul>



<a name="notes"></a>
<h2>Notes</h2>
<ul>
  <li>
    If the extension's context specifies multiple resources, they are represented with multiple 
    elements in the <code>SearchParameter.base</code> array
  </li>
  <li>
    An expression like <code>Resource.descendents.extension('extension-url').value</code> is possible, but this 
    is a low performance option for a server to evaluate, and search parameter expressions are performance 
    sensitive
  </li>
</ul>

<a name="fhirpath"></a>
<h2>Use of FHIRPath in Expressions</h2>
<ul>
  <li>
    An expression like <code>Resource.descendents().extension('extension-url').value</code> is possible, but this 
    is a low performance option for a server to evaluate, and search parameter expressions are performance 
    sensitive
  </li>
  <li>
    While SearchParameter.expression allows for the full use of FHIRPath, including resolve() in a search
    parameter definition makes it difficult to support for transactional servers. For that reason, this
    specification does not define parameters that link across resource instance boundaries.<br/>
    This specification does use search parameters with resolve() to narrow types
    (e.g., Observation.subject.resolve() is Patient). We recommend that other specifications follow the
    same practice - chaining is the mechanism defined to search across resource boundaries.
  </li>
</ul>

<blockquote class="note-to-balloters">
  <p>
    Balloter feedback requested: We are seeking input on approaches to managing the balance between expressiveness and performance impact on servers from the use of various FHIRPath features in search parameter expressions.
  </p>
</blockquote>


<a name="srch"></a>
<h2>SearchParameters on Extensions</h2>
<p>
The SearchParameter resource may be used to define searches on extensions.
A simple definition defines the code, the base resource the extension can be 
found in, and a type, and an expression. Assume that the extension is <code>http://example.org/fhir/StructureDefinition/extension-thumb-length</code>
which has a value that is a quantity, and that is used on patient, then an appropriate SearchParameter would be:
</p>
<pre class="json">
   "code" : "thumb-length",
   "base" : ["Patient"],
   "type" : "quantity",
   "expression" : "Patient.extension('http://example.org/fhir/StructureDefinition/extension-thumb-length').value"
</pre>
<p>
Servers MAY attempt to process expressions that just select the extension without the <code>.value</code>, but this
is not required and may be discouraged or deprecated in the future. 
</p>
<p>
Extensions may have multiple types with different search behaviors, so the type can be specifically selected:
</p>
<pre class="json">
   "code" : "thumb-length-code",
   "base" : ["Patient"],
   "type" : "token",
   "expression" : "Patient.extension('http://example.org/fhir/StructureDefinition/extension-thumb-length').value.ofType(CodeableConcept)"
</pre>
<p>
This example would select coded thumb lengths and index them only for the <code>thumb-length-code</code> search parameter.
When an extension can have multiple types with incompatible search behavior, the search 
parameters have to do this. Note that is type casting the extension directly (e.g.
<code>Patient.extension('...').ofType(CodeableConcept)</code>) will lead to an empty index, 
since the extension is not a CodeableConcept itself.
</p>
<p>
When extensions can be used in multiple places, these places are enumerated in the expression:
</p>
<pre>
Patient.extension('http://example.org/fhir/StructureDefinition/extension-thumb-length').value
 | Patient.contact.extension('http://example.org/fhir/StructureDefinition/extension-thumb-length').value
 | Practitioner.extension('http://example.org/fhir/StructureDefinition/extension-thumb-length').value
</pre>

<a name="alias"></a>
<h4>Search Parameter Aliases</h4>

<p>
To support evolution toward consistent naming conventions while maintaining backward compatibility, <code>SearchParameter</code> resources 
MAY define one or more <code>aliasCode</code> values. These aliases represent suggested alternative codes that can be used to reference the search 
parameter in addition to the primary <code>code</code> value.
</p>

<p>
<b>Usage Guidelines:</b>
</p>
<ul>
  <li>Aliases should be used primarily for backward compatibility when standardizing parameter names</li>
  <li>Servers that declare support for a SearchParameter SHOULD accept all defined aliases in addition to the primary code</li>
  <li>New implementations SHOULD use the primary code rather than aliases</li>
  <li>Aliases are displayed in the SearchParameter registry and resource search parameter tables</li>
</ul>

<p>
<b>Example:</b> A search parameter previously named <code>authoredon</code> might be updated to use <code>authored</code> as the primary code (for consistency with other resources) while retaining <code>authoredon</code> as an alias for backward compatibility.
</p>

</div>
