<!DOCTYPE HTML>

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
[%settitle FHIRPath%]
[%file newheader%]
</head>
<body>
[%file newnavbar%]

<div class="col-12">

<h2>FHIRPath</h2>
<table class="cols"><tr><td id="wg"><a _target="blank" href="[%wg its%]">[%wgt its%]</a> Work Group</td><td id="fmm"><a href="../publish/versions.html#maturity">Maturity Level</a>: 0</td><td id="ballot"><a href="versions.html#levels">Ballot Status</a>: <a href="history.html#pubs">Draft</a></td></tr></table>

<p>
Note: this content is a joint development between the FHIR project 
and the CQL project. It is intended that this will be published 
as its own standard. As a temporary measure, it is 
included in FHIR until publishing questions are resolved.
</p>

<p>
FHIRPath is a path based navigation and extraction language, 
somewhat like XPath. Operations are expressed in terms of the logical 
content of hierarchical data models, and support traversal, selection 
and projection of data. Its design was influenced by the needs for 
path navigation, selection and formulation of invariants in both HL7 
Fast Healthcare Interoperability Resources (FHIR) and HL7 Clinical 
Quality Language (CQL).
</p>
<p>
In both FHIR and CQL, this means that expressions can be written 
that deal with the contents of the resources and data types as 
described in the Logical views, or the UML diagrams, rather than 
against the physical representation of those resources. JSON and 
XML specific features are not visible to the FHIRPath language 
(such as comments and the split representation of primitives).
</p>

<p>
The expressions can in theory be converted to equivalent expressions in 
XPath, OCL, or another similarly expressive language.
</p>

<h3>1. Navigation model</h3>

<p>
FHIRPath navigates and selects nodes from a tree that abstracts away 
and is independent of the actual underlying implementation of the source 
against which the FHIRPath query is run. This way, FHIRPath can be 
used on in-memory Java POJOs, Xml data or any other physical representation, 
so long as that representation can be viewed as classes that have properties. In 
somewhat more formal terms, FHIRPath operates on a directed acyclic graph of 
classes as defined by a MOF-equivalent type system.
</p>

<p>
Data is represented as a tree of labeled nodes, where each node may optionally 
carry a primitive value and have child nodes. Nodes need not have a unique label, 
and leaf nodes must carry a primitive value. For example, a (partial) 
representation of a FHIR Patient resource in this model looks like this:
</p>

<p>
<img src="treestructure.png" alt="Tree representation of a Patient" style="max-width:100%;"/>
</p>

<p>
The diagram shows a tree with a repeating <code>identifier</code> node, which represents 
repeating members of the FHIR object model. Leaf nodes such as <code>use</code> and 
<code>family</code> carry a (string) value. It is also possible for internal nodes 
to carry a value, as is the case for the node labeled <code>active</code>: this 
allows the tree to represent FHIR "primitives", which may still have child extension data.
</p>

<h3>2. Path selection</h3>

<p>FHIRPath allows navigation in the tree by composing a path of concatenated labels, e.g.</p>

<pre><code>name.given</code></pre>

<p>
This would result in a set of nodes, one with the value "Wouter" and one with the value 
"Gert". In fact, each step in such a path results in a collection of nodes by selecting nodes 
with the given label from the step before it. The focus at the beginning of the evaluation 
contained all elements from Patient, and the path <code>name</code> selected just those 
named <code>name</code>. Since the <code>name</code> element repeats, the next step 
<code>given</code> along the path, will contain all nodes labeled <code>given</code> from 
all nodes <code>name</code> in the preceding step. 
</p>

<p>
The underlying type of the entry point (here: Patient) can be represented, but is optional. 
To illustrate this point, the path <code>name.given</code> above can be evaluated as an 
expression on a set of data of any type. However, for natural human use, expressions may 
be prefixed with the name of the type:</p>

<pre><code>Patient.name.given</code></pre>

<p>
The two expressions have the same outcome, but when evaluating the second, the evaluation 
will only produce results when used on data of type <code>Patient</code>.
</p>

<p>
Syntactically, FHIRPath defines identifiers as any sequence of characters consisting only of letters, digits, and underscores, beginning with a letter or underscore. Paths may use double quotes to include characters in path parts that would otherwise 
be interpreted as operators, e.g.:
</p>

<pre><code>Message."PID-1"</code></pre>

<h4>3.1 Paths and polymorphic items</h4>

<p>
In the underlying representation of data, nodes may be typed and represent polymorphic items. 
Paths may either ignore the type of a node, and continue along the path or may be explicit 
about the expected node and filter the set of nodes by type before navigating down child nodes: 
</p>

<pre><code>Observation.value.unit - all kinds of value 
Observation.value.as(Quantity).unit - only values that are of type Quantity</code></pre>

<p>
The <code>is</code> function can be used to determine whether or not a given value is of a given type:
</p>

<pre><code>Observation.value.is(Quantity) - returns true if the value is of type Quantity</code></pre>

<p>
The list of available types that can be passed as a parameter to the 
<code>as</code> and <code>is</code> functions is determined by the 
underlying data model.
</p>

<h4>3.2 Referring to the current item</h4>

<p>
It is sometimes useful to refer to the current item under evaluation when writing an expression, 
especially within <code>where()</code> when the value of the current item needs to be passed as 
a function parameter. This can be done using the special path <code>$this</code>:
</p>

<pre><code>Patient.name.given.where(substring($this.length()-3)) = 'out'</code></pre>

<h4>3.3 Order nodes and traversal</h4>

<p>
Collections of nodes are inherently ordered, and implementations must 
retain the original order of a collection. There are two special cases: 
the outcome of operations like <code>children()</code> and <code>descendants()</code> 
cannot be assumed to be in any meaningful order, and <code>first()</code>, 
<code>last()</code>, <code>tail()</code>, <code>skip()</code> and <code>take()</code> 
should not be used on collections derived from these paths. Note that some 
implementations may follow the standard order, and some may not, and some may 
be different depending on the underlying source.</p>

<h3>4. Expressions</h3>

<p>
In addition to paths, FHIRPath expressions may contain <em>literals</em> and 
<em>function invocations</em>. FHIRPath supports the following types of literals:</p>

<pre><code>boolean: true, false
string: 'test string', 'urn:oid:3.4.5.6.7.8'
integer: 0, 45
decimal: 0.0, 3.141592653587793236
datetime: @2015-02-04T14:34:28Z - @ followed by ISO8601 compliant date/time
time: @T14:34:28Z @ followed by ISO8601 compliant time (beginning with T)</code></pre>

<p>
Unicode is supported in both string literals and quoted identifiers. String literals are surrounded 
by single quotes and may use <code>\</code>-escapes to escape quotes and represent Unicode characters:</p>

<ul>
 <li>Unicode characters may be escaped using <code>\u</code> followed by four hex digits.</li>
 <li>Additional escapes are those supported in JSON:
 <ul>
  <li><code>\\</code> (backslash), </li>
  <li><code>\/</code> (slash), </li>
  <li><code>\f</code> (form feed - \u000c),</li>
  <li><code>\n</code> (newline - \u000a), </li>
  <li><code>\r</code> (carriage return - \u000d), </li>
  <li><code>\t</code> (tab - \u0009)</li>
  </ul>
 </li>
</ul>

<p>
Numbers can be integers and may optionally have decimal parts. Numbers cannot use exponential notation.
</p>

<p>
Expressions can also contain <em>operators</em>, like those for mathematical operations and boolean logic:
</p>

<pre><code>Appointment.minutesDuration / 60 &gt; 5
MedicationAdministration.wasNotGiven.exists() implies MedicationAdministration.reasonNotGiven.exists()
name.given | name.last
'sir ' + name.given</code></pre>

<p>
Finally, FHIRPath supports the notion of functions, which all take a collection of values as input 
and produce another collection as output. For example:</p>

<pre><code>(name.given | name.last).distinct()
identifier.where(use = 'official')</code></pre>

<p>Since all functions work on collections, constants will first be converted to a collection when functions are invoked on constants:</p>

<pre><code>(4+5).count()</code></pre>

<p>will return <code>1</code>, since this is implicitly a collection with one constant number <code>9</code>.</p>

<blockquote>
<p>Note: There is no concept of <code>null</code> in FHIRPath. This means that when, in an underlying instance a member is null, there will simply be no corresponding node for that member in the tree. This means that for example <code>Patient.children()</code> will contain only non-null members and <code>Patient.name</code> will return an empty collection if there are no name elements in the instance.</p>
</blockquote>

<h4>4.1 Boolean evaluation of collections</h4>

<p>Collections can be evaluated as booleans in logical tests in criteria. When a collection is implicitly converted to a boolean then:</p>

<ul>
<li>IF the collection contains a single node AND the node's value is a boolean THEN

<ul>
<li>the collection evaluates to the value of that single boolean node</li>
</ul></li>
<li>ELSE IF the collection is empty THEN

<ul>
<li>the collection evaluates to an empty collection</li>
</ul></li>
<li>ELSE 

<ul>
<li>the collection evaluates to <code>true</code></li>
</ul></li>
</ul>

<p>This same principle applies when using the path statement in invariants.</p>

<blockquote>
<p>Note: Because the path language is side effect free, it does not matter whether implementations use short circuit boolean evaluation or not. However with regard to performance, implementations are encouraged to use short circuit evaluation, and authors of path statements should pay attention to short circuit evaluation when designing statements for optimal performance.</p>
</blockquote>

<h4>4.2 Propagation of empty results</h4>

<p>FHIRPath functions and operators both propagate empty results. This means in general that if any input to a function or operator is empty, then the result will be empty as well. More specifically:</p>

<ul>
<li>If a function operates on an empty collection, the result is an empty collection</li>
<li>If a function is passed an empty collection as argument, the result is an empty collection</li>
<li>If any operand to an operator is an empty collection, the result is an empty collection.</li>
</ul>

<p>When functions behave differently (for example the <code>count()</code> and <code>empty()</code> functions), this is clearly documented in the next sections.</p>

<h3>5. Functions</h3>

<p>Functions are distinguished from path navigation names by the fact that they are followed by a <code>()</code> with zero or more parameters. Functions always take a collection as input and produce another collection as output, even though these may be collections of just a single item. Correspondingly, arguments to the functions can be any FHIRPath expression, though some functions require these expressions to evaluate to a collection containing a single item of a specific type.</p>

<p>The following list contains all functions supported in FHIRPath, detailing the expected kind of parameters and kind of collection returned by the function:</p>

<ul>
<li>If the function expects a parameter to be a single value (e.g. <code>item(index: integer)</code> and it is passed an argument that evaluates to a collection with multiple items or a collection with an item that is not of the required type, the evaluation of the expression will end and an error will be signaled to the calling environment.</li>
<li><p>If the function takes an <code>expression</code> as a parameter, the function will evaluate this parameter with respect to each of the items in the input collection. These expressions may refer to the special <code>$this</code> element, which represents the item from the input collection currently under evaluation. For example, in:</p>

<pre><code>name.given.where($this &gt; 'ba' and $this &lt; 'bc')
</code></pre>

<p>the <code>where()</code> function will iterate over each item in the input collection (elements named <code>given</code>) and <code>$this</code> will be set to each item when the expression passed to <code>where()</code> is evaluated.</p></li>
<li>Optional parameters are enclosed in square brackets in the definition of a function.</li>
<li>All functions return a collection, but if this is a single item of a predefined type, the description of the function will specify its output type explicitly, instead of just stating <code>collection</code>, e.g. <code>all(...) : boolean</code></li>
</ul>

<h4>5.1 Existence</h4>

<p><b>empty() : boolean</b></p>

<p>Returns <code>true</code> if the input collection is empty (<code>{ }</code>) and <code>false</code> otherwise.</p>

<p><b>not() : boolean</b></p>

<p>Returns <code>true</code> if the input collection evaluates to <code>false</code>, and <code>false</code> if it evaluates to <code>true</code>. Otherwise, the result is empty (<code>{ }</code>):</p>

<table><thead>
<tr>
<th> </th>
<th>not</th>
</tr>
</thead><tbody>
<tr>
<td><code>true</code></td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>false</code></td>
<td><code>true</code></td>
</tr>
<tr>
<td>empty (<code>{ }</code>)</td>
<td>empty (<code>{ }</code>)</td>
</tr>
</tbody></table>

<p><b>exists() : boolean</b></p>

<p>Returns the opposite of <code>empty()</code>, and as such is a shorthand for <code>empty().not()</code></p>

<p><b>all() : boolean</b></p>

<p>Returns <code>true</code> if every element in the input collection evaluates to <code>true</code>, and <code>false</code> if any element evaluates to <code>false</code>. Otherwise, the result is empty (<code>{ }</code>).
</p>

<p><b>subsetOf(other : collection) :  boolean</b></p>

<p>Returns <code>true</code> if all items in the input collection are members of the collection passed as the <code>other</code> argument. Membership is determined using the equals (<code>=</code>) operation (see below).</p>

<p><b>supersetOf(other : collection) : boolean</b></p>

<p>Returns <code>true</code> if all items in the collection passed as the <code>other</code> argument are members of the input collection. Membership is determined using the equals (<code>=</code>) operation (see below).</p>

<p><b>isDistinct() : boolean</b></p>

<p>Returns <code>true</code> if all the items in the input collection are distinct. To determine whether two items are distinct, the equals (<code>=</code>) operator is used, as defined below.</p>

<p><b>distinct() : collection</b></p>

<p>Returns a collection containing only the unique items in the input collection. To determine whether two items are the same, the equals (<code>=</code>) operator is used, as defined below.</p>

<p><b>count() : integer</b></p>

<p>Returns a collection with a single value which is the integer count of the number of items in the input collection. Returns 0 when the input collection is empty.</p>

<h4>5.2 Filtering and projection</h4>

<p><b>where(criteria : expression) : collection</b></p>

<p>Filter the input collection to only those elements for which the stated criteria expression evaluates to true.</p>

<p><b>select(projection: expression) : collection</b></p>

<p>Evaluates the given expression for each item in the input collection. The result of each evaluation is added to the output collection. If the evaluation results in a collection with multiple items, all items are added to the output collection (collections resulting from evaluation of <code>projection</code> are <em>flattened</em>).</p>

<p><b>repeat(projection: expression) : collection</b></p>

<p>A version of <code>select</code> that will repeat the projection and add it to the output collection, as long as the projection yields new items (as determined by the Equals operator). </p>

<p>This operation can be used to traverse a tree and selecting only specific children:</p>

<pre><code>ValueSet.expansion.repeat(contains)
</code></pre>

<p>Will repeat finding children called <code>contains</code>, until no new nodes are found.</p>

<pre><code>Questionnaire.repeat(group | question).question
</code></pre>

<p>Will repeat finding children called <code>group</code> or <code>question</code>, until no new nodes are found.</p>

<p>Note that this is slightly different from</p>

<pre><code>Questionnaire.descendants().select(group | question)
</code></pre>

<p>which would find <strong>any</strong> descendants called <code>group</code> or <code>question</code>, not just the ones nested inside other <code>group</code> or <code>question</code> elements.</p>

<p><b>is(type : identifier) : boolean</b></p>

<p>Returns <code>true</code> if the collection contains a single element of the given type or a subclass thereof.</p>

<p><b>as(type : identifier) : collection</b></p>

<p>Returns a collection that contains all items in the input collection that are of the given type or a subclass thereof.</p>

<h4>5.3 Subsetting</h4>

<p><b><em>name</em>[ index : integer ] : collection</b></p>

<p>This indexer operation returns a collection with only the <code>index</code>-th item (0-based index). If the index lies outside the boundaries of the input collection, an empty collection is returned.</p>

<p>Example:</p>

<pre><code>Patient.name[0]
</code></pre>

<p><b>single() : collection</b></p>

<p>Will return the single item in the input if there is just one item. If there are multiple items, an error is signaled to the evaluation environment.</p>

<p><b>first() : collection</b></p>

<p>Returns a collection containing just the first item in the list. Equivalent to <code>item(0)</code>, so it will return an empty collection if the input collection has no items.</p>

<p><b>last() : collection</b></p>

<p>Returns a collection containing the last item in the list. Will return an empty collection if the input collection has no items.</p>

<p><b>tail() : collection</b></p>

<p>Returns a collection containing all but the first item in the list. Will return an empty collection if the input collection has no or just one item.</p>

<p><b>skip(num : integer) : collection</b></p>

<p>Returns a collection containing all but the first <code>num</code> items in the list. Will return an empty collection if there are no items remaining after the indicated number of items have been skipped.</p>

<p><b>take(num : integer) : collection</b></p>

<p>Returns a collection containing the first <code>num</code> items in the list, or less if there are less then <code>num</code> items. Will return an empty collection if the input collection is empty.</p>

<h4>5.5 Conversion</h4>

<p>The functions in this section operate on collections with a single item. If there is more than one item, or an incompatible item, the evaluation of the expression will end and signal an error to the calling environment.</p>

<p>To use these functions over a collection with multiple items, one may use filters like <code>where()</code> and <code>select()</code>:</p>

<pre><code>Patient.name.given.select(substring(1))
</code></pre>

<p><b>iif(criterium: expression, true-expression [, otherwise-expression]) : collection</b></p>

<p>If the input collection contains a single item, this function evaluates the <code>criterium</code> expression. If this expression evaluates to true, the function evaluates the <code>true-expression</code> on the input and returns that as a result. </p>

<p>If the evaluation resulted in <code>false</code> or an empty collection, the <code>otherwise-expression</code> is evaluated on the input and returned, unless the optional <code>otherwise-expression</code> is not given, in which case the function returns an empty collection.</p>

<p>If the input has multiple items or is empty, the function will return an empty collection.</p>

<p><b>toInteger() : integer</b></p>

<p>If the input collection contains a single item, this function will return a single integer if:</p>

<ul>
<li>the item in the input collection is an integer</li>
<li>the item in the input collection is a string and is convertible to an integer</li>
<li>the item is a boolean, where <code>true</code> results in a 1 and <code>false</code> results in a 0.</li>
</ul>

<p>In all other cases, the function will return an empty collection.</p>

<p><b>toDecimal() : decimal</b></p>

<p>If the input collection contains a single item, this function will return a single decimal if:</p>

<ul>
<li>the item in the input collection is a decimal</li>
<li>the item in the input collection is a string and is convertible to a decimal</li>
<li>the item is a boolean, where <code>true</code> results in a 1 and <code>false</code> results in a 0.</li>
</ul>

<p>In all other cases, the function will return an empty collection.</p>

<p><b>toString() : string</b></p>

<p>If the input collection contains a single item, this function will return a single string if:</p>

<ul>
<li>the item in the input collection is a string</li>
<li>the item in the input collection is a number, the output will contain its string representation</li>
<li>the item is a boolean, where <code>true</code> results in "true" and <code>false</code> in "false".</li>
</ul>

<p>In all other cases, the function will return an empty collection.</p>

<h4>5.6 String manipulation</h4>

<p>The functions in this section operate on collections with a single item. If there is more than one item, or an incompatible item, the evaluation of the expression will end and signal an error to the calling environment.</p>

<p><b>substring(start : integer [, length : integer]) : collection</b></p>

<p>If the input collection contains a single item of type string, it returns a collection with the part of the string starting at position <code>start</code> (zero-based). If <code>length</code> is given, will return at most <code>length</code> number of characters from the input string.</p>

<p>If <code>start</code> lies outside the length of the string, the function returns an empty collection. If there are less remaining characters in the string than indicated by <code>length</code>, the function returns just the remaining characters.</p>

<p><b>startsWith(string : string) : boolean</b></p>

<p>If the input collection contains a single item of type string, the function will return <code>true</code> when the  value starts with the specified content.</p>

<p><b>endsWith(string : string) : boolean</b></p>

<p>If the input collection contains a single item of type string, the function will return <code>true</code> when the value ends with the specified content.</p>

<p><b>matches(regex : string) : boolean</b></p>

<p>If the input collection contains a single item of type string, the function will return true when the  value matches the given regular expression. Regular expressions are supposed to work culture invariant, case-sensitive and in 'single line' mode and allow Unicode characters. </p>

<p><b>replaceMatches(regex : string, substitution: string) : string</b></p>

<p>If the input collection contains a single item of type string, the function will match the input using the regular expression in <code>regex</code> and replace each match with the <code>substitution</code> string. The substitution may refer to identified match groups in the regular expression. </p>

<p>This example of <code>replaceMatches()</code> will convert a string with a date formatted as MM/dd/yy to dd-MM-yy:</p>

<pre><code>'11/30/1972'.replaceMatches('\\b(?&lt;month&gt;\\d{1,2})/(?&lt;day&gt;\\d{1,2})/(?&lt;year&gt;\\d{2,4})\\b',
       '${day}-${month}-${year}')
</code></pre>

<blockquote>
<p>Note: All platforms will use their native regular expression implementations, which will commonly be close to the regular expressions in Perl 5, however there are always small differences. I don't think we can prescribe any "common" dialect for FHIRPath.</p>
</blockquote>

<p><b>contains(string : string) : boolean</b></p>

<p>A simpler variation of <code>matches()</code> that returns a boolean when the given <code>string</code> is a substring of the single string in the input collection.</p>

<p><b>replace(pattern : string, substitution : string) : string</b></p>

<p>A simpler variation of <code>replaceMatches</code> that returns the input string with all instances of <code>pattern</code> replaced with <code>substitution</code>.</p>

<p><b>length() : integer</b></p>

<p>If the input collection contains a single item of type string, the function will return the length of the string.</p>

<h4>5.6 Tree navigation</h4>

<p><b>children() : collection</b></p>

<p>Returns a collection with all immediate child nodes of all items in the input collection.</p>

<p><b>descendants() : collection</b></p>

<p>Returns a collection with all descendant nodes of all items in the input collection. The result does not include the nodes in the input collection themselves. Is a shorthand for <code>repeat(children())</code>.</p>

<blockquote>
<p>Note: Many of these functions will result in a set of nodes of different underlying types. It may be necessary to use <code>as()</code> as described in the previous section to maintain type safety. See section 8 for more information about type safe use of FHIRPath expressions.</p>
</blockquote>

<h4>5.7 Utility functions</h4>

<p><b>memberOf(valueset : string) : boolean</b></p>

<p>If the input collection contains a single string item, it is taken to be a code and valueset membership is tested against the valueset passed as the argument. The <code>valueset</code> argument is a uri used to resolve to a valueset.  </p>

<p><b>trace(name : string) : collection</b></p>

<p>Add a string representation of the input collection to the log, using the parameter <code>name</code> as the name in the log. This log should be made available to the user in some appropriate fashion. Does not change the input, so returns the input collection as output.</p>

<p><b>today() : datetime</b></p>

<p>Returns a datetime containing the current date.</p>

<p><b>now() : datetime</b></p>

<p>Returns a datetime containing the current date and time, including timezone.</p>

<h3>6. Operations</h3>

<p>Operators are allowed to be used between any kind of path expressions (e.g. expr op expr). Like functions, operators will generally propagate an empty collection in any of their operands. This is true even when comparing two empty collections using the equality operators.</p>

<h4>6.1 Equality</h4>

<p><b>= (Equals)</b></p>

<p>Returns <code>true</code> if the left collection is equal to the right collection:</p>

<p>If both operands are collections with a single item:</p>

<ul>
<li>For primitives:

<ul>
<li>If the value is a string, the strings must be exactly the same</li>
<li>For numbers, equality requires that the 2 values have the same precision </li>
<li>For boolean values, the values must be the same</li>
</ul></li>
<li>For complex types, equality requires all child properties to be equal, recursively.</li>
</ul>

<p>If both operands are collections with at least one item:</p>

<ul>
<li>Each item must be equal</li>
<li>Comparison is order dependent</li>
</ul>

<p>Otherwise, equals returns <code>false</code>. </p>

<p>Note that this implies that if both collections have a different number of items to compare, the result will be <code>false</code>. </p>

<p>Typically, this operator is used with single fixed values as operands. This means that Patient.telecom.system = 'phone' will return <code>false</code> if there is more than one telecom with a <code>use</code> element. Typically, you'd want Patient.telecom.where(system = 'phone')</p>

<p>If one or both of the operands is the empty collection, this operation returns an empty collection.</p>

<p><b>~ (Equivalent)</b></p>

<p>Returns <code>true</code> if the collections are the same.</p>

<p>If both operands are collections with a single item:</p>

<ul>
<li>For primitives

<ul>
<li>If the value is a string, the strings must be the same while ignoring case and accents</li>
<li>For numbers, precision is ignored (exact rules to be discussed) </li>
<li>For boolean values, the values must be the same</li>
</ul></li>
<li>For complex types, equivalence requires all child properties to be equivalent, recursively.</li>
</ul>

<p>If both operands are collections with multiple items:</p>

<ul>
<li>Each item must be equivalent</li>
<li>Comparison is not order dependent</li>
</ul>

<p>Note that this implies that if both collections have a different number of items to compare, the result will be <code>false</code>. </p>

<p>If one or both of the operands is the empty collection, this operation returns an empty collection.</p>

<p><b>!= (Not Equals)</b></p>

<p>The inverse of the equals operator.</p>

<p><b>!~ (Not Equivalent)</b></p>

<p>The inverse of the equivalent operator.</p>

<h4>6.2 Comparison</h4>

<ul>
<li>The comparison operators are defined for strings, numbers, datetimes, and times.</li>
<li>unless there is only one item in each collection (left and right) of the same type, the comparisons return false</li>
<li>string evaluation is strictly lexical, not based on any defined meaning of order</li>
<li>If one or both of the arguments are an empty collection, the comparisons return an empty collection.</li>
</ul>

<p><b>&gt; (Greater Than)</b></p>

<p><b>&lt; (Less Than)</b></p>

<p><b>&lt;= (Less or Equal)</b></p>

<p><b>&gt;= (Greater or Equal)</b></p>

<h4>6.3 Types</h4>

<p><b>is</b></p>

<p>If the left operand is a collection with a single item and the second operand is an identifier, this operator returns <code>true</code> if the type of the left operand is the type specified in the second operand, or a subclass thereof. In all other cases this function returns the empty collection.</p>

<pre><code>Patient.contained.all($this is Patient implies age &gt; 10)
</code></pre>

<p><b>as</b></p>

<p>If the left operand is a collection with a single item and the second operand is an identifier, this function returns the value of the left operand, or a subclass thereof. Otherwise, this operator returns the empty collection.</p>

<h4>6.4 Collections</h4>

<p><b>| (union collections)</b></p>

<p>Merge the two collections into a single collection, eliminating any duplicate values (using equals (<code>=</code>)) to determine equality).</p>

<p><b>in (membership)</b></p>

<p>If the left operand is a collection with a single item, this operator returns true if the item is in the right operand using equality semantics. This is the inverse operation of contains.</p>

<p><b>contains (containership)</b></p>

<p>If the right operand is a collection with a single item, this operator returns true if the item is in the left operand using equality semantics. This is the inverse operation of in.</p>

<h4>6.5 Boolean logic</h4>

<p>For all boolean operators, the collections passed as operands are first evaluated as booleans (as described in 4.1). The operators then use three-valued logic to propagate empty operands.</p>

<p><b>and</b></p>

<p>Returns <code>true</code> if both operands evaluate to <code>true</code>, <code>false</code> if either operand evaluates to <code>false</code>, and empty collection (<code>{ }</code>) otherwise:</p>

<table><thead>
<tr>
<th> </th>
<th><code>true</code></th>
<th><code>false</code></th>
<th>empty (<code>{ }</code>)</th>
</tr>
</thead><tbody>
<tr>
<td><code>true</code></td>
<td><code>true</code></td>
<td><code>false</code></td>
<td>empty (<code>{ }</code>)</td>
</tr>
<tr>
<td><code>false</code></td>
<td><code>false</code></td>
<td><code>false</code></td>
<td><code>false</code></td>
</tr>
<tr>
<td>empty (<code>{ }</code>)</td>
<td>empty (<code>{ }</code>)</td>
<td><code>false</code></td>
<td>empty (<code>{ }</code>)</td>
</tr>
</tbody></table>

<p><b>or</b></p>

<p>Returns <code>false</code> if both operands evaluate to <code>false</code>, <code>true</code> if either operand evaluates to <code>true</code>, and empty (<code>{ }</code>) otherwise:</p>

<table><thead>
<tr>
<th> </th>
<th><code>true</code></th>
<th><code>false</code></th>
<th>empty (<code>{ }</code>)</th>
</tr>
</thead><tbody>
<tr>
<td><code>true</code></td>
<td><code>true</code></td>
<td><code>true</code></td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>false</code></td>
<td><code>true</code></td>
<td><code>false</code></td>
<td>empty (<code>{ }</code>)</td>
</tr>
<tr>
<td>empty (<code>{ }</code>)</td>
<td><code>true</code></td>
<td>empty (<code>{ }</code>)</td>
<td>empty (<code>{ }</code>)</td>
</tr>
</tbody></table>

<p><b>xor</b></p>

<p>Returns <code>true</code> if exactly one of the operands evaluates to <code>true</code>, <code>false</code> if either both operands evaluate to <code>true</code> or both operands evaluate to <code>false</code>, and the empty collection (<code>{ }</code>) otherwise:</p>

<table><thead>
<tr>
<th> </th>
<th><code>true</code></th>
<th><code>false</code></th>
<th>empty (<code>{ }</code>)</th>
</tr>
</thead><tbody>
<tr>
<td><code>true</code></td>
<td><code>false</code></td>
<td><code>true</code></td>
<td>empty (<code>{ }</code>)</td>
</tr>
<tr>
<td><code>false</code></td>
<td><code>true</code></td>
<td><code>false</code></td>
<td>empty (<code>{ }</code>)</td>
</tr>
<tr>
<td>empty (<code>{ }</code>)</td>
<td>empty (<code>{ }</code>)</td>
<td>empty (<code>{ }</code>)</td>
<td>empty (<code>{ }</code>)</td>
</tr>
</tbody></table>

<p><b>implies</b></p>

<p>If the left operand evaluates to <code>true</code>, this operator returns the boolean evaluation of the right operand. If the left operand evaluates to <code>false</code>, this operator returns <code>true</code>. Otherwise, this operator returns <code>true</code> if the right operand evaluates to <code>true</code>, and the empty collection (<code>{ }</code>) otherwise.</p>

<table><thead>
<tr>
<th> </th>
<th><code>true</code></th>
<th><code>false</code></th>
<th>empty (<code>{ }</code>)</th>
</tr>
</thead><tbody>
<tr>
<td><code>true</code></td>
<td><code>true</code></td>
<td><code>false</code></td>
<td>empty (<code>{ }</code>)</td>
</tr>
<tr>
<td><code>false</code></td>
<td><code>true</code></td>
<td><code>true</code></td>
<td><code>true</code></td>
</tr>
<tr>
<td>empty (<code>{ }</code>)</td>
<td><code>true</code></td>
<td>empty (<code>{ }</code>)</td>
<td>empty (<code>{ }</code>)</td>
</tr>
</tbody></table>

<h4>6.6 Math</h4>

<p>The math operators require each operand to be a single element. Both operands must be of the same type, each operator below specifies which types are supported.</p>

<p>If there is more than one item, or an incompatible item, the evaluation of the expression will end and signal an error to the calling environment.</p>

<p>As with the other operators, the math operators will return an empty collection if one or both of the operands are empty. </p>

<p><b>* (multiplication)</b></p>

<p>Multiplies both arguments (numbers only)</p>

<p><b>/ (division)</b></p>

<p>Divides the left operand by the right operand (numbers only). </p>

<p><b>+ (addition)</b></p>

<p>For numbers, add the numbers. For strings, concatenates the right operand to the left operand.</p>

<p><b>- (subtraction)</b></p>

<p>Subtracts the right operand from the left operand (numbers only).</p>

<p><b>div</b></p>

<p>Performs truncated division of the left operand by the right operand (numbers only).</p>

<p><b>mod</b></p>

<p>Computes the remainder of the truncated division of its arguments (numbers only).</p>

<h4>6.5 Operator precedence</h4>

<p>Precedence of operations, in order from high to low:</p>

<pre><code>#01 . (path/function invocation)
#02 [] (indexer)
#03 unary + and -
#04: *, /, div, mod
#05: +, -, 
#06: |
#07: &gt;, &lt;, &gt;=, &lt;=
#08: is, as
#09: =, ~, !=, !~
#10: in, contains
#11: and 
#12: xor, or
#13: implies
</code></pre>

<p>As customary, expressions may be grouped by parenthesis (<code>()</code>).</p>

<h3>7. Environment variables</h3>

<p>A token introduced by a % refers to a value that is passed into the evaluation engine by the calling environment. Using environment variables, authors can avoid repetition of fixed values and can pass in external values and data.</p>

<p>The following environmental values are set for all contexts:</p>

<pre><code>%sct        - (string) url for snomed ct
%loinc      - (string) url for loinc
%ucum       - (string) url for ucum
%"vs-[name]" - (string) full url for the provided HL7 value set with id [name]
%"ext-[name]" - (string) full url for the provided HL7 extension with id [name]
%context    - The original node that was passed to the evaluation engine before starting evaluation

Note how the names of the `vs-` and `ext-` constants are escaped (just like paths) to allow "-" in the name. 
</code></pre>

<p>Implementers should note that using additional environment variables is a formal extension point for the language. Implementation Guides are allowed to define their own externals, and implementers should provide some appropriate configuration framework to allow these constants to be provided to the evaluation engine at run time. E.g.:</p>

<pre><code>%us-zip = '[0-9]{5}(-[0-9]{4}){0,1}'
</code></pre>

<p>Authors of Implementation Guides should be aware that adding specific environment variables restricts the use of the FHIRPath to their particular context. </p>

<p>Note that these tokens are not restricted to simple types, and they may not have defined fixed values that are known before evaluation at run-time, though there is no way to define these kind of values in implementation guides.</p>

<h3>8. Type safety and strict evaluation</h3>

<p>Strongly typed languages are intended to help authors avoid mistakes by ensuring that expressions written describe valid operations. For example, a strongly typed language would typically disallow the expression:</p>

<pre><code>1 + 'John'
</code></pre>

<p>because it performs an invalid operation, namely adding numbers and strings. However, there are cases where the author knows that a particular invocation may be safe, but the compiler is not aware of, or cannot infer, the reason. In these cases, type-safety errors can become an unwelcome burden, especially for experienced developers.</p>

<p>As a result, FHIRPath defines a <em>strict</em> option that allows an execution environment to determine how much type safety should be applied. With <em>strict</em> enabled, FHIRPath behaves as a traditional strongly-typed language, whereas without <em>strict</em>, it behaves as a traditional dynamically-typed language.</p>

<p>For example, since some functions and most operators will only accept a single item as input, and throw an exception otherwise:</p>

<pre><code>Patient.name.given + ' ' + Patient.name.family
</code></pre>

<p>will work perfectly fine, as long as the patient has a single name, but will fail otherwise. It is in fact "safer" to formulate such statements as either:</p>

<pre><code>Patient.name.select(given + ' ' + family)
</code></pre>

<p>which would return a collection of concatenated first and last names, one for each name of a patient. Of course, if the patient turns out to have multiple given names, even this statement will fail and the author would need to choose the first name in each collection explicitly:</p>

<pre><code>Patient.name.first().select(given.first() + ' ' + family.first())
</code></pre>

<p>It is clear that, although more robust, the last expression is also much more elaborate, certainly in situations where, because of external constraints, the author is sure names will not repeat, even if the unconstrained data model allows repetition.</p>

<p>Apart from throwing exceptions, unexpected outcomes may result because of the way the equality operators are defined. The expression</p>

<pre><code>Patient.name.given = 'Wouter'
</code></pre>

<p>will return false as soon as a patient has multiple names, even though one of those may well be 'Wouter'. Again, this can be corrected:</p>

<pre><code>Patient.name.where(given = 'Wouter').exists()
</code></pre>

<p>but is still less concise than would be possible if constraints were well known in advance.</p>

<p>The strict option provides a mode in which the author of the FHIRPath statement is protected against such cases by employing strict typing. Based on the definition of the operators and functions and given the type of input, a compiler can trace the statement and determine whether "unsafe" situations can occur.</p>

<p>Unsafe uses are:</p>

<ul>
<li>A function that requires an input collection with a single item is called on an output that is not guaranteed to have only one item.</li>
<li>A function is passed an argument that is not guaranteed to be a single value.</li>
<li>A function is passed an input value or argument that is not of the expected type</li>
<li>An operator that requires operands to be collections with a single item is called with arguments that are not guaranteed to have only one item.</li>
<li>An operator has operands that are not of the expected type</li>
<li>Equality operators are used on operands that are not both collections or collections of single items.</li>
</ul>

<p>There are a few constructs in the FHIRPath language where the compiler cannot trace the type, and should issue a warning to the user when doing "strict" evaluation:</p>

<ul>
<li>The <code>children()</code> and <code>descendants()</code> functions</li>
<li>The <code>resolve()</code> function</li>
<li>A member which is polymorphic (e.g. a choice[x] type in FHIR)</li>
</ul>

<p>Authors can use the <code>as()</code> function directly after such constructs to inform the compiler of the expected type, so that strict type-checking can continue.</p>

<p>In strict mode, when the compiler finds places where a collection of multiple items can be present while just a single item is expected, the author will need to make explicit how repetitions are dealt with. Depending on the situation one may:</p>

<ul>
<li>Use <code>first()</code>, <code>last()</code> or indexer (<code>[ ]</code>) to select a single item</li>
<li>Use <code>select()</code> and <code>where()</code> to turn the expression into one that evaluates each of the repeating items individually (as in the examples above)</li>
<li>Use <code>single()</code> to return either the single item or else an empty collection. This is especially useful when using FHIRPath to formulate invariants: in cases where single items are considered the "positive" or "true" situation, <code>single()</code> will return an empty collection, so the invariant will evaluate to the empty collection (or false) in any other circumstance.</li>
</ul>

<h3>Appendix A - Use of FHIRPath in HL7 FHIR</h3>

<p>FHIRPath is used in five places in the FHIR specifications:</p>

<ul>
<li>search parameter paths - used to define what contents the parameter refers to </li>
<li>slicing discriminator - used to indicate what element(s) define uniqueness</li>
<li>invariants in ElementDefinition, used to apply co-occurrence and other rules to the contents </li>
<li>error message locations in OperationOutcome</li>
<li>URL templates in Smart on FHIR's cds-hooks</li>
<li>may be used for Patch in the future</li>
</ul>

<p>As stated in the introduction, FHIRPath uses a tree model that abstracts away the actual underlying datamodel of the data being queries. For FHIR, this means that the contents of the resources and data types as described in the Logical views (or the UML diagrams) are used as the model, rather than the JSON and XML formats, so specific xml or json features are not visible to the FHIRPath language (such as comments and the split representation of primitives).</p>

<p>More specifically:</p>

<ul>
<li>A FHIRPath may optionally start with a full resource name</li>
<li>Elements of datatypes and resources are used as the name of the nodes which can be navigated over, except for choice elements (ending with '[x]'), see below.</li>
<li>The <code>contained</code> element node does not have the name of the Resource as its first and only child (instead it directly contains the contained resource's children)</li>
<li>There is no difference between an attribute and an element</li>
<li>Repeating elements turn into multiple nodes with the same name</li>
</ul>

<h4>A.1 Polymorphism in FHIR</h4>

<p>FHIR has the notion of choice elements, where elements can be one of multiple types, e.g. <code>Patient.deceased[x]</code>. In actual instances these will be present as either <code>Patient.deceasedBoolean</code> or <code>Patient.deceasedDateTime</code>. In FHIRPath choice elements are labeled according to the name without the '[x]' suffix, and children can be explicitly filtered using the <code>asType</code> operation:</p>

<pre><code>Observation.value.as(Quantity).unit
</code></pre>

<h4>A.2 Using FHIR types in expressions</h4>

<p>The evaluation engine will automatically convert the value of FHIR types representing primitives to FHIRPath types when they are used in expression in the following fashion:</p>

<table><thead>
<tr>
<th>FHIR primitive type</th>
<th>FHIRPath type</th>
</tr>
</thead><tbody>
<tr>
<td>boolean</td>
<td>boolean</td>
</tr>
<tr>
<td>string, uri, code, oid, id, uuid, sid, markdown, base64Binary</td>
<td>string</td>
</tr>
<tr>
<td>integer, unsignedInt, positiveInt</td>
<td>integer</td>
</tr>
<tr>
<td>decimal</td>
<td>decimal</td>
</tr>
<tr>
<td>date, dateTime, instant</td>
<td>datetime</td>
</tr>
<tr>
<td>time</td>
<td>time</td>
</tr>
</tbody></table>

<p>Note that FHIR primitives may contain extensions, so that the following expressions are <em>not</em> mutually exclusive:</p>

<pre><code>Patient.name.given = 'Ewout'            // value of Patient.name.given as a string
Patient.name.given.extension.first().value = true   // extension of the primitive value
</code></pre>

<h4>A.3 Additional functions</h4>

<p>FHIR adds (backwards compatible) functionality to the common set of functions:</p>

<p><b>extension(string : string) : collection</b></p>

<p>Return any extension with the given URL. This is a syntactical shortcut for <code>.extension.where(url = string)</code>, but is simpler to write. </p>

<p><b>trace(name : string) : collection</b></p>

<p>When FHIRPath statements are used in an invariant, the log contents should be added to the 
error message constructed when the invariant is violated. For example:</p>

<pre><code>"SHALL have a local reference if the resource is provided inline (url: height; ids: length,weight)" 

from 

"reference.startsWith('#').not() 
    or ($context.reference.substring(1).log('url') in $resource.contained.id.log('ids'))"
</code></pre>

<p><b>resolve() : collection</b></p>

<p>For each item in the collection, if it is a string, locate the target of the reference, and add it to the resulting collection. If the item is not a string, the item is ignored and nothing is added to the output collection.</p>

<p>The items in the collection may also represent a Reference, in which case the <code>Reference.reference</code> is resolved.</p>

<p>If fetching the resource fails, the failure message is added to the output collection.</p>

<p><b>as(type : identifier) : collection</b></p>

<p>In FHIR, only concrete core types are allowed as an argument. All primitives are considered to be independent types (so <code>markdown</code> is <strong>not</strong> a subclass of <code>string</code>). Profiled types are not allowed, so to select <code>SimpleQuantity</code> one would pass <code>Quantity</code> as an argument.</p>

<h4>A.4 Changes to operators</h4>

<p><b>~ (Equivalence)</b></p>

<p>Equivalence works in exactly the same manner, but with the addition that for complex types, equality requires all child properties to be equal, <strong>except for "id" elements</strong>.</p>

<h4>A.5 Environment variables</h4>

<p>The FHIR specification specified one additional variable:</p>

<pre><code>%resource   - The original resource current context is part of.
              When evaluating a datatype, this would be the resource the element is part of. Do not go past a root resource into a bundle, if it is contained in a bundle
</code></pre>

<h3>Appendix B - Use of FHIRPath in Clinical Quality Language (CQL)</h3>

<p>Clinical Quality Language is being extended to use FHIRPath as its core expression language, in much the same way that XQuery uses XPath to represent expressions within queries. In particular, the following extensions to CQL are proposed:</p>

<h3><a id="Path_Traversal_2"></a>Path Traversal</h3>
<p>When a path expression involves an element with multiple cardinality, the expression is considered short-hand for an equivalent query invocation. For example:</p>
<pre><code>Patient.name
</code></pre>
<p>is allowed, and is considered a short-hand for the following query expression:</p>
<pre><code>Patient.name X where X.name is not null return X.name
</code></pre>
<p>Note that the restriction is required as it ensures that the resulting list will not contain any null elements.</p>
<h3><a id="Constants_and_Contexts_13"></a>Constants and Contexts</h3>
<p>FHIRPath has the ability to reference contexts (using the <code>$</code> prefix) and environment-defined variables (using the <code>%</code> prefix). Within CQL, these contexts and environment-defined variables are added to the appropriate scope (global for environment-variables, local for contexts) with the prefix included. This allows them to be referenced like any other variable within CQL, but preserves the prefix as a namespace differentiator.</p>
<h3><a id="Additional_Operators_16"></a>Additional Operators</h3>
<p>The following additional operators are being added to CQL:</p>
<ul>
<li><code>~</code>, <code>!~</code> - Equivalent operators (formerly <code>matches</code> in CQL)</li>
<li><code>!=</code> - As a synonym for <code>&lt;&gt;</code></li>
<li><code>implies</code> - Logical implication</li>
<li><code>|</code> - As a synonym for <code>union</code></li>
</ul>
<h3><a id="Methodstyle_Invocation_23"></a>Method-style Invocation</h3>
<p>One of the primary syntactic features of FHIRPath is the ability to invoke a function on a collection. For example:</p>
<pre><code>Patient.name.given.substring(3)
</code></pre>
<p>The CQL syntax is being extended to support this style of invocation, but as a short-hand for an equivalent CQL statement for each operator. For example:</p>
<pre><code>stringValue.substring(3, 5)
</code></pre>
<p>is allowed, and is considered a short-hand for the following CQL expression:</p>
<pre><code>Substring(stringValue, 3, 5)
</code></pre>
<p>For most functions, this short-hand is a simple rewrite, but for contextual functions such as <code>where()</code> and <code>select()</code>, this rewrite must preserve the context semantics:</p>
<pre><code>Patient.name.where(given = 'John')
</code></pre>
<p>is short-hand for:</p>
<pre><code>Patient.name N where N.given = 'John'
</code></pre>
<h3><a id="Strict_Evaluation_44"></a>Strict Evaluation</h3>
<p>Because CQL is a type-safe language, embedded FHIRPath expressions should be compiled in <em>strict</em> mode. However, to enable the use of FHIRPath in <em>loose</em> mode, an implicit conversion from a list of elements to an element is added. This implicit conversion is implemented as an invocation of <code>singleton from</code>, ensuring that if the list has multiple elements at run-time an error will be thrown.</p>
<p>In addition, the underlying Expression Logical Model (ELM) is being extended to allow for dynamic invocation. A <code>Dynamic</code> type is introduced with appropriate operators to support run-time invocation where necessary. However, these operators are introduced as an additional layer on top of core ELM, and CQL compiled with the <em>strict</em> option will never produce expressions containing these elements. This avoids placing additional implementation burden on systems that do not need dynamic capabilities.</p>

</div>

[%file newfooter%]
</body>
</html>
