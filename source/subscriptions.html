<!DOCTYPE HTML>


[%settitle Subscriptions Framework%]
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
[%file newheader%]
</head>
<body>
[%file newnavbar%]



<h1>Topic-Based Subscriptions Framework</h1>
<table class="colsd"><tr><td id="wg"><a _target="blank" href="[%wg fhir%]">[%wgt fhir%]</a> Work Group</td><td id="fmm"><a href="versions.html#maturity">Maturity Level</a>: 0</td><td id="ballot"><a href="versions.html#std-process">Standards Status</a>:<!--!ns!--><a href="versions.html#std-process">Draft</a></td></tr></table>

<p>
  Subscriptions are used to establish proactive event notifications from a FHIR server to another system. Servers which have implemented support for Subscriptions will advertise their use via the resources <a href="subscription.html">Subscription</a> and <a href="subscriptiontopic.html">SubscriptionTopic</a>. Interactions and operations allowed on these resources may be discovered via the FHIR Application's <a href="capabilitystatement.html">CapabilityStatement</a>.
</p>

<a name="actors-and-roles"/>
<h2>Actors and Roles</h2>
<p>
  Any FHIR application may support the use of Subscriptions.  In this documentation:
  <ul>
    <li><b>Server</b> refers to the FHIR application or applications acting as the subscription provider.  This includes the responsibilities of implementing one or more <code>SubscriptionTopics</code>, managing <code>Subscriptions</code>, and sending notifications.</li>
    <li><b>Client</b> or <b>Subscriber</b> refers to the application or applications requesting topic-based notifications.  This includes the responsibilities of acting as a FHIR client (to create a <code>Subscription</code>) and receiving notifications on a supported channel.</li>
    <li><b>Endpoint</b> refers to the portion of the client which is responsible for receiving notifications, if applicable. For example, when using the <code>rest-hook</code> channel type the endpoint is the HTTP server listening for notifications. While part of the client, it is often useful to refer to the endpoint separately for clarity.</li>
  </ul>
  Note: either role may be implemented by one or more applications across one or more systems.
</p>

<a name="bnr"></a>
<h2>Boundaries and Relationships</h2>
<p>
  The Subscriptions Framework in FHIR is a mechanism used to send notifications from a server to a client based on activity occurring in the server.
</p>
<p>
  The Subscription mechanism is composed of three parts:
  <ul>
    <li><a href="subscriptiontopic.html">SubscriptionTopic</a> resources
      <ul>
        <li>Define the <b>data</b> and <b>change</b> or <b>event</b> used to trigger notifications</li>
        <li>Define the filters allowed to clients</li>
        <li>Are always referenced by canonical URL</li>
      </ul>
    </li>
    <li><a href="subscription.html">Subscription</a> resources
      <ul>
        <li>Describe a client's request to be notified about events defined by a <code>SubscriptionTopic</code></li>
        <li>Set actual filters, as defined in the referenced <code>SubscriptionTopic</code></li>
        <li>Describe the <a href="subscription.html#channels">channel</a> and endpoint used to send notifications</li>
        <li>Describe the payload included in notifications (MIME type, content level, etc.)</li>
      </ul>
    </li>
    <li><a href="bundle.html#subscription-notification">subscription-notification Bundles</a>
      <ul>
        <li>Describe a notification, using a <a href="subscriptionstatus.html">SubscriptionStatus</a></li>
        <li>Contain zero or more notification payloads</li>
      </ul>
    </li>
  </ul>
</p>
<p>
  Definitionally, a <code>Subscription</code> requires a <code>SubscriptionTopic</code> - without a resource describing an event or change of interest, a <code>Subscription</code> would have no meaning.
</p>
<p>
  While active, a <code>Subscription</code> relies on both <a href="bundle.html#subscription-notification">Bundle</a> and <a href="subscriptionstatus.html">SubscriptionStatus</a> for sending notifications.
</p>
<p>
  When using the <code>Subscription</code> resource, the FHIR server combines
  the roles of publisher and information distributer. Some arrangements
  of the 'publish and subscribe' pattern describe separate agents for the two roles.
  This specification makes no recommendations towards the internal architecture of 
  server implementations.
</p>
<p>
  While the FHIR REST API describes a polling-based method for observing events using 
  <a href="bundle.html">bundles</a> and the <a href="http.html#history">history operation</a>, 
  polling can cause processing delays (e.g., time between polling operations) and incur costs in:
  <ul>
    <li>computation - e.g., processing queries when there are no state changes;</li>
    <li>connectivity - e.g., many clients connecting regularly when there are no state changes; and</li>
    <li>energy - e.g., mobile devices needing to 'wake up' and poll regularly.</li>
  </ul>
</p>
<p>
  Note that topic-based subscription capabilities have been added to the core specification as of FHIR R5.  In order to facilitate adoption, a <a href="https://hl7.org/fhir/uv/subscriptions-backport/">Backport Implementation Guide</a> is available to provide the equivalent functionality in some earlier versions of FHIR.  When using earlier versions of FHIR supported by the IG, cross version extensions SHOULD NOT be used on <code>Subscription</code> resources to describe any elements described by that guide.
</p>

<a name="relationtofhircast"/>
<h3>Relation to FHIRcast</h3>
<p>
  <a href="http://fhircast.org">FHIRcast</a> is a framework for user-activity synchronization across applications.  FHIRcast and Subscription are both conceptually based <a href="https://www.w3.org/TR/websub/">W3 WebSub</a>, and while the mechanics of two projects look similar, they are fundamentally different projects used to address different use cases.  In particular:
  <ul>
    <li>
      <p>FHIRcast is designed to be used by multiple applications perhaps with the same user and typically on the same device</p>
      <p>Subscriptions are designed to be used by multiple distinct systems, often outside of a user workflow</p>
    </li>
    <li>
      <p>FHIRcast sends only single-event notifications</p>
      <p>Subscriptions allow servers to batch multiple notifications in high-frequency scenarios</p>
    </li>
    <li>
      <p>FHIRcast is designed around short-lived sessions</p>
      <p>Subscriptions are intended to be long-lived resources</p>
    </li>
  </ul>
</p>

<a name="relationtomessaging"/>
<h3>Relation to Messaging</h3>
<p>
  FHIR <a href="messaging.html">Messaging</a> is a message-based protocol which can be used for communication. When combining Messaging and Subscriptions, complete notifications are wrapped into Messaging Bundles.  More details are provided <a href="subscription.html#messaging">below</a>.
</p>

<a name="overview-workflow"/>
<h2>Workflow Overview</h2>
<p>
  This section gives an overview of the workflow for both Servers and Clients to work with Subscriptions.  Each <a href="subscription.html#channels">channel</a> MAY vary slightly from this general overview - specifically around interactions involving the <code>Endpoint</code> (e.g., when using a <code>rest-hook</code> the client must pre-configure an HTTP endpoint which the server validates, but when using a <code>websocket</code> the client simply connects to the server).
</p>

<a name="workflow-styles"/>
<h3>Types of Workflows</h3>
<p>
  The Subscriptions Framework is intended to be a flexible and reusable layer of infrastructure.  In this section, two types of subscription workflows are described: <i>in-band</i> (or client) managed and <i>out-of-band</i> (or server) managed.  These styles are not mutually exclusive, and a server MAY support both styles.
</p>
<p>
  <i>In-Band</i> managed subscriptions are those where the client is responsible for creating and managing the subscription.  In this style, the server needs to expose functionality relating to Subscription Topics and Subscriptions themselves so that they can be managed by the client. For details about the conformance requirements specific to in-band management, please see <a href="#conformance-in-band">Conformance: In-Band</a>.
</p>
<p>
  <i>Out-of-Band</i> managed subscriptions are those where the client is <b>not</b> responsible for creating and managing the subscription.  In this style, many server requirements can be relaxed, depending on whether the intention is to manage subscriptions internally or via a third-party (e.g., a jurisdictional authority, management service, etc.). For details about the conformance requirements specific to out-of-band management, please see <a href="#conformance-out-of-band">Conformance: Out-of-Band</a>.  Note that when using a third-party responsible for managing subscriptions, the server MAY or MAY NOT expose various subscription-related operations via FHIR.
</p>

<a name="creating-a-subscription"/>
<h3>Creating a Subscription - In-Band Managed</h3>

<p>
  A workflow for creating a subscription using the in-band management style is below:
</p>

<figure>
  <img src="subscription-workflow-general.svg" alt="Workflow sequence diagram of in-band FHIR Subscriptions" />
  <figcaption>Workflow sequence diagram of in-band FHIR Subscriptions</figcaption>
</figure>

<ol>
  <li>
    Server implements the core functionality required for topic-based subscriptions.
  </li>
  <li>
    Server implements one or more <a href="subscriptiontopic.html">SubscriptionTopic</a> resources.  Implementation is specific to each topic, and will vary between servers.
  </li>
  <li>
    Client asks the server for the list of supported <a href="subscriptiontopic.html">SubscriptionTopic</a> resources, via querying the resource.
  </li>
  <li>
    Server responds with a <a href="bundle.html#searchset">searchset Bundle</a>.
  </li>
  <li>
    Client ensures that the endpoint is prepared (if applicable - see <a href="subscription.html#channels">channels</a>).
  </li>
  <li>
    Client requests a <a href="subscription.html">Subscription</a> (e.g., via <code>HTTP POST</code>, <code>HTTP PUT</code>, etc.).
  </li>
  <li>
    Server MAY accept the <a href="subscription.html">Subscription</a> request (e.g., supported channel and payload).  Note that the server MAY modify the request to be suitable (e.g., changing heartbeat timeouts, etc.).  Clients SHALL check the returned resource or query for the accepted version if not returned to ensure an accepted request conforms with their expectations.
  </li>
  <li>
    Server MAY reject the <a href="subscription.html">Subscription</a> request (e.g., unsupported channel type).
  </li>
  <li>
    If applicable, the server MAY send a <a href="subscriptionstatus.html#handshake-notification">handshake</a> to the endpoint.
  </li>
  <li>
    If the Server sends a <a href="subscriptionstatus.html#handshake-notification">handshake</a>, the endpoint SHALL respond appropriately, or the Server MAY deactivate the subscription.
  </li>
</ol>

<p>Note: The step where the client requests a <a href="subscription.html">Subscription</a> resource (e.g., via <code>HTTP POST</code> or <code>HTTP PUT</code>) follows the standard FHIR resource creation rules; see <a href="http.html#create">Creating Resources</a> for expected behavior and error handling (e.g., servers return an <a href="operationoutcome.html">OperationOutcome</a> on failure).</p>

<p>
  Once the subscription is active, notifications will be sent according to the <a href="subscription.html#channels">channel</a>.  Note that error states may occur, see <a href="#errors">Managing Subscriptions and Errors</a> for more information.
</p>

<h3>Creating a Subscription - Out-of-Band Managed</h3>

<p>
  A workflow for creating a subscription using the out-of-band management style is below:
</p>

<figure>
  <img src="subscription-workflow-oob-server.svg" alt="Workflow sequence diagram of out-of-band FHIR Subscriptions" />
  <figcaption>Workflow sequence diagram of out-of-band FHIR Subscriptions</figcaption>
</figure>

<ol>
  <li>
    Server implements the core functionality required for topic-based subscriptions.
  </li>
  <li>
    Server implements one or more topics, which could be defined via <a href="subscriptiontopic.html">SubscriptionTopic</a> resources.  Implementation is specific to each topic, and will vary between servers.
  </li>
  <li>
    The Subscription Manager (may be the Server) negotiate interest and subscription details with the Client.
  </li>
  <li>
    The Server and the Subscription Manager (may be itself) negotiate the details of the subscription with information about the Client.
  </li>
  <li>
    If applicable, the server MAY send a <a href="subscriptionstatus.html#handshake-notification">handshake</a> to the endpoint.
  </li>
  <li>
    If the Server sends a <a href="subscriptionstatus.html#handshake-notification">handshake</a>, the endpoint SHALL respond appropriately, or the Server MAY deactivate the subscription.
  </li>
</ol>

<p>Note: Although creation is negotiated out-of-band in this workflow, any server-side creation or update of a <a href="subscription.html">Subscription</a> resource still follows the standard FHIR resource creation rules described at <a href="http.html#create">Creating Resources</a>, including normal HTTP status codes and use of <a href="operationoutcome.html">OperationOutcome</a> for errors.</p>

<p>
  After the subscription has been negotiated, processing occurs: the Server is responsible for sending notifications; the Client is responsible for receiving them and responding appropriately; and the Subscription Manager is responsible for keeping information up to date, managing errors, etc..
</p>



<a name="overview-topic"/>
<h2>Subscription Topics</h2>
<p>
  The <code>SubscriptionTopic</code> resource is used to define conceptual or computable events for <code>Subscription</code> resources.  Conceptually, subscription topics specify:
  <ul>
    <li>What causes a notification, either by referencing an event in an event trigger (e.g., <code>http://example.com/fhir/events#something-interesting-happened</code>) or by describing a resource state change in a resource trigger (e.g., an <code>Encounter</code> is created or updated to have an <code>Encounter.state</code> of <code>active</code>).</li>
    <li>What filters a client is allowed to request.  For example, a topic that allows clients to restrict notifications to a particular patient id or group, a specific procedure, etc., relevant to that particular topic.</li>
    <li>What related resources the server MAY include in notifications.  For example, while a discharge notification would likely be focused on the <code>Encounter</code> resource, since that is the resource that is updated, it is likely desireable to include the patient information, observations, diagnosed conditions, location information, etc.</li>
  </ul>
</p>
<p>
  Subscription Topics are intended to be discoverable, reusable, and extensible.  Definitions should be defined in a computable way whenever possible, but the conceptual definition is the arbiter between any discrepancies.  For example, a query-based and a FHIRPath-based definition may differ slightly because of what is expressible in each language.  In such cases, the goal is correct implementation of the concept - not literal translations between computable definitions.
</p>
<p>
  More details about defining and deriving subscriptions topics can be found on the <a href="subscriptiontopic.html">SubscriptionTopic</a> resource page, specifically in the sections <a href="subscriptiontopic.html#defining">Defining Subscription Topics</a> and <a href="subscriptiontopic.html#deriving">Deriving from Existing Subscription Topics</a>.
</p>

<a name="finding-topics"/>
<h3>Finding Subscription Topics</h3>
<p>
  Example and Canonical Subscription Topics can be found at <a href="http://registry.fhir.org/">registry.fhir.org</a>.  It is strongly suggested that implementers reuse existing topics and submit new topics whenever possible for better compatibility.
</p>

<a name="multi-resource-topics"/>
<h3>Multi-Resource Topics</h3>
<p>
  Subscription Topics can be defined across multiple resource types. For example, a single topic could be defined to trigger when a Patient has a new <a href="observation.html">Observation</a>, <a href="condition.html">Condition</a>, or <a href="procedure.html">Procedure</a>. Alternatively, a system could be interested in notifications based on any Resource being deleted. In either case, it is desireable to be able to trigger notifications across more than one resource type. If all of the resource have a logical grouping in the FHIR hierarchy, the lower-level resource type can be used. For example, for notifications across all resources, the value <a href="codesystem-fhir-types.html#fhir-types-Resource">Resource</a> can be used directly. If there is no lower-level grouping, each resource must be listed individually in the appropriate elements of the topic (e.g., multiple <a href="subscriptiontopic-definitions.html#SubscriptionTopic.trigger">SubscriptionTopic.trigger</a> elements, each with the correct <code>resource</code>).
</p>

<a name="overview-subscription"/>
<h2>Subscriptions</h2>
<p>
  The <code>Subscription</code> resource is used to request notifications for a specific client about a specific topic (as defined by a <code>SubscriptionTopic</code>).  Conceptually, a subscription specifies: a <b>topic</b> (<code>SubscriptionTopic</code>), the notification <b>channel</b> (e.g., REST, websockets, email, etc.), and the notification <b>payload</b> (e.g., MIME type, amount of detail, etc.).  Detailed information about channel-types and payload configuration can be found on the <a href="subscription.html">Subscription</a> resource page.
</p>
<p>
  When a FHIR Server accepts a request to create a <code>Subscription</code>, the server is indicating to the client that the server:
  <ul>
    <li>is capable of detecting when events covered by the requested <code>SubscriptionTopic</code> occur, and</li>
    <li>is willing to make a <a href="https://tools.ietf.org/html/rfc5290">simple best effort</a> attempt at delivering a notification for each occurrence of a matching event.</li>
  </ul>
</p>
<p>
  When processing a request for a subscription, following are <i>some</i> checks that a server SHOULD validate:
</p>
<ul>
  <li>
    that the <code>SubscriptionTopic</code> is valid and implemented by the server
  </li>
  <li>
    that all requested filters are defined in the requested topic and are implemented in the server
  </li>
  <li>
    that the channel type is known and implemented by the server
  </li>
  <li>
    that the channel endpoint is valid for the channel provided (e.g., is it a valid URL of the expected type)
  </li>
  <li>
    that the payload configuration is known and implemented by the server
  </li>
  <li>
    that the payload configuration is valid for the channel type requested (e.g., complies with the server's security policy)
  </li>
</ul>

<a name="resource-filters"/>
<h3>Filters and Resource Types</h3>
<p>
  If allowed by a topic, notifications for a single subscription can be triggered on <a href="#multi-resource-topics">multiple resource types</a>. A topic can also define filters that apply to some or all triggering resource types. Note that if the <code>resourceType</code> is not specified, the server MAY either reject the request, determine at the time of creation which resources the parameter is applied to, or test each resource at runtime.
</p>
<p>
  For example, if a topic is defined for both <a href="observation.html">Observation</a> and <a href="condition.html">Condition</a> resources, the <a href="searchparameter-registry.html#clinical-patient">patient</a> search parameter is defined across both types and the same value will apply to either.  However, if the <a href="searchparameter-registry.html#clinical-code">code</a> search parameter is used, receivers will likely want to specify the filters independently with different values for observations vs. conditions.  Filters only apply to the resources they are listed by.  For example, a filter for the <code>Condition.onset-age</code> parameter is not used when a topic triggers on an Observation.  Note that this is true even if links exist between resources.
</p>
<p>
  The same behavior applies to lower-level resources, e.g., <code>Resource</code>. If a topic allows for filtering on common search parameters such as <a href="search.html#_language">_language</a>, <a href="search.html#_source">_source</a>, or <a href="search.html#_tag">_tag</a>, it is logical to apply each of those parameters to every resource. If a non-generic search parameter is allowed (e.g., <a href="searchparameter-registry.html#clinical-patient">patient</a>) and a <code>resourceType</code> is unspecified or too broad, the server could choose to reject the request, determine subsets at the time of creation, or test each possible notification individually.
</p>
<p>
  When multiple filters are specified, all filters that apply to a resource must match in order for the resource to be considered a match.  For example, if a subscription allows for filters for both the <code>Patient.address-state</code> and <code>Patient.birthdate</code> search parameters, a subscription specifying both <code>address-state=WI</code> and <code>birthdate=ge2000</code> would only match resources that identify a person born in the year 2000 or later and currently living in Wisconsin.
</p>

<a name="overview-notification"/>
<h2>Subscription Notifications</h2>
<p>
  The <code>SubscriptionStatus</code> resource is used to encapsulate information about a subscription and meta-information about the notification itself (e.g., how many events are included, etc.).  There are currently two areas where the resource is used: in <a href="bundle.html#subscription-notification">subscription-notification Bundles</a> and as the return type for the <a href="subscription-operation-status.html">$status operation</a>.
</p>
<p>
  Unless otherwise specified by a server implementation and channel, the Subscriptions Framework does <b>not</b> involve <a href="https://www.rfc-editor.org/rfc/rfc2212">guaranteed</a> delivery of notifications; channels are assumed to be <a href="https://www.rfc-editor.org/rfc/rfc5290">simple best-effort</a> unless otherwise specified.  While the Subscriptions Framework is able to support such mechanisms, defining channels using them is beyond the scope of the standard at this time.
</p>
<p>
  Subscribers should be aware of some limitations regarding delivery. In particular:
  <ul>
    <li>Some notifications might not be delivered.</li>
    <li>Some notifications might be delivered multiple times.</li>
  </ul>
</p>
<p>
  In order to mitigate the impact from the above issues, the Subscriptions Framework includes mechanisms to detect both scenarios.  More information can be found <a href="#errors-delivery">below</a>.
</p>

<a name="conformance"/>
<h2>Conformance</h2>
<p>
  The requirements to claim conformance with the Subscriptions Framework are detailed below. Note that there are two sets described - one for <i>in-band</i> subscription management and one for <i>out-of-band</i> subscription management.  Servers MAY support either or both styles.
</p>

<a name="conformance-in-band"/>
<h3>In-Band Management</h3>
<p>
  In order to claim conformance with this framework, servers supporting <i>in-band</i> management have requirements for <code>SubscriptionTopic</code> and <code>Subscription</code> resources, as detailed below. Note that the requirements are based on FHIR interactions, as the Subscriptions Framework does not require REST support.
</p>
<ul>
  <li>SHALL support the <code>SubscriptionTopic</code> resource
    <ul>
      <li>SHALL support the <code>read</code> interaction</li>
      <li>SHALL support the <code>search</code> interaction</li>
      <li>MAY support other interactions</li>
    </ul>
  </li>
  <li>SHALL support the <code>Subscription</code> resource
    <ul>
      <li>SHALL support the <code>read</code> interaction</li>
      <li>SHALL support the <code>create</code> interaction</li>
      <li>SHALL support the <code>update</code> interaction</li>
      <li>SHALL support the <code>delete</code> interaction</li>
      <li>SHOULD support the <code>search</code> interaction</li>
      <li>MAY support other interactions</li>
    </ul>
  </li>
  <li>SHALL support the <code>$status</code> operation on the <code>Subscription</code> resource.</li>
  <li>SHALL support at least one channel type, and SHOULD include one from the core-defined channel types</li>
  <li>SHALL support at least one Payload Type</li>
</ul>

<a name="conformance-out-of-band"/>
<h3>Out-of-Band Management</h3>
<p>
  In order to claim conformance with this framework, servers supporting <i>out-of-band</i> management have requirements for <code>SubscriptionTopic</code> and <code>Subscription</code> resources, as detailed below. Note that the requirements are based on FHIR interactions, as the Subscriptions Framework does not require REST support.
</p>
<ul>
  <li>MAY support the <code>SubscriptionTopic</code> resource
    <ul>
      <li>MAY support the <code>read</code> interaction</li>
      <li>MAY support the <code>search</code> interaction</li>
      <li>MAY support other interactions</li>
    </ul>
  </li>
  <li>SHOULD support the <code>Subscription</code> resource
    <ul>
      <li>SHOULD support the <code>read</code> interaction</li>
      <li>SHOULD support the <code>search</code> interaction</li>
      <li>MAY support the <code>create</code> interaction</li>
      <li>MAY support the <code>update</code> interaction</li>
      <li>MAY support the <code>delete</code> interaction</li>
      <li>MAY support other interactions</li>
    </ul>
  </li>
  <li>SHOULD support the <code>$status</code> operation on the <code>Subscription</code> resource.</li>
  <li>SHALL support at least one channel type, and SHOULD include one from the core-defined channel types</li>
  <li>SHALL support at least one Payload Type</li>
</ul>

<a name="conformance-discovery"/>
<h3>Discovery</h3>
<p>
  Some options of the Subscriptions Framework are not easily expressed in a <code>CapabilityStatement</code>.  In addition to the basic support in the CapabilityStatement (e.g., resources, interactions, and operations), a conformant server SHALL support at least one <code>Payload Type</code> and SHOULD support one <code>Channel Type</code> defined in the core specification.  While channel information is not currently discoverable via capabilities, server implementers are expected to document their support out-of-band so that developers can understand support.  Client developers (subscribers) are unlikely to implement more than a few channel types, so it is unlikely that a client is able to "try and error" too many times.  Note that a future publication of FHIR may include more functionality regarding capabilities; this guidance will evolve with any changes.
</p>

<a name="safety"/>
<h2>Safety and Security</h2>
<p>
  Applications are responsible for following <a href="security.html">FHIR security guidance</a>.  Some recommendations specific to subscriptions are provided below.
</p>
<p>
  A subscription is a request for future event notifications. As with any client-initiated interaction, a <code>Subscription</code> could request information a client is not allowed to see. Applications SHALL enforce authorization in accordance with their policy requirements. Applications SHOULD take a subscription's <code>SubscriptionTopic</code> and filters into account when authorizing the creation of a <code>Subscription</code>, and SHOULD ensure that authorization is (still) in place when sending any event notifications.
</p>
<p>
  When sending an event notification, applications can adopt various strategies to ensure that authorization is still in place. Some strategies may provide imperfect assurance (e.g., a server might rely on signed tokens with some pre-specified lifetime as evidence of authorization). In addition to these strategies, servers can mitigate the risk of disclosing sensitive information by limiting the payload types it supports (e.g., by prohibiting certain clients from requesting <code>full-resource</code> notification payloads and relying instead on <code>id-only</code> payloads).
</p>
<p>
  When implementing channels, implementers should be aware of security best-practices for those protocols.  For example, when implementing the <code>REST-hook</code> channel type, it is strongly recommended to use HTTPS instead of HTTP.  In general, use of protocols that transmit data unencrypted is strongly discouraged.
</p>
<p>
  Implementors should note that security and privacy considerations can also prohibit notifications from being generated, in addition to considerations about sending notifications. For example, if a resource is deleted because it was "Entered in Error", a server may choose to not send a notification or could include special handling for those cases (e.g., sending a predefined notification message indicating that a patient should disregard a prior notification).  Similarly, if a patient has decided that a category of lab results are confidential, practitioners without appropriate consent for disclosure should not receive any indication of those results (e.g., a server cannot generate a notification event for them).
</p>
<p>
  <code>Subscription</code> resources are not intended to be secure storage for secrets (e.g., OAuth Client ID or Tokens, etc.). Implementers MAY use their judgement on including limited-use secrets (e.g., a token supplied in a <code>Subscription.parameter</code> to verify that a message is from the desired source).  Server implementations SHOULD be aware that data contained in a Subscription can be sensitive (e.g., privileged endpoint URLs) and take appropriate steps to prevent unauthorized access.
</p>
<p>
  Each notification sent by the application could reveal information about the application and subscriber relationship, as well as sensitive administrative or clinical information. Applications are responsible for ensuring appropriate security is employed for each channel they support. The <code>Subscription</code> resource does not address these concerns directly; it is assumed that these are administered by another configuration processes. For instance, an application might maintain a whitelist of acceptable endpoints or trusted certificate authorities for <code>rest-hook</code> channels.
</p>
<p>
  Some topic and server implementation combinations may trigger internal notification workflows when notifications SHOULD NOT be sent.  For example, if a topic is designed around <code>Observation</code> resources being removed (e.g., deleted), an implementation may be triggered if an <code>Observation</code> is moved to a higher security level and is no longer available to a user.  These types of situations are implementation-specific, so this note is to raise awareness of potential pitfalls when implementing subscriptions.
</p>
<p>
  Subscribers should ensure an appropriate process to validate incoming messages.  For example, if the <code>full-resource</code> content type is used, clients should provide a header or some other secret to the server so that messages can be verified prior to being used for health decisions.  Using content types of <code>empty</code> or <code>id-only</code> can mitigate this risk, as resources must be retrieved from a trusted location prior to use.  Additionally, subscriber implementations should be defensive about the processes spawned when receiving a notification.  For example, if data-receipt always directly triggers a query to a FHIR server, bad actors could generate fake notifications across several clients in order to overload a destination server (denial of service).
</p>
<p>
  Subscribers should be aware of, and protect against, the possibility of being used as part of an attack on a FHIR server.  For example, a malicious client may send a large volume of fake notifications with <code>empty</code> notifications, which would cause the subscriber to send many (potentially expensive) queries to a server.
</p>

<a name="tracking"/>
<h3>Tracking Subscription Notifications</h3>
<p>
  Servers implementing Subscriptions are responsible for complying with their policies on information logging.  Servers are encouraged to track all sent notifications, for example with the use of <a href="auditevent.html">AuditEvent</a> or <a href="communication.html">Communication</a> resources.
</p>

<a name="scoping"/>
<h2>Scoping Responsibilities</h2>
<p>
  Unless otherwise specified by a server implementation and channel, the Subscriptions Framework does not involve guaranteed delivery of notifications. While the Subscriptions Framework is able to support such mechanisms, defining them are beyond the scope of this specification.
</p>

<p>
  Servers SHOULD detect errors and take appropriate action where possible.  In general, this boundary is when the notification is delivered.  For example, during a REST-hook notification, the subscription server can detect errors up until the REST endpoint returns a HTTP status code (e.g., 200).  This does not imply that a client successfully processed (or even received) a notification - simply that the server has sent the notification successfully.
</p>

<p>
  Clients SHOULD be aware of some limitations regarding delivery. In particular:
</p>
<ul>
  <li>some notifications might not be delivered, and</li>
  <li>some notifications might be delivered multiple times.</li>
</ul>

<p>
  In order to mitigate the impact from the above issues, the Subscriptions Framework includes mechanisms to detect both scenarios.
</p>

<a name="errors"/>
<h2>Managing Subscriptions and Errors</h2>
<p>
  Subscription management is concerned with a few stages: creating a subscription, managing notification errors, and removing a subscription. Given the differences in those stages when a subscription is managed <i>in-band</i> or <i>out-of-band</i>, the following sections are split into those two categories.
</p>

<a name="managing-in-band"/>
<h3>In-Band Subscription Management</h3>
<p>
  A subscription resource is authored by the client with an initial status of <code>requested</code>. A new subscription is created on the server using the <code>create</code> or <code>update</code> interaction. After a successful <code>create</code> interaction, the client parses the <code>Location</code> header of the HTTP response and saves the new Subscription's logical id for use in subsequent operations.
</p>
<p>
  When the server receives a request for a subscription, it SHOULD check that it is prepared to accept/process the subscription. If it is, it sets the subscription to <code>requested</code> and processes it like a normal <a href="http.html#create">create</a>. If it isn't, it SHOULD return an error with an <a href="operationoutcome.html">OperationOutcome</a> instead of processing the <code>create</code>.
</p>
<p>
  The filter criteria are subject to the same limitations as the client that created it, such as access to patient compartments etc. Note that the subscription MAY remain active after the client access tokens expire (e.g., if the client's authorization period outlasts the access token lifetime).
</p>
<p>
  Once the server is prepared to send notifications for a subscription, it sets the status to <code>active</code>.  Note that the server MAY choose to activate a subscription immediately on creation (without any additional processing), after testing communications with the client endpoint, or after some additional process (e.g., administrative review).
</p>
<p>
  An appropriately authorized client can use <code>search</code> and/or <code>history</code> interactions to see what subscriptions are currently active on the server. If a subscription is no longer desired, the subscription can be removed via a <code>delete</code> interaction.
</p>
<p>
  The server may retry the notification a fixed number of times and/or refer errors to its own alert logs. If the notification fails, the server SHOULD set the status to <code>error</code> and mark the error in the resource. If the notification succeeds, the server SHOULD update the status to <code>active</code> and may remove any error codes. If a subscription fails consistently a server may choose set the subscription status to <code>off</code> and stop trying to send notifications.
</p>
<p>
  Errors a server wishes to make accessible to clients are communicated via <code>SubscriptionStatus.error</code>. Clients MAY receive these errors in notifications sent by the server or detect them by running the <code>$status</code> operation on a subscription. Servers should provide a mechanism for clearing errors (e.g., when resetting a <code>Subscription.status</code> back to <code>requested</code> after an error).
</p>


<a name="managing-out-of-band"/>
<h3>Out-of-Band Subscription Management</h3>
<p>
  In the <i>out-of-band</i> management style, there MAY or MAY NOT be <code>Subscription</code> resources on a server.  The equivalent responsibilities fall to the server implementation.
</p>
<p>
  The negotiation of <code>SubscriptionTopic</code> and <code>Subscription</code> content in this style are considered an implementation detail.  For example, a server could have an internal model for tracking client information and an administrative user interface for managing subscriptions.
</p>
<p>
  It is important to note that the managing entity for the subscription or equivalent (whether the Server or a third-party) is responsible for ensuring that the subscription is valid and that the client is prepared to receive notifications.  Additionally, that same party is responsible for detecting, reporting, and resolving any errors.  For example, if a client endpoint has an expired certificate and a server cannot send notifications, the client could be unaware of any issues.  The managing entity is responsible for discovering this state and working with the involved parties to ensure no information is missed.
</p>


<a name="guaranteed-vs-best-effort"/>
<h3>Guaranteed vs. Best-Effort Delivery</h3>
<p>
  As mentioned in the <a href="#overview-notification">Notifications Overview</a>, channels for FHIR subscriptions can provide either <a href="https://www.rfc-editor.org/rfc/rfc2212">guaranteed</a> (reliable) or <a href="https://www.rfc-editor.org/rfc/rfc5290">simple best-effort</a> (unreliable) delivery.  While this is a classification of the delivery channel, it can impact the contents of notifications.  Note that channels are assumed to be best-effort unless otherwise specified.
</p>

<a name="best-effort-notification"/>
<h4>Best-Effort (Unreliable) Notifications</h4>
<p>
  The channels defined by this specification (e.g., REST-Hook, Email, etc.) are all categorized as simple best-effort delivery channels; they do not guarantee that a subscribing application has successfully received a notification that has been sent.  The simplest case to illustrate is with the Email channel - once a server has sent a message, there is no determination for if a client has received the message.
</p>
<p>
  The <a href="#errors-delivery">Detecting Delivery Errors</a> section of this document describes the mechanisms used to discover and mitigate issues cause by unreliable delivery mechanisms.
</p>

<a name="guaranteed-notification"/>
<h4>Guaranteed (Reliable) Notifications</h4>
<p>
  Channels can be defined using guaranteed-delivery mechanisms (e.g., message queues).  When a channel is defined with this capability, a notification must be processed by the subscribing application before it is considered delivered.  In these cases, the server can choose to exclude some of the tracking information from notifications, see the <a href="subscriptionstatus.html#event-numbering">Event Numbering</a> section of the <code>SubscriptionStatus</code> resource for details.
</p>

<a name="errors-delivery"/>
<h3>Detecting Delivery Errors</h3>
<p>
  There are several mechanisms available to subscribers in order to understand the current state of notification delivery.  Below are some example error scenarios with details about how a subscriber can detect some problem states.
</p>

<a name="errors-missing-event"/>
<h4>Missing Event</h4>
<p>
  The diagram below shows how a subscriber can use the <code>SubscriptionStatus.eventsSinceSubscriptionStart</code> parameter on received notifications to determine that an event has been missed.
</p>
<figure>
  <img src="subscription-error-missing-event.svg" alt="Diagram showing a missed-event detection and recovery workflow"/>
  <figcaption>Diagram showing a missed-event detection and recovery workflow</figcaption>
</figure>
<p>
  In the above sequence, the subscriber tracks the <code>eventsSinceSubscriptionStart</code> of each received notification (per Subscription).  When the subscriber received event 23, the subscriber was aware that the last notification it received was a single notification for event 21.  The subscriber then waited an amount of time to ensure that event 22 was indeed missing (and not, for example, still being processed) and started a recovery process.  The recovery process itself will vary by subscriber, but should be a well-understood method for recovering in the event of errors.
</p>

<a name="errors-broken-communication"/>
<h4>Broken Communication</h4>
<p>
  The diagram below show how a subscriber can use the <code>Subscription.heartbeatPeriod</code> to determine errors which prevent notifications from reaching the endpoint.
</p>
<figure>
  <img src="subscription-error-no-communication.svg" alt="Diagram showing broken communication detection and recovery workflow" />
  <figcaption>Diagram showing broken communication detection and recovery workflow</figcaption>
</figure>
<p>
  In the above sequence, the subscriber is aware that the <code>heartbeatPeriod</code> has elapsed for a subscription without receiving any notifications.  The subscriber then asks the server for the <a href="subscription-operation-status.html">$status</a> of the subscription, and seeing an error, begins a recovery process.  As in the previous scenario, the recovery process itself will vary by subscriber, but should be a well-understood method for recovering in the event of errors.
</p>

<a name="recovering-from-errors"/>
<h4>Recovering from Errors</h4>
<p>
  Clients are responsible for devising an appropriate method for recovering from errors.  Often, this process will include a series or batch of requests that allow a client to know the current state or a request to the <a href="subscription-operation-events.html">$events</a> operation when available.  For example, an application may need to query all relevant resources for a patient in order to ensure nothing has been missed.  Once an application has returned to a functional state, it should request the subscription is reactivated by updating the <code>status</code> to either <code>requested</code> or <code>active</code> as appropriate.
</p>

<a name="using-events-operation"/>
<h4>Using the <code>$events</code> operation</h4>
<p>
  Servers MAY choose to support the <a href="subscription-operation-events.html">$events</a> operation, as defined on the <code>Subscription</code> resource.  The <code>$events</code> operation allows clients to request events which have occurred in the past.  Servers which implement the operation MAY use implementation-specific criteria to restrict availability of events (e.g., most recent 10 events, events within the past 30 days, etc.).
</p>
<p>
  During a recovery process, clients MAY try to retrieve missing events via the <code>$events</code> operation, which should allow processing to continue as normal.
</p>

[%file newfooter%]

</body>
</html>


