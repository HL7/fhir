<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
       "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

[%settitle RESTful API%]
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
[%file newheader%]
</head>
<body>
[%file newnavbar%]

<div class="col-9">

<h2>RESTful API</h2>
<p>
Each resource type has the same set of interactions defined that can be used to manage the resources 
in a highly granular fashion. Applications claiming conformance to this framework
claim to be conformant to "RESTful FHIR".
</p>
<p>
Note that in this RESTful framework, transactions are performed directly on the server resource using an 
HTTP request/response. The API does not directly address authentication, authorization, and audit
collection - for further information, see the <a href="security.html">Security Page</a>.
</p>
<p>
The API describes the FHIR resources as a set of operations (known as "interactions") on resources where individual
resource instances are managed in collections by their type. Servers can choose which of 
these interactions are made available and which resource types they support. Servers SHALL
provide a <a href="conformance.html">conformance statement</a> that specifies what interactions and 
resources are supported.
</p>
<p>
The following logical interactions are defined:
</p>
<a name="interactions"> </a>
<a name="operations"> </a>
<table class="list"> 
  <tr><td><b>Instance Level Interactions</b></td><td></td></tr>
  <tr><td><a href="#read">read</a></td><td>Read the current state of the resource</td></tr>
  <tr><td><a href="#vread">vread</a></td><td>Read the state of a specific version of the resource</td></tr>
  <tr><td><a href="#update">update</a></td><td>Update an existing resource by its id (or create it if it is new)</td></tr>
  <tr><td><a href="#delete">delete</a></td><td>Delete a resource</td></tr>
  <tr><td><a href="#history">history</a></td><td>Retrieve the update history for a particular resource</td></tr>
  <tr><td colspan="2"><b>Type Level Interactions</b></td></tr>
  <tr><td><a href="#create">create</a></td><td>Create a new resource with a server assigned id</td></tr>
  <tr><td><a href="#search">search</a></td><td>Search the resource type based on some filter criteria</td></tr>
  <tr><td><a href="#history">history</a></td><td>Retrieve the update history for a particular resource type</td></tr>
  <tr><td><a href="#validate">validate</a></td><td>Check that the content would be acceptable as an update</td></tr>
  <tr><td colspan="2"><b>Whole System Interactions</b></td></tr>
  <tr><td><a href="#conformance">conformance</a></td><td>Get a conformance statement for the system</td></tr>
  <tr><td><a href="#transaction">transaction</a></td><td>Update, create or delete a set of resources as a single transaction</td></tr>
  <tr><td><a href="#history">history</a></td><td>Retrieve the update history for all resources</td></tr>
</table>

<p><b>Style Guide</b></p>
<p>
URL operations on this pages are defined like this:
</p>

<pre>
  OPERATION [base]/[type]/[id] {?_format=[mime-type]}
</pre>
<ul>
 <li>The first word is the HTTP verb used for the operation</li>
 <li>Content surrounded by [] is mandatory, and will be replaced the string literal identified. Possible insertion values:
   <ul>
     <li><b>base</b>: The <a href="#root">Service Root URL</a></li>
     <li><b>mime-type</b>: The <a href="#mime-type">Mime Type</a></li>
     <li><b>type</b>: The name of a resource type (e.g. "Patient")</li>
     <li><b>id</b>: The <a href="resources.html#metadata">Logical Id</a> of a resource</li>
     <li><b>vid</b>: The <a href="resources.html#metadata">Version Id</a> of a resource</li>
     <li><b>compartment</b>: The name of a <a href="extras.html#compartment">compartment</a></li>
     <li><b>parameters</b>: URL parameters as defined for the particular operation</li>
   </ul>
 </li>
 <li>Content surrounded by {} is optional</li>
</ul>
<a name="root"> </a>
<a name="general"> </a>
<h3>Service Root URL</h3>
<p>
The Service Root URL is the address where all of the 
resources defined by this interface are found. The Service 
Root URL takes the form of 
</p>
<pre>
http(s)://server{/path}
</pre>
<p>
The path portion is optional, and does not include a trailing slash. Each 
resource type defined in this specification has a manager (or "entity set")
that lives at the address "/[type]" where the
"type" is the name of the resource type. 
For instance, the resource manager for the type 
"Patient" will live at:
</p>
<pre>
https://server/path/Patient
</pre>
<p>
All the logical interactions are defined relative to the service root
URL. This means that if the address of any one FHIR resource on a system 
is known, the address of other resources may be determined. 
</p>
<p>
Note: All URLs (and ids that form part of the URL) defined by this specification are case sensitive.</p>
<p>
Note that a server may use a path of the form "http://server/...[xx]..." where the [xx] is some variable 
portion that identifies a particular instantiation of the FHIR API. Typically, the variable id 
identifies a patient or a user, and the underlying information is completely compartmented 
by the logical identity associated with [xx]. In this case, the FHIR API presents a 
patient or user centric view of a record, where authentication/authorization is 
explicitly granted to the URL, on the grounds that some identifiable user is associated
with the logical identity. It is not necessary to explicitly embed the patient id in the 
URL - see <a href="extras.html#compartments">Compartments</a> for an alternative approach.
</p>

<h3>Resource Metadata and Versioning</h3>
<p>
Each resource has an associated set of <a href="resources.html#metadata">resource metadata elements</a>. These map to the http request and response using the following fields:
</p>
<table class="grid">
  <tr><th>Metadata Item</th><th>Where found in HTTP</th></tr>
  <tr><td><a href="resources.html#metadata">Logical Id</a></td><td>The Id is represented explicitly in the URL</td></tr>
  <tr><td><a href="resources.html#metadata">Version Id</a></td><td>The Version Id is represented by the full canonical URL in the content-location header (see <a href="#vread">vread</a> below). 
     The Version Id may also be represented in the http ETag, but the use of ETag is not needed by this specification</td></tr>
  <tr><td>Last Modified Date</td><td>HTTP Last-Modified header</td></tr>
</table>
<p></p>

<h3>Security</h3>
<p>
Using HTTPS is optional, but all production exchange of healthcare data SHOULD use SSL and additional security as appropriate. See <a href="security.html#http">HTTP Security</a> for further information.
</p>
<p>
Note: to support browser-based client applications, recommend that servers SHOULD implement <a href="http://enable-cors.org/">cross-origin resource sharing</a> for the operations documented here.  
</p>

<h3>HTTP Status Codes</h3>
<p>
This specification makes rules about the use of specific HTTP status codes 
in particular circumstances where the status codes SHALL map to particular 
states correctly, and only where the correct status code is not obvious. 
Other HTTP status codes may be used for other states as appropriate, and this particularly
includes various authentication related status codes and redirects. 
Authentication redirects should not be interpreted to change the location 
of the resource itself (a common web programming error). 
</p>
<p>
FHIR defines an <a href="operationoutcome.html">OperationOutcome resource</a> that can be used to convey specific detailed
processable error information. For a few combinations of interactions and specific
return codes, an OperationOutcome is required to be returned as the content of the response. 
The OperationOutcome may be returned with any HTTP 4xx or 5xx response, but is not required - many of 
these errors may be generated by generic server frameworks underlying a FHIR server.
</p>

<a name="mime-type"> </a>
<h3>Content Types and encodings</h3>
<p>
The formal MIME-type for FHIR resources is application/xml+fhir or application/json+fhir.
The correct mime type SHALL be used by clients and servers:
</p>
<table class="grid">
<tr><th></th><th>xml</th><th>json</th></tr>
<tr><td>Resource</td><td>application/xml+fhir</td><td>application/json+fhir</td></tr>
<tr><td>Bundle</td><td>application/atom+xml</td><td>application/json+fhir</td></tr>
</table>
<p>
Servers SHALL support server-driven content negotiation
as described in <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec12.html#sec12">section 12</a> 
of the HTTP specification.
</p>
<p>
However in order to support various implementation limitations, servers SHOULD support 
support the optional "_format" parameter to specify alternative response formats by their MIME-types.
For the _format parameter, the values "xml", "text/xml", "application/xml", and "application/xml+fhir" SHALL be interpreted to mean
the normative XML format defined by FHIR and "json", "application/json" and "application/json+fhir" SHALL be interpreted to mean the
informative JSON format.
</p>
<p>
FHIR uses UTF-8 for all request and response bodies. Since the HTTP specification (section 3.7.1)
defines a default character encoding of ISO-8859-1, requests and responses SHALL explicitly set
the character encoding to UTF-8 using the 'charset' parameter of the MIME-type in the Content-Type header. 
Requests MAY also specify this charset parameter in the Accept header and/or use the Accept-Charset header.
</p>

<a name="read"> </a>
<h3>read</h3>
<p>
The read interaction accesses the current contents of a resource. The interaction
is performed by an HTTP GET command as shown:
</p>
<pre>
  GET [base]/[type]/[id] {?_format=[mime-type]}
</pre>
<p>
This returns a single instance with the content specified for the resource type.
This url may be accessed by a browser. The possible values for the 
<a href="resources.html#metadata">Logical Id</a> (id) itself are described in the <a href="datatypes.html#id">id type</a>.
Servers are required to return a content-location header with the response which is the full version 
specific url (see vread below) and a Last-Modified header.
<p>
Note: Unknown resources and deleted resources are treated differently on a read: A GET for a deleted 
resource returns a 410 status code, whereas a GET for an unknown resource returns 404. Systems that do 
not track deleted records will treat deleted records as an unknown resource.
</p>

</p>
<a name="vread"> </a>
<h3>vread</h3>
<p>
The vread interaction preforms a version specific read of the resource. The interaction
is performed by an HTTP GET command as shown:
</p>
<pre>
  GET [base]/[type]/[id]/_history/[vid] {?_format=[mime-type]}
</pre>
<p>
This returns a single instance with the content specified for the resource type for that
version of the resource. 
<!-- this - what does it mean?
Servers may return a content-location header with the response which is the url 
requested and a Last-Modified header. 
-->
</p>
<p>
The <a href="resources.html#metadata">Version Id</a> (vid) is an opaque identifier that conforms to the same <a href="datatypes.html#id">format requirements</a> as 
a <a href="resources.html#metadata">Logical Id</a>. The id may have been found by performing a history interaction (see below), by recording the 
version id from a content location returned from a read or from a version specific reference in a 
content model. If the version referred to is actually one where the resource was deleted, the 
server should return a 410 status code.
</p>
<p>
Servers are encouraged to support a version specific retrieval of the current version of the 
resource even if they are do not provide access to previous versions. If a request
is made for a previous version of a resource, and the server does not support accessing
previous versions, it should return a 405 Method Not Allowed error.
</p>

<a name="update"> </a>
<h3>update</h3>
<p>
The update interaction creates a new current version for an existing resource or 
creates a new resource if no resource already exists for the given id. 
The update interaction is performed by an HTTP PUT command as shown:
</p>
<pre>
  PUT [base]/[type]/[id] {?_format=[mime-type]}
</pre>
<p>
If the interaction is successful, the server SHALL return either a 200 OK if the resource was updated, or a 201 Created if the resource was created,
with a Last-Modified header, and a Location and Content-Location header that refers to the specific version created by the 
update interaction.
</p>
<p>
Servers are permitted to reject update interactions because of integrity concerns or business 
rules implemented on the server, and return HTTP status codes accordingly (usually 422). 
A server SHOULD accept the resource as submitted when accepts the update, and return the same
content when it is subsequently read. However systems may not be able to do this. 
Systems should clearly document how the resource will be changed. Clients SHOULD not 
expect the resource to be unchanged if it does not conform to the server's profile.
</p>
<p>
In particular, servers may choose to implement version-aware updates, where the only updates that are 
accepted quote the current version of the resource. In this case, the client must submit the currently 
correct version specific URL in the Content-Location in the PUT request. If the value is missing, 
the server SHALL return a 412 Preconditions failed response. Clients SHOULD submit a proper Content-Location 
header and SHALL correctly understand a 409 response as an update conflict.
</p>
<p>
Common HTTP Status codes returned on FHIR-related errors (in addition to normal HTTP errors related to security, header and content type negotiation issues):
</p>
<ul>
 <li><b>400 Bad Request</b> - resource could not be parsed or failed basic FHIR validation rules</li>
 <li><b>404 Not Found</b> - resource type not supported, or not a FHIR end point</li>
 <li><b>405 Method Not allowed</b> - the resource did not exist prior to the update, and the serer does not allow client defined ids</li>
 <li><b>409/412</b> - version conflict management - see above</li> 
 <li><b>422 Unprocessable Entity</b> - the proposed resource violated applicable FHIR profiles or server business rules. This should be accompanied by an <a href="operationoutcome.html">OperationOutcome</a> resource providing additional detail</li>
</ul>
<a name="delete"> </a>
<h3>delete</h3>
<p>
The delete interaction removes an existing resource. The interaction
is performed by an HTTP DELETE command as shown:
</p>
<pre>
  DELETE [base]/[type]/[id] 
</pre>
<p>
A delete interaction means that <a href="#read">non-version specific reads</a> of a resource 
return a 410 error and that the resource is no longer found through search interactions. Upon successful
deletion the server should return 204 (No Content). If the server refuses to delete resources of 
that type on principle, then it should return the status code 
405 method not allowed. If the server refuses to delete a resource because of reasons specific 
to that resource, such as referential integrity, it should return the status code 409 Conflict.
If the resource cannot be deleted because it does not exist on the server, the server SHALL return 404 (Not found).
Performing this interaction on a resource that is already deleted has no effect, and should return 204.
Resources that have been deleted may subsequently be brought back to life by PUTting an update to them 
subsequent to the deletion. 
</p>
<p>
Many resources have a status element that overlaps with the idea of deletion. Each resource type
defines what the semantics of the deletion interactions are. If no documentation is provided, the 
deletion interaction should be understood as deleting the record of the resource, with nothing
about the state of the real-world corresponding resource implied.
</p>

<a name="create"> </a>
<h3>create</h3>
<p>
The create interaction creates a new resource in a server assigned location. If the client 
wishes to have control over the id of a newly submitted resource, it should use the update 
interaction instead. The create interaction is performed by an HTTP POST command as shown:
</p>
<pre>
  POST [base]/[type] {?_format=[mime-type]}
</pre>
<p>
The server returns a 201 Created, along with 
a Location header which contains the new <a href="resources.html#metadata">Logical Id</a> and <a href="resources.html#metadata">Version Id</a> of the created resource:
</p>
<pre>
  Location: [base]/[type]/[id]/_history/[vid]
</pre>
<p>
Where [id] and [vid] are the newly created id and version id for the resource.
When the payload data is incorrect and cannot be used to create a new resource, the server returns a 400 Bad Request.
</p>
<p>
A server SHOULD accept the resource as submitted when accepts the create, and return the same
content when it is subsequently read. However systems may not be able to do this. 
Systems should clearly document how the resource will be changed. Clients SHOULD not 
expect the resource to be unchanged if it does not conform to the server's profile.
</p>
<p>
Common HTTP Status codes returned on FHIR-related errors (in addition to normal HTTP errors related to security, header and content type negotiation issues):
</p>
<ul>
 <li><b>400 Bad Request</b> - resource could not be parsed or failed basic FHIR validation rules</li>
 <li><b>404 Not Found</b> - resource type not supported, or not a FHIR end point</li>
 <li><b>422 Unprocessable Entity</b> - the proposed resource violated applicable FHIR profiles or server business rules. This should be accompanied by an <a href="operationoutcome.html">OperationOutcome</a> resource providing additional detail</li>
</ul>

<a name="search"> </a>
<h3>search</h3>
<p>
This interaction searches a set of resources based on some filter criteria. The interaction can be performed by several different HTTP commands. 
To search all resources at once:
</p>
<pre>
  GET [base]?[parameters] {&amp;_format=[mime-type]}
</pre>
<p>
To search a single resource type:
</p>
<pre>
  GET [base]/[type]?[parameters] {&amp;_format=[mime-type]}
  GET [base]/[type]/_search?[parameters] {&amp;_format=[mime-type]}
</pre>
<p>
To search a <a href="extras.html#compartments">compartment</a>:
</p>
<pre>
  GET [base]/[compartment]/[id]/*?[parameters]  {&amp;_format=[mime-type]}
  GET [base]/[compartment]/[id]/[type]?[parameters]  {&amp;_format=[mime-type]}
</pre>
<p>
Because of the way that some user agents treat GET and POST requests, POST submissions are 
also allowed with exactly the same semantics as the equivalent GET command.
All these search interactions take a series of parameters that are a series of name'='value pairs 
encoded in the URL (or as an x-multi-part-form submission for a POST).
(See <a href="http://www.w3.org/TR/REC-html40/interact/forms.html#form-content-type">W3C HTML forms</a>). 
Searches are processed as specified for the <a href="query.html">Query handling mechanism</a>. 
</p>
<p>
If the search fails, the return value is a status code 4xx or 5xx with an <a href="operationoutcome.html">OperationOutcome</a>.
If the search succeeds, the return content is an <a href="extras.html#bundle">Bundle</a> containing the results of the search as a list of resources
in a defined order. The result list can be long, so servers may use paging. If they do, they SHALL use the method described 
in <a href="https://tools.ietf.org/html/rfc5005">RFC 5005 (Feed Paging and Archiving)</a> (also <a href="#paging">see below</a>) for breaking the 
list into pages if appropriate.
</p>

<a name="validate"> </a>
<a name="validation"> </a>
<h3>validate</h3>
<p>
The validate interaction checks whether the attached content would be acceptable as an 
update to an existing resource. The interaction is performed by an HTTP POST command as shown:
</p>
<pre>
  POST [base]/[type]/_validate{/[id]}
</pre>
<p>
The content is first checked against the general specification and against the conformance 
profile that applies to the application. Then, if the optional [id] section is 
also provided, the resource is considered as a proposed update to the specific resource, 
and additional instance specific rules such as referential integrity 
and update logic (including version control) are applied as well. 
</p>
<p>
The client can ask the server to validate against a particular resource by attaching
a <a href="extras.html#tags">profile tag</a> to the resource. This is an assertion that 
the resource conforms to the specified profile(s), and the server can cehck this. 
</p>
<p>
How much checking to perform as part of the validation operation is at the 
discretion of the server. The server SHALL check all the things it requires
of the resource as part of it's normal operations, and MAY choose to validate
the resource against the schema and schematron provided as part of this
specification, and/or other profiles, including the one specified by the 
client.
</p>
<p>
The return content has one of the following values:
</p>
<ul>
 <li><b>400 Bad Request</b> - resource could not be parsed or had some basic FHIR validation error</li>
 <li><b>200 OK</b> - resource passed all validation rules</li>
 <li><b>422 Unprocessable Entity</b> - the resource was valid, but as a proposed update, it violates applicable FHIR profiles or server business rules</li>
</ul>
<p>
Unless the result is 200 OK, the response SHALL include an <a href="operationoutcome.html">OperationOutcome</a> resource that lists the issues found on validation.
</p>


<a name="conformance"> </a>
<h3>conformance</h3>
<p>
The conformance interaction retrieves the server's conformance statement that defines how it supports resources. 
The interaction is performed by an HTTP OPTIONS or a GET command as shown:
</p>
<pre>
  GET [base]/metadata {?_format=[mime-type]}
  OPTIONS [base] {?_format=[mime-type]}
</pre>
<p>
Applications SHALL return a <a href="conformance.html">Conformance Resource</a> that specifies which resource types and interactions are supported
for the GET command, and SHOULD do so for the OPTIONS command. If a 404 Unknown is returned from the GET, FHIR is not supported on the 
nominated service url. The GET command is defined because not all client libraries are able to perform an OPTIONS command. 
A Content-Location header should be returned with the conformance resource 
Additional 
parameters that are required to be returned with the OPTIONS command are defined in the <a href="#hdata">OMG hData RESTful Transport</a> 
specification. 
</p>
<p>
In addition to this conformance operation, a server may also choose to provide the 
standard set of interactions (read, search, create, update) defined on this page 
for the <a href="conformance.html">Conformance Resource</a> end-point. 
This is different to the conformance operation:
</p>
<table class="grid">
 <tr><td>conformance operation</td><td>returns a conformance statement describes the server's current operational functionality</td></tr>
 <tr><td>Conformance end-point</td><td>manages a repository of conformance statements (e.g. the HL7 conformance statement registry)</td></tr>
</table>
<p>
All servers are required to support the conformance operation, but servers may choose whether they wish to support the conformance end-point, just like any other end-point.
</p>

<a name="transaction"> </a>
<a name="transaction"> </a>
<h3>transaction</h3>
<p>
The transaction interaction submits a set of resources to be updated, created or deleted on the server. 
This interaction allows multiple resources to be updated/created in a single transaction. Multiple 
resources of the same or different types may be submitted, and they may be a mix of new and existing resources. 
The interaction is performed by an HTTP POST command as shown:
</p>
<pre>
  POST [base] {?_format=[mime-type]}
</pre>
<p>
The content of the post submission is a resource bundle. The resources in the bundle are each processed separately
as if they were an individual <a href="#create">create</a>, <a href="#update">update</a> or 
<a href="#delete">delete</a> as described below, along with the normal processing for each 
(such as tracking tags, verification and version aware updates). Servers SHALL either accept all resources 
and return a 200 OK, along with a response bundle, or reject all resources and return an 
HTTP 400 or 500 type response. It is not an error if the submitted bundle has no resources in it.
The outcome of the processing the transaction SHALL not depend on the order of the resources in 
the transaction. Note that this means that a resource can only appear in a transaction once, and since
bundles may have the same resource more than once or other order dependencies (e.g. update lists), some
kinds of bundles may not be able to be used in a transaction.
</p>
<p>
When a bundle is submitted in a transaction interaction, all the resources have an identity specified
in the bundle. If the identity of the resource matches an existing or possible resource location 
on the server, the server should treat this entry as an <a href="#update">update interaction</a> 
(i.e. PUT to the given resource). If the identity is not one that the server recognizes as a resource location it can use, the 
server should treat the interaction as a <a href="#create">create interaction</a> (i.e. POST to 
the given resource type URL), and create a new identity for the submitted resource. For 
clarity, when the client intends a resource to have a transient identity that the server
SHALL replace, it should use a cid: url on the resource - that is, a url with the scheme 
"cid:"<a href="http://tools.ietf.org/html/rfc2392">per RFC 2392</a>. Note that the client SHALL provide
an identity in the bundle entry.id, but may also provide a version specific identity the
atom "self" link, and may refer to this for version specific references. Deleted resources are those marked clearly
using the method described for <a href="xml.html#atom-deleted">XML</a> or 
<a href="json.html#json-bundle-delete">JSON</a>.
</p>
<p>
A transaction may include references from one resource to another in the bundle, which may 
include circular references where resources refer to each other. If the server assigns 
a new identity to any resource in the bundle, it SHALL also update any references to that 
resource in the same bundle as they are processed. References to resources that are not 
part of the bundle are left untouched. If a resource in the bundle carries a version-specific 
id (using its self-link), any version-specific references to it SHALL also be updated.
Servers SHALL be replace all matching links in the bundle, whether they are found in the resource ids, 
resource references, url elements, or &lt;a href="" &amp; &lt;img src="" in the narrative.
</p>
<p>
Note that this allows clients to assign temporary (version-specific) ids to new resources and refer to
them from within the bundle while the server will update these temporary ids after their creation. This
is especially useful in RESTful scenario's where one would otherwise need multiple interactions, possibly
leading to loss of referential integrity (e.g. when storing a Provenance resource and its 
corresponding target resource), or, on document repositories, a document index entry and its
accompanying document.
</p>
<p>
In order to allow the client to know how newly created resources are now identified for future 
reference, the server SHALL return a bundle with the version-specific identities of the created 
and updated resources, though without the content elements that would contain the resource contents.
</p>
<p>
The application constructing a bundle may not be sure whether a particular resource will already exist
at the time that the transaction is executed; this is typically the case with reference resources such 
as patient and provider. In this case, the bundle should contain a candidate resource with
a cid: identifier, and an additional search parameter using an Atom link:
</p>
<pre>
 &lt;link href="http://localhost/Patient?[parameters]" rel="search"/&gt;
</pre>
<p>
A search link with a root of http://localhost means to search the local resource store for 
a match as specified in the parameters (which must conform to the servers capability for 
searching as specified in its conformance statement). If the search returns no matches, 
the server process the resource normally. If the search returns one match, the server
uses this matching resource instead, and ignores the submitted resource. If more than
one resource is found, the transaction SHALL be rejected.
</p>
<p>
If the server that is processing the transaction requires version aware updates, 
the client may need to reference what is the server's current version of
the resource, which is now the client's previous version:
</p>
<pre>
 &lt;link href="[base]/Patient/34/history/31" rel="predecessor-version"/&gt;
</pre>
<p>
A server SHOULD accept "http://localhost" in place of the [base] to ease
processing where the host name may be unknown (e.g. where proxies are involved).
The predecessor-version is treated as if it were the content-location header
on an update interaction.
</p>

<a name="history"> </a>
<h3>history</h3>
<p>
The history interaction retrieves the history of either a particular resource, all resources of 
a given type, or all resources supported by the system. These three variations of the history
interaction are performed by HTTP Get command as shown:
</p>
<pre>
  GET [base]/[type]/[id]/_history{?[parameters]&amp;_format=[mime-type]}
  GET [base]/[type]/_history{?[parameters]&amp;_format=[mime-type]}
  GET [base]/_history{?[parameters]&amp;_format=[mime-type]}
</pre>
<p>
The return content is a <a href="extras.html#bundle">Bundle</a> containing the specified version history, 
sorted with oldest versions last, and including deleted resources. In addition to the standard _format
parameter, the parameters may also include:
</p>
<table class="list">
  <tr><td>_count : <a href="datatypes.html#integer">integer</a></td><td>single</td><td>Number of return records requested. The server is not bound to return the number requested, but cannot return more</td></tr>
  <tr><td>_since : <a href="datatypes.html#integer">instant</a></td><td>single</td><td>Only include resource versions that were created at or after the given instant in time</td></tr>
</table>
<p>
The history list can be restricted to a limited period by specifying a _since parameter which contains a full date time with time zone. 
Servers SHALL ensure that if a client uses the feed.updated date from the last response they received as 
the value of the _since parameter, no versions will be missed. Clients should be aware that due to timing imprecision, 
they may receive notifications of a resource update on the boundary instant more than once. Servers are 
not required to support a precision finer than by second. 
</p>
<p>
The updates list can be long, so servers may use paging. If they do, they SHALL use the method described 
in <a href="https://tools.ietf.org/html/rfc5005">RFC 5005 (Feed Paging and Archiving)</a> (also <a href="#paging">see Paging</a>) for breaking the 
list into pages if appropriate.
</p>
<p>
The history interaction is suitable for use with internet pub/sub systems based on rss/atom, 
including services such as <a href="http://www.feedly.com">Feedly</a>, allowing humans to easily subscribe to notifications
of updates to a resource (this is usually appropriate for low volume high knowledge resources like
profiles). In addition, the history interaction can be used to set up a subscription from one system
to another, so that resources are synchronized between them. Systems receiving such feeds and planning
on enforcing resource integrity should note that <a href="#transaction">transaction</a> boundaries 
are not reflected in the history list.
</p>
 
 <a name="tags"> </a>
<h3>Tag Operations</h3>
 
<p>
<a href="extras.html#tags">Tags</a> are attached to resources to define operational behavior. When resources are exchanged directly use HTTP on the read, vread, create and update interactions, the 
http header "Category" is used, following the method described for <a href="http://tools.ietf.org/html/draft-johnston-http-category-header-02">Web Categories</a>.
</p>
<pre>
 <a name="tags"> </a> Category: [Tag Term]; scheme="[Tag Scheme]"; label="[Tag label]"(, ...)
</pre>
<p>
The label portion is optional. Note that label may come before scheme. 
Although Category is described as a repeating header, many implementations 
require unique header names, so multiple tags are representing using the one header.
</p>
<table class="grid">
 <tr><td><b>Interaction</b></td><td><b>Tag Actions</b></td></tr>
 <tr><td>read/vread</td><td>The server returns all tags associated with the resource in the headers</td></tr>
 <tr><td>create</td><td>The server stores all the tags provided in the headers</td></tr>
 <tr><td>update</td><td>The server stores all the tags provided in the headers, and keeps any tags already associated with the resource</td></tr>
</table>
<p>
In the other interactions, the resources are wrapped in bundles, where tags are represented in the entry.category element
and servers populate these completely or process these as part of a transaction submission.
</p>
<p>
The following operations provide specific support for tags: <a name="tag-ops"> </a>
</p>
<table class="grid">
 <tr><td width="50%"><b>HTTP Command</b></td><td valign="center"><b>description</b></td></tr>
 <tr><td><pre>GET [base]/_tags</pre></td><td valign="center">get a list of all tags</td></tr>
 <tr><td><pre>GET [base]/[type]/_tags</pre></td><td valign="center">get a list of all tags used for the nominated resource type</td></tr>
 <tr><td><pre>GET [base]/[type]/[id]/tags</pre></td><td valign="center">get a list of all tags affixed to the nominated resource. This duplicates the HTTP header entries</td></tr>
 <tr><td><pre>GET [base]/[type]/[id]/_history/[vid]/_tags</pre></td><td valign="center">get a list of all tags affixed to the nominated version of the resource. This duplicates the HTTP header entries</td></tr>
 <tr><td><pre>POST [base]/[type]/[id]/_tags</pre></td><td valign="center">Affix tags in the list to the nominated resource</td></tr>
 <tr><td><pre>POST [base]/[type]/[id]/history/[vid]/_tags</pre></td><td valign="center">Affix tags in the list to the nominated version of the resource</td></tr>
 <tr><td><pre>DELETE [base]/[type]/[id]/_tags</pre></td><td valign="center">Remove all tags in the provided list from the list of tags for the nominated resource</td></tr>
 <tr><td><pre>DELETE [base]/[type]/[id]/_history/[vid]/_tags</pre></td><td valign="center">Remove tags in the provided list from the list of tags for the nominated version of the resource</td></tr>
</table>  
<p>
The tags of an old version can still be changed. Note that changing the tags on a resource does not create a new version of the resource. A tag list 
is represented like this in XML and JSON:
</p>
<pre class="spec">
&lt;taglist xmlns="http://hl7.org/fhir"> <span style="float: right"><a title="Documentation for this format" href="formats.html"><img src="help.png" alt="doco"/></a></span>
    <span style="color:Gray;">&lt;!-- </span><span style="color:navy;">Tags in the list (<span style="color: brown;"><b>0..*</b></span>): </span> <span style="color: Gray"> --&gt; </span>
    &lt;category term="<span style="color:navy;">[Tag URI]</span>" label="<span style="color:navy;">[Tag Label]</span>" scheme="http://hl7.org/fhir/tag"&gt; 
&lt;/taglist&gt;
</pre>

<pre class="json">
{
  &quot;taglist&quot; : {

    &quot;category&quot; : [{
        &quot;term&quot; : &quot;[Tag URI]&quot;,
        &quot;label&quot; : &quot;[Tag Label]&quot;,
        &quot;scheme&quot; : &quot;http://hl7.org/fhir/tag&quot;
      }]
  }
}
</pre>

<a name="binary"> </a>
<h3>Binary Support</h3>
<p>
FHIR servers can choose to offer support for purely binary resources
at the end point [base]/binary. The binary end-point accepts
any kind of content, such as images and other media, documents (CDA, 
PDF, Word etc.), plain text, XML or anything else, and stores the 
content as is, along with the content type provided by the HTTP headers. 
</p>
<p>
Binary resources function with the same interactions as described
above, except that there is no support for the search interaction. 
The _format  parameter has no meaning when used with binary 
resources: they are always represented using their original content type.
</p>

<a name="paging"> </a>
<h3>Paging</h3>
<p> 
If servers provide paging, they SHALL conform to the method described in <a href="https://tools.ietf.org/html/rfc5005">RFC 5005 (Feed 
Paging and Archiving)</a> for sending continuation links to the client when returning a bundle
(e.g. with history and search). If the server does not do this, there is no way to continue paging.
</p>
<p>
This example shows the third page of a search result:
</p>

<pre class="xml">
&lt;feed xmlns="http://www.w3.org/2005/Atom"&gt;
  &lt;title&gt;Search Page 3&lt;/title&gt;
  &lt;!-- This Search. url starts with base search, and adds the effective 
    parameters, and additional parameters for search state. All searches 
    SHALL return this value.    
	
	  In this case, the search continuation method is that the server 
    maintains a state, with page references into the stateful list.
	--&gt;
  &lt;link rel="self" href="http://example.org/Patient?name=peter&amp;stateid=23&amp;page=3"/&gt;

  &lt;!-- 4 links for navigation in the search. All of these are optional, but recommended --&gt;  
  &lt;link rel="first" href="http://example.org/Patient?name=peter&amp;stateid=23&amp;page=1"/&gt;
  &lt;link rel="previous" href="http://example.org/Patient?name=peter&amp;stateid=23&amp;page=2"/&gt;
  &lt;link rel="next" href="http://example.org/Patient?name=peter&amp;stateid=23&amp;page=4"/&gt;
  &lt;link rel="last" href="http://example.org/Patient?name=peter&amp;stateid=23&amp;page=26"/&gt;
  &lt;updated&gt;2003-12-13T18:30:02Z&lt;/updated&gt;

  &lt;!-- the rest of the search results... --&gt;  
&lt;/feed&gt;
</pre>

<p>
The server need not use a stateful paging method as shown in this example - it is at 
the discretion of the server how to best ensure that the continuation retains 
integrity in the context of ongoing changes to the resources. An alternative approach
is to use version specific references to the records on the boundaries, but this is 
subject to continuity failures when records are updated.
</p>
<p>
A server MAY inform the client of the total number of resources returned by the interaction using 
the totalResults element from the <a href="http://www.opensearch.org/Specifications/OpenSearch/1.1">
OpenSearch specification</a>:
</p>
<pre class="xml">
&lt;feed xmlns="http://www.w3.org/2005/Atom"&gt;
  &lt;title&gt;Search Page 3&lt;/title&gt;
  &lt;os:totalResults xmlns:os="http://a9.com/-/spec/opensearch/1.1/"&gt;1432&lt;/os:totalResults&gt;
  
  &lt;!-- the rest of the search results... --&gt;  
&lt;/feed&gt;
</pre>

<p>Note that for search, where _include can be used to return additional related resources, the total number 
of resources in the feed may exceed the number indicated in totalResults.</p>

<h3>Intermediaries</h3>
<p>
The HTTP protocol may be routed through an HTTP proxy such as 
squid. Such proxies are transparent to the applications, though
implementers should be alert to the effects of caching, particularly
including the risk of receiving stale content. See the <a href="http://tools.ietf.org/html/rfc2616#page-74">HTTP specification</a>
for further detail
</p>
<p>
Interface engines may also be placed between the consumer and
the provider. These differ from proxies because they actively
alter the content and/or destination of the HTTP exchange and are
not bound the rules that apply to HTTP proxies. Such agents are allowed, 
but SHALL mark the http header to assist with troubleshooting.
</p>
<p>
Any agent that modifies an HTTP request or Response content other
than under the rules for HTTP proxies SHALL add a stamp to the HTTP 
headers like this:
</p>
<pre>
  request-modified-[identity]: [purpose]
  response-modified-[identity]: [purpose]
</pre>
<p>
The identity SHALL be a single token defined by the administrator of the agent
that will sufficiently identify the agent in the context of use. The header
SHALL specify the agent's purpose in modifying the content. End point systems SHALL
not use this header for any purpose. Its aim is to assist with 
system troubleshooting.
</p>

<a name="hdata"> </a>
<h3>OMG hData RESTful Transport</h3>

<p>
This RESTful specification described here is based on the <a href="http://www.omg.org">OMG Health RESTful specification</a> (specific reference to be provided when this is published). 
In this regard, FHIR functions as a Record Format Profile as described in that specification. Note the following significant factors to be aware of:
</p>
<ul>
 <li>FHIR maps the hData sections to resource types, and hData documents to resource instances. There are no subsections, and client systems are not able to create new sections, though <a href="extras.html#compartments">compartments</a> behave somewhat like sections</li>
 <li>The FHIR resource id maps to the hData document name by prepending "@"</li>
 <li>Because clients cannot submit new sections (POST to service URL), POST to the service URL has been re-used for <a href="#transaction">the transaction interaction</a> (difference under review)</li>
 <li>FHIR does not (yet) define a root document. When defined, it will contain information about what the FHIR server has done (as opposed to a conformance statement, which describes what it is capable of doing)</li>
 <li>Note that this specification does not repeat the rules in the hData RESTful Transport concerning the OPTIONS command on the service URL, but these rules (extra headers etc.) still apply</li>
</ul>

<a name="summary"> </a>
<h3>Summary</h3>
<p>
These tables present a summary of the interactions described here.
</p>

<table class="grid">
<tr><th>Interaction</th><th>Path</th><th colspan="5">Request</th></tr>
<tr><th colspan="2"></th>                                     <th>Verb</th>         <th>Content-Type</th> <th>Body</th>     <th>Accept</th> <th>Content-Location</th></tr>
<tr><td>read</td>       <td>/[type]/@[id]</td>                <td>GET</td>          <td>N/A</td>          <td>N/A</td>      <td>O</td>      <td>N/A</td></tr>
<tr><td>vread</td>      <td>/[type]/@[id]/history/[vid]</td> <td>GET</td>          <td>N/A</td>          <td>N/A</td>      <td>O</td>      <td>N/A</td></tr>
<tr><td>conformance</td><td>/ or /metadata</td>               <td>OPTIONS / GET</td><td>N/A</td>          <td>N/A</td>      <td>O</td>      <td>N/A</td></tr>
<tr><td>update</td>     <td>/[type]/@[id]</td>                <td>PUT</td>          <td>R</td>            <td>Resource</td> <td>O</td>      <td>O or R</td></tr>
<tr><td>create</td>     <td>/[type]</td>           		      <td>POST</td>         <td>R</td>            <td>Resource</td> <td>O</td>      <td>N/A</td></tr>
<tr><td>transaction</td><td>/</td>                            <td>POST</td>         <td>R</td>            <td>Bundle</td>   <td>O</td>      <td>N/A</td></tr>
<tr><td>delete</td>     <td>/[type]/@[id]</td>                <td>DELETE</td>       <td>N/A</td>          <td>N/A</td>      <td>N/A</td>    <td>N/A</td></tr>
<tr><td>search</td>     <td>/[type]/search or /[type]</td>               <td>GET</td>          <td>N/A</td>          <td>N/A</td>      <td>O</td>      <td>N/A</td></tr>
<tr><td>search-all</td>	<td>/</td>                   		  <td>GET</td>          <td>N/A</td>          <td>N/A</td>      <td>O</td>      <td>N/A</td></tr>
<tr><td>validate</td>   <td>/[type]/validate/@[id]</td>       <td>POST</td>         <td>R</td>            <td>Resource</td> <td>O</td>      <td>N/A</td></tr>
<tr><td>history</td>	<td>/[type]/@[id]/history</td> 		  <td>GET</td>          <td>N/A</td>          <td>N/A</td>      <td>O</td>      <td>N/A</td></tr>
<tr><td>history-type</td><td>/[type]/history</td> 		  	  <td>GET</td>          <td>N/A</td>          <td>N/A</td>      <td>O</td>      <td>N/A</td></tr>
<tr><td>history-all</td><td>/history</td> 		  			  <td>GET</td>          <td>N/A</td>          <td>N/A</td>      <td>O</td>      <td>N/A</td></tr>
<tr><td>tags-all</td><td>/tags</td><td>GET</td><td>N/A</td><td>N/A</td><td>O</td><td>N/A</td></tr>
<tr><td>tags-type</td><td>/[type]/tags</td><td>GET</td><td>N/A</td><td>N/A</td><td>O</td><td>N/A</td></tr>
<tr><td rowspan="3">tags</td><td rowspan="3">/[type]/@[id]/tags</td><td>GET</td><td>N/A</td><td>N/A</td><td>O</td><td>N/A</td></tr>
<tr><td>POST</td><td>R</td><td>TagList</td><td>N/A</td><td>N/A</td></tr>
<tr><td>DELETE</td><td>N/A</td><td>N/A</td><td>N/A</td><td>N/A</td></tr>
<tr><td rowspan="3">tags-version</td><td rowspan="3">/[type]/@[id]/history/[vid]/tags</td><td>GET</td><td>N/A</td><td>N/A</td><td>O</td><td>N/A</td></tr>
<tr><td>POST</td><td>R</td><td>TagList</td><td>N/A</td><td>N/A</td></tr>
<tr><td>DELETE</td><td>N/A</td><td>N/A</td><td>N/A</td><td>N/A</td></tr>
</table>

<p>
Note: N/A = not present, R = Required, O = optional.
</p>

<table class="grid">
<tr><th>Interaction</th><th colspan="5">Response</th></tr>
<tr><th colspan="1"></th> <th>Content-Type</th> <th>Body</th>               <th>Location</th> <th>Content-Location</th> <th>Status Codes</th></tr>
<tr><td>read</td>         <td>R</td>            <td>Resource</td>           <td>N/A</td>      <td>R</td>                <td>200, 404, 410</td></tr>
<tr><td>vread</td>        <td>R</td>            <td>Resource</td>           <td>N/A</td>      <td>O</td>                <td>200, 404, 405</td></tr>
<tr><td>conformance</td>  <td>R</td>            <td>Conformance</td>        <td>N/A</td>      <td>O</td>                <td>200, 404</td></tr>
<tr><td>update</td>       <td>R</td>            <td>Resource</td>           <td>N/A</td>      <td>R</td>                <td>201, 400, 404, 405, 409, 412, 422</td></tr>
<tr><td>create</td>       <td>R</td>            <td>Resource</td>           <td>R</td>        <td>O</td>                <td>200, 201, 400, 404, 405, 422</td></tr>
<tr><td>transaction</td>  <td>R</td>            <td>Bundle</td>             <td>N/A</td>      <td>N/A</td>              <td>200, 400, 404, 405, 409, 412, 422</td></tr>
<tr><td>delete</td>       <td>N/A</td>          <td>N/A</td>                <td>N/A</td>      <td>N/A</td>              <td>204, 405, 404</td></tr>
<tr><td>search</td>       <td>R</td>            <td>Bundle</td>             <td>N/A</td>      <td>N/A</td>              <td>200, 403</td></tr>
<tr><td>search-all</td>   <td>R</td>            <td>Bundle</td>             <td>N/A</td>      <td>N/A</td>              <td>200, 403</td></tr>
<tr><td>validate</td>     <td>N/A or R</td>     <td>N/A or OperationOutcome</td> <td>N/A</td>      <td>N/A</td>              <td>400</td></tr>
<tr><td>history</td>   	  <td>R</td>            <td>Bundle</td>             <td>N/A</td>      <td>N/A</td>              <td>200</td></tr>
<tr><td>history-type</td> <td>R</td>            <td>Bundle</td>             <td>N/A</td>      <td>N/A</td>              <td>200</td></tr>
<tr><td>history-all</td>  <td>R</td>            <td>Bundle</td>             <td>N/A</td>      <td>N/A</td>              <td>200</td></tr>
<tr><td>tags-all</td><td>R</td><td>TagList</td><td>N/A</td><td>N/A</td><td>200</td></tr>
<tr><td>tags-type</td><td>R</td><td>TagList</td><td>N/A</td><td>N/A</td><td>200</td></tr><tr><td rowspan="3">tags</td><td>R (GET)</td><td>TagList</td><td>N/A</td><td>N
/A</td><td>200, 404, 410</td></tr>
<tr><td>N/A (POST)</td><td>N/A</td><td>N/A</td><td>N/A</td><td>204</td></tr>
<tr><td>N/A (DELETE)</td><td>N/A</td><td>N/A</td><td>N/A</td><td>204</td></tr>
<tr><td rowspan="3">tags-version</td><td>R (GET)</td><td>TagList</td><td>N/A</td><td>N/A</td><td>200, 404</td></tr>
<tr><td>N/A (POST)</td><td>N/A</td><td>N/A</td><td>N/A</td><td>204</td></tr>
<tr><td>N/A (DELETE)</td><td>N/A</td><td>N/A</td><td>N/A</td><td>204</td></tr>
</table>

<p>
Note: this table lists the status codes described here, but other status codes are possible as described by the HTTP specification. 
Additional codes that are likely a server errors and various codes associated with authentication protocols.
</p>

</div>

[%onthispage Interactions#interactions|Tag Operations#tags|Binary Support#binary|Paging#paging|hData Information#hdata|Summary#summary%]

[%file newfooter%]
</body>
</html>