<!DOCTYPE HTML>

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
[%settitle FHIRPath%]
<head>
[%file newheader%]
</head>
<body>
[%file newnavbar%]



<h2>FHIRPath</h2>
<table class="colsn"><tr><td id="wg"><a _target="blank" href="[%wg fhir%]">[%wgt fhir%]</a> Work Group</td><td id="fmm"><a href="versions.html#maturity">Maturity Level</a>: Normative</td><td id="ballot"><a href="versions.html#std-process">Standards Status</a>:<!--!ns!--><a href="versions.html#std-process">Normative</a></td></tr></table>

<p>
The FHIR Specification uses <a href="http://hl7.org/fhirpath/r2">FHIRPath (release 2)</a> for path-based navigation and extraction.
FHIRPath is a separate specification published at <a href="http://hl7.org/fhirpath/r2">http://hl7.org/fhirpath</a> in order to support wider re-use across multiple specifications.
</p>
<p>
FHIRPath is used in several places in the FHIR and related specifications:
</p>
<ul>
<li><a href="elementdefinition-definitions.html#ElementDefinition.constraint.expression">invariants in ElementDefinition</a> - used to apply co-occurrence and other rules to the contents (e.g. value.empty() or code!=component.code)</li>
<li><a href="elementdefinition-definitions.html#ElementDefinition.slicing.discriminator.path">slicing discriminator</a> - used to indicate what element(s) define uniqueness (e.g. Observation.category)</li>
<li><a href="searchparameter-definitions.html#SearchParameter.expression">search parameter paths</a> - used to define what contents the parameter refers to (e.g. Observation.dataAbsentReason)</li>
<li><a href="operationoutcome-definitions.html#OperationOutcome.issue.expression">error message locations in OperationOutcome</a></li>
<li><a href="fhirpatch.html">FHIRPath-based Patch</a></li>
<li><a href="testscript-definitions.html#TestScript.setup.action.assert.expression">Invariants in the TestScript resource</a></li>
</ul>
<p>
In addition, FHIRPath is used in <a href="http://cds-hooks.hl7.org/ballots/2018May/specification/1.0/#prefetch-template">pre-fetch templates in Smart on FHIR's CDS-Hooks</a>.
</p>

<a name="rules"></a>
<h3>Using FHIRPath with Resources</h3>

<p>
In FHIRPath, like XPath, operations are expressed in terms of the logical content of hierarchical data models, and support traversal,
selection and filtering of data.
</p>
<p>
FHIRPath uses a tree model that abstracts away the actual underlying data model of the
data being queried. For FHIR, this means that the contents of the resources and data
types as described in the Logical views (or the UML diagrams) are used as the model,
rather than the JSON and XML formats, so specific xml or json features are not
visible to the FHIRPath language (such as comments and the split representation
of primitives).
</p>
<p>More specifically:</p>
<ul>
 <li>A FHIRPath may optionally start with a full resource name</li>
 <li>Elements of datatypes and resources are used as the name of the nodes which can be navigated over, except for choice elements (ending with '[x]'), see below.</li>
 <li>The <code>contained</code> element node does not have the name of the Resource as its first and only child (instead it directly contains the contained resource&#8217;s children)</li>
 <li>There is no difference between an attribute and an element</li>
 <li>Repeating elements turn into multiple nodes with the same name</li>
</ul>

<a name="polymorphism"></a>
<h4>Polymorphism in FHIR</h4>

<p>
For <a href="formats.html#choice">choice elements</a>, where elements can be one of multiple types, e.g. <code>Patient.deceased[x]</code>.
In actual instances these will be present as either <code>Patient.deceasedBoolean</code> or <code>Patient.deceasedDateTime</code>.
In FHIRPath, choice elements are labeled according to the name without the '[x]' suffix, and children can be explicitly treated
as a specific type using the <code>as</code> operation:</p>

<pre class="fhirpath">
(Observation.value as Quantity).unit
</pre>

<p>
FHIRPath statements can start with a full resource name:
</p>
<pre>
Patient.name.given
</pre>
<p>
The name can also include super types such as DomainResource:
</p>
<pre>
DomainResource.contained(id = 23).exists()
</pre>
<p>
These statements apply to any resource that specializes <a href="domainresource.html">DomainResource</a>.
</p>

<a name="types"></a>
<h4>Using FHIR types in expressions</h4>
<p>
The namespace for the types defined in FHIR (primitive datatypes, datatypes, resources) is
FHIR. So, for example:
</p>
<pre>
Patient.is(FHIR.Patient)
</pre>
<p>
The first element - the type name - is not namespaced, but the parameter to the is() operation is.
</p>
<p>
Understanding the primitive types is critical: FHIR.string is a different type to System.String.
The FHIR.string type specializes FHIR.Element, and has the properties id, extension, and also
the implicit value property that is actually of type of System.String.
</p>

<p>
The evaluation engine will automatically convert the value of FHIR types representing primitives
to FHIRPath types when they are used in expressions according to the following mapping:
</p>

<table class="grid">
<tr>
<th>FHIR primitive type</th>
<th>FHIRPath type</th>
</tr>
<tr>
<td>FHIR.boolean</td>
<td>System.Boolean</td>
</tr>
<tr>
<td>FHIR.string, FHIR.uri, FHIR.code, FHIR.oid, FHIR.id, FHIR.uuid, FHIR.sid, FHIR.markdown, FHIR.base64Binary</td>
<td>System.String</td>
</tr>
<tr>
<td>FHIR.integer, FHIR.unsignedInt, FHIR.positiveInt</td>
<td>System.Integer</td>
</tr>
<tr>
<td>FHIR.integer64</td>
<td>System.Long</td>
</tr>
<tr>
<td>FHIR.decimal</td>
<td>System.Decimal</td>
</tr>
<tr>
<td>FHIR.date, FHIR.dateTime, FHIR.instant</td>
<td>System.DateTime</td>
</tr>
<tr>
<td>FHIR.time</td>
<td>System.Time</td>
</tr>
<tr>
<td>FHIR.Quantity</td>
<td>System.Quantity (see below)</td>
</tr>
</table>

<p>Since FHIR primitives may contain extensions, the following expressions are <em>not</em> mutually exclusive:</p>

<pre class="fhirpath">
Patient.name.given = 'Ewout'         // value of Patient.name.given as a string
Patient.name.given.extension.first().value = true   // extension of the primitive value
</pre>
<p>
The automatic conversion means that in most respects, a FHIR primitive can
generally be treated as if it was the equivalent FHIRPath system type. The primary
exception is the is() operation, where the difference is explicit:
</p>
<pre class="fhirpath">
Patient.name.given.is(FHIR.string);
Patient.name.given.is(System.string).not();
Patient.name.given.getValue().is(System.string);
</pre>
<p>
As shown, all FHIR primitives have the operation <code>getValue()</code> defined (see below)
for the few edge cases where the automatic conversion isn't appropriate. Note
that ofType() does not have such restrictions - both of the following are valid:
</p>
<pre class="fhirpath">
Patient.name.given.ofType(FHIR.string);
Patient.name.given.ofType(System.string);
</pre>


<a name="quantity"></a>
<h4>Use of FHIR Quantity</h4>

<p>
The Mapping from FHIR Quantity to FHIRPath System.Quantity can only be applied if the FHIR Quantity has a UCUM code
- i.e. a system of <code>http://unitsofmeasure.org</code>, and a code is present.
</p>
<p>
As part of the mapping, time-valued UCUM units are mapped to the <a href="http://hl7.org/fhirpath/R2/index.html#time-valued-quantities">calendar duration units</a> defined in FHIRPath, according to the following map:
</p>
<table class="grid">
<tr><td>a</td><td>year</td></tr>
<tr><td>mo</td><td>month</td></tr>
<tr><td>d</td><td>day</td></tr>
<tr><td>h</td><td>hour</td></tr>
<tr><td>min</td><td>minute</td></tr>
<tr><td>s</td><td>second</td></tr>
</table>

[%dragons-start%]
<p>
i.e. The FHIR Quantity 1 'a' would be implicitly converted to the 
FHIRPath System.Quantity 1 'year'.
Note that there's a subtle difference between the UCUM definitions
for <code>a</code> and <code>mo</code>, which are definition durations 
of <code>365.25</code> and <code>30</code> days respectively, while 
<code>year</code> and <code>month</code> are calendar based durations,
and their length of time varies. See <a href="http://hl7.org/fhirpath/N1/#time-valued-quantities">Time-valued Quantities</a>
for further discussion. Implementers should be aware of these subtle differences,
but in general, this approach matches what users expect most closely.
</p>
[%dragons-end%]

<a name="variables"></a>
<h4>FHIR Specific Variables</h4>

<p>FHIR defines two specific variables that are always in scope when FHIRPath is used
in any of the contexts above:
</p>
<pre>
%resource // the resource that contains the original node that is in %context
%rootResource // the container resource for the resource identified by %resource
</pre>
<p>
The resource is very often the context, such that %resource = %context.
When a DomainResource contains another resource, and that contained resource
is the focus (%resource) then %rootResource refers to the container resource.
Note that in most cases, the resource is not contained by another resource, and
then %rootResource is the same as %resource.
</p>

<a name="functions"></a>
<h4>Additional functions</h4>
<p>FHIR adds (compatible) functionality to the set of common FHIRPath functions:</p>

<p><b>extension(url : string) : collection</b></p>
<p>Will filter the input collection for items named "extension" with the given url. 
  This is a syntactical shortcut for <code>.extension.where(url = string)</code>, 
  but is simpler to write. Will return an empty collection if the input collection is 
  empty or the url is empty.</p>

<p><b>hasValue() : Boolean</b></p>
<p>Returns true if the input collection contains a single value which is a FHIR primitive, 
  and it has a primitive value (e.g. as opposed to not having a value and just having extensions).
  Otherwise, the return value is empty.
</p>

<blockquote>
<p><strong>Note to implementers</strong>: The FHIR conceptual model talks about "primitives" as subclasses of the type Element that also have id and extensions. What this actually means is that a FHIR primitive is not a primitive in an implementation language. The introduction (section 2 above) describes the navigation tree as if the FHIR model applies - primitives are both primitives and elements with children.</p>

<p>In FHIRPath, this means that FHIR primitives have a <code>value</code> child, but, as described above, they are automatically cast to FHIRPath primitives when comparisons are made, and that the primitive value will be included in the set returned by <code>children()</code> or <code>descendants()</code>.</p>
</blockquote>

<p><b>getValue() : System.[type]</b></p>
<p>Return the underlying system value for the FHIR primitive if the input collection contains a single value which is a FHIR primitive, 
  and it has a primitive value (see discussion for hasValue()). Otherwise the return value is empty.</p>

<p><b>resolve() : collection</b></p>
<p>For each item in the collection, if it is a string that is a <a href="datatypes.html#uri">uri</a>
   (or <a href="datatypes.html#canonical">canonical</a> or <a href="datatypes.html#url">url</a>), locate the 
   target of the reference, and add it to the resulting collection. If the item does not resolve to a resource, 
   the item is ignored and nothing is added to the output collection.</p>
<p>The items in the collection may also represent a Reference, in which case the <code>Reference.reference</code> is resolved. 
  If the input is empty, the output will be empty.</p>

<p><b>as(type : identifier) : collection</b></p>
<p>An alias for ofType() maintained purely for backwards compatibility.</p>

  
<p><b>ofType(type : identifier) : collection</b></p>
<p>Returns a collection that contains all items in the input collection that are of the given type or a subclass thereof.
  This works the same as in the base FHIRPath specification, but implementers should be aware that in FHIR, 
  only concrete core types are allowed as an argument. All primitives are considered to be independent 
  types (so <code>markdown</code> is <strong>not</strong> a subclass of <code>string</code>). Profiled types are 
  not allowed, so to select <code>SimpleQuantity</code> one would pass <code>Quantity</code> as an argument.</p>


<p><b>elementDefinition() : collection</b></p>
<p>Returns the FHIR element definition information for each element in the input collection. If the 
  input collection is empty, the return value will be empty.
</p>

<p><b>slice(structure : string, name : string) : collection</b></p>
<p>
  Returns the given slice as defined in the given structure definition. The 
  structure argument is a uri that resolves to the structure definition, and 
  the name must be the name of a slice within that structure definition. 
  If the structure cannot be resolved, or the name of the slice within the resolved structure is not present, or those parameters are empty, 
  and empty value is returned.
</p>
<p>For every element in the input collection, if the resolved slice is present on the element, it will be returned. If the slice does not match any element in the input collection, or if the input collection is empty, the result is an empty collection (<code>{ }</code>).</p>

<p><b>checkModifiers(modifier : string) : collection</b></p>

<p>For each element in the input collection, verifies that there are no modifying extensions defined other than the ones given by the <code>modifier</code> argument. 
  If the check passes, the input collection is returned. Otherwise, an error is thrown, including if modifier is empty.</p>

<p><b>conformsTo(structure : string) : Boolean</b></p>
<p>Returns <code>true</code> if the single input element conforms to the profile specified by the <code>structure</code> argument, 
  and false otherwise. If the input is not a single item, the structure is empty, or the structure cannot be resolved to a valid profile, 
  the result is empty.</p>

<p><b>memberOf(valueset : string) : Boolean</b></p>

<p>When invoked on a single code-valued element, returns true if the code is a member of the given valueset.
When invoked on a single concept-valued element, returns true if any code in the concept is a member of the given valueset.
When invoked on a single string, returns true if the string is equal to a code in the valueset, so long as the valueset 
only contains one codesystem. If the valueset in this case contains more than one codesystem, the return value is empty.</p>

<p>If the valueset cannot be resolved as a uri to a value set, or the input is empty or has more than one value, the return value is empty.</p>
<p>Note that implementations are encouraged to make use of a terminology service to provide this functionality.</p>

<p>For example:</p>

<pre class="fhirpath">
Observation.component.where(code.memberOf('http://hl7.org/fhir/ValueSet/observation-vitalsignresult'))
</pre>

<p>This expression returns components that have a code that is a member of the observation-vitalsignresult valueset.</p>

<p><b>subsumes(code : Coding | CodeableConcept) : Boolean</b></p>

<p>When invoked on a Coding-valued element and the given code is Coding-valued, returns true if the source code is equivalent to the given code, or if the source code subsumes the given code (i.e. the source code is an ancestor of the given code in a subsumption hierarchy), and false otherwise.</p>
<p>If the Codings are from different code systems, the relationships between the code systems must be well-defined or the return value is an empty value.</p>
<p>When the source or given elements are CodeableConcepts, returns true if any Coding in the source or given elements is equivalent to or subsumes the given code.</p>
<p>If either the input or the code parameter are not single value collections, the return value is empty.</p>
<p>Note that implementations are encouraged to make use of a terminology service to provide this functionality.</p>

<p><b>subsumedBy(code: Coding | CodeableConcept) : Boolean</b></p>

<p>When invoked on a Coding-valued element and the given code is Coding-valued, returns true if the source code is equivalent to the given code, or if the source code is subsumed by the given code (i.e. the given code is an ancestor of the source code in a subsumption hierarchy), and false otherwise.</p>
<p>If the Codings are from different code systems, the relationships between the code systems must be well-defined or a run-time error is thrown.</p>
<p>When the source or given elements are CodeableConcepts, returns true if any Coding in the source or given elements is equivalent to or subsumed by the given code.</p>
<p>If either the input or the code parameter are not single value collections, the return value is empty.</p>
<p>Note that implementations are encouraged to make use of a terminology service to provide this functionality.</p>

<p><b>htmlChecks : Boolean</b></p>

<p>When invoked on a single <a href="narrative.html#xhtml">xhtml</a> element returns true if the <a href="narrative.html#rules">rules around
HTML usage</a> are met, and false if they are not. The return value is empty on any other kind of element, or a collection of 
xhtml elements.
</p>

<a name="changes"></a>
<h4>Changes to operators</h4>

<p><b>~ (Equivalence)</b></p>
<p>Equivalence works in exactly the same manner, but with the addition that for complex types, equality requires all child properties to be equal, <strong>except for "id" elements</strong>.</p>
<p>In addition, for Coding values, equivalence is defined based on the code and system elements only. The version, display, and userSelected elements are ignored for the purposes of determining Coding equivalence.</p>
<p>For CodeableConcept values, equivalence is defined as a non-empty intersection of Coding elements, using equivalence. In other words, two CodeableConcepts are considered equivalent if any Coding in one is equivalent to any Coding in the other.</p>

<a name="vars"></a>
<h4>Environment variables</h4>
<p>The FHIR specification adds support for additional environment variables:</p>
<p>The following environmental values are set for all contexts:</p>
<pre class="fhirpath">
%sct        // (string) url for snomed ct
%loinc      // (string) url for loinc
%"vs-[name]" // (string) full url for the provided HL7 value set with id [name]
%"ext-[name]" // (string) full url for the provided HL7 extension with id [name]
%resource	// The original resource current context is part of. When evaluating a datatype, this would be the resource the element is part of. Do not go past a root resource into a bundle, if it is contained in a bundle.

// Note that the names of the `vs-` and `ext-` constants are quoted (just like paths) to allow "-" in the name.
</pre>
<p>For example:</p>
<pre class="fhirpath">
Observation.component.where(code.memberOf(%"vs-observation-vitalsignresult"))
</pre>
<p>This expression returns components that have a code that is a member of the observation-vitalsignresult valueset.</p>
[%impl-note%]
Implementation Guides are allowed to define their own externals, and implementers should provide some appropriate configuration framework to allow these constants to be provided to the evaluation engine at run-time. E.g.:
</p>
<pre class="fhirpath">
%"us-zip" = '[0-9]{5}(-[0-9]{4}){0,1}'
</pre>
[%end-note-np%]

<p>Authors of Implementation Guides should be aware that adding specific environment variables restricts the use of the FHIRPath to their particular context.</p>

<p>Note that these tokens are not restricted to simple types, and they may have fixed values that are not known before evaluation at run-time, though there is no way to define these kinds of values in implementation guides.</p>


<a name="simple"></a>
<h3>Restricted Subset ("Simple")</h3>

<p>
This page documents a restricted subset of the <a href="http://hl7.org/fhirpath">FHIRPath language</a> that
is used in a few contexts in this specification. When the restricted
FHIRPath language subset is in use, the following rules apply:
</p>
<ul>
 <li>All statements SHALL start with the name of the context element (e.g. on a Patient resource, Patient.contact.name.), or SHALL be simply "$this" to refer to the element that has focus</li>
 <li>Operators SHALL NOT be used</li>
 <li>Only the following functions may be used:
   <ul>
    <li>.resolve()</li>
    <li>.extension("url")</li>
    <li>.ofType(type)</li>
   </ul>
   All other functions SHALL NOT be used
 </li>
</ul>
<p>
These rules exist to keep processing the path simple to support use of the path by processors that are not backed by a full FHIRPath implementation.
</p>
<p>
The following locations use this restricted FHIRPath language:
</p>
<ul>
 <li><a href="elementdefinition-definitions.html#ElementDefinition.slicing.discriminator.path">ElementDefinition.slicing.discriminator.path</a></li>
 <li><a href="metadatatypes-definitions.html#DataRequirement.dateFilter.path">DataRequirement.dateFilter.path</a></li>
 <li><a href="operationoutcome-definitions.html#OperationOutcome.issue.expression">OperationOutcome.issue.expression</a></li>
</ul>

<div class="draft-content">
<a name="txapi"></a>
<h3>Terminology Service API</h3>

<p style="background-color: #ffcccc; border:1px solid grey; padding: 5px; max-width: 790px;">
Unlike this rest of this page, the FHIR Terminology service API and the general server API (see below) are only draft (Maturity = 0). They will be advanced to a more
mature status following the usual <a href="versions.html#maturity">Maturity Model</a> for FHIR.
</p>

<p>
In order to support terminological reasoning in FHIRPath statements, FHIR defines
a general %terminologies object that FHIRPath implementations should make available.
Calls to this object are passed through a <a href="terminology-service.html">standard FHIR terminology service</a>.
</p>
<p>
Summary:
</p>
<pre class="fhirpath">
%terminologies.expand(valueSet, params) : ValueSet
%terminologies.lookup(coded, params) : Parameters
%terminologies.validateVS(valueSet, coded, params) : Parameters
%terminologies.validateCS(codeSystem, coded, params) : Parameters
%terminologies.subsumes(system, coded1, coded2, params) : code
%terminologies.translate(conceptMap, code, params) : Parameters
</pre>

<p>
All these functions return an empty value if any of the parameters 
are empty, or a collection with more than one value, or one or
more of the parameters are not valid.
</p>

<p><b>expand</b></p>

<pre class="fhirpath">
%terminologes.expand(valueSet, params) : ValueSet
</pre>
<p>
This calls the <a href="terminology-service.html#expand">Terminology Service $expand</a> operation (<a href="valueset-operation-expand.html">formal definition</a>).
</p>
<p>
Parameters:
</p>
<ul>
 <li><b>valueSet</b>: either an actual <a href="valueset.html">ValueSet</a>, or a <a href="references.html#canonical">canonical URL</a> reference to a value set.</li>
 <li><b>params</b>: a URL encoded string with other parameters for the expand operation (e.g. 'displayLanguage=en&amp;activeOnly=true')</li>
</ul>
<p>
<b>Return Value:</b> a <a href="valueset.html">ValueSet</a> with an expansion, or an empty value if an error occurs.
</p>

<p><b>lookup</b></p>

<pre class="fhirpath">
%terminologies.lookup(coded, params) : Parameters
</pre>
<p>
This calls the <a href="terminology-service.html#lookup">Terminology Service $lookup</a> operation (<a href="codesystem-operation-lookup.html">formal definition</a>).
</p>
<p>
Parameters:
</p>
<ul>
 <li><b>coded</b>: either a <a href="datatypes.html#coding">Coding</a>, a <a href="datatypes.html#CodeableConcept">CodeableConcept</a>, or a resource element that is a <a href="datatypes.html#code">code</a></li>
 <li><b>params</b>: a URL encoded string with other parameters for the lookup operation (e.g. 'date=2011-03-04&amp;displayLanguage=en')</li>
</ul>
<p>
<b>Return Value:</b>
</p>

<p><b>validateVS</b></p>

<pre class="fhirpath">
%terminologies.validateVS(valueSet, coded, params) : Parameters
</pre>
<p>
This calls the <a href="terminology-service.html#expand">Terminology Service $validate-code</a> operation on a value set
(<a href="valueset-operation-validate-code.html">formal definition</a>).
</p>
<p>
Parameters:
</p>
<ul>
 <li><b>valueSet</b>: either an actual <a href="valueset.html">ValueSet</a>, or a <a href="references.html#canonical">canonical URL</a> reference to a value set.</li>
 <li><b>coded</b>: either a <a href="datatypes.html#coding">Coding</a>, a <a href="datatypes.html#CodeableConcept">CodeableConcept</a>, or a resource element that is a <a href="datatypes.html#code">code</a></li>
 <li><b>params</b>: a URL encoded string with other parameters for the validate-code operation (e.g. 'date=2011-03-04&amp;displayLanguage=en')</li>
</ul>
<p>
<b>Return Value:</b> A <a href="parameters.html">Parameters</a> resource with the results of the validation operation.
</p>

<p><b>validateCS</b></p>

<pre class="fhirpath">
%terminologies.validateCS(codeSystem, coded, params) : Parameters
</pre>
<p>
This calls the <a href="terminology-service.html#expand">Terminology Service $validate-code</a> operation on a code system
(<a href="codesystem-operation-validate-code.html">formal definition</a>).
</p>
<p>
Parameters:
</p>
<ul>
 <li><b>codeSystem</b>: either an actual <a href="codesystem.html">CodeSystem</a>, or a <a href="references.html#canonical">canonical URL</a> reference to a code system.</li>
 <li><b>coded</b>: either a <a href="datatypes.html#coding">Coding</a>, a <a href="datatypes.html#CodeableConcept">CodeableConcept</a>, or a resource element that is a <a href="datatypes.html#code">code</a></li>
 <li><b>params</b>: a URL encoded string with other parameters for the validate-code operation (e.g. 'date=2011-03-04&amp;displayLanguage=en')</li>
</ul>
<p>
<b>Return Value:</b> A <a href="parameters.html">Parameters</a> resource with the results of the validation operation.
</p>

<p><b>subsumes</b></p>

<pre class="fhirpath">
%terminologies.subsumes(system, coded1, coded2, params) : code
</pre>
<p>
This calls the <a href="terminology-service.html#subsumes">Terminology Service $subsumes</a> operation (<a href="codesystem-operation-subsumes.html">formal definition</a>).
</p>
<p>
Parameters:
</p>
<ul>
 <li><b>system</b>: the URI of a code system within which the subsumption testing occurs</li>
 <li><b>coded1</b>: A <a href="datatypes.html#coding">Coding</a> or a resource element that is a <a href="datatypes.html#code">code</a></li>
 <li><b>coded2</b>: A <a href="datatypes.html#coding">Coding</a> or a resource element that is a <a href="datatypes.html#code">code</a></li>
 <li><b>params</b>: a URL encoded string with other parameters for the validate-code operation (e.g. 'version=2014-05-06')</li>
</ul>
<p>
<b>Return Value:</b> a code as specified for the subsumes operation.
</p>

<p><b>translate</b></p>

<pre class="fhirpath">
%terminologies.translate(conceptMap, coded, params) : Parameters
</pre>
<p>
This calls the <a href="terminology-service.html#translate">Terminology Service $translate</a> operation (<a href="conceptmap-operation-translate.html">formal definition</a>).
</p>
<p>
Parameters:
</p>
<ul>
 <li><b>conceptMap</b>: either an actual <a href="conceptmap.html">ConceptMap</a>, or a <a href="references.html#canonical">canonical URL</a> reference to a value set.</li>
 <li><b>coded</b>: The source to translate: a <a href="datatypes.html#coding">Coding</a> or a resource element that is a <a href="datatypes.html#code">code</a></li>
 <li><b>params</b>: a URL encoded string with other parameters for the validate-code operation (e.g. 'source=http://acme.org/valueset/23&amp;target=http://acme.org/valueset/23')</li>
</ul>
<p>
<b>Return Value:</b> A <a href="parameters.html">Parameters</a> resource with the results of the translation operation.
</p>

<a name="srvr-api"></a>
<h3>General Service API</h3>

<p>
In order to support interaction with a server in FHIRPath statements, FHIR defines
a general %server object that FHIRPath implementations should make available.
Calls to this object are passed through a <a href="terminology-service.html">standard FHIR terminology service</a>.
</p>
<p>
Summary:
</p>
<pre class="fhirpath">
%server : Server // default server (application controls context)
%server.at(url) : Server // server at specified address

%server.read(type, id) : Resource
%server.create(resource) : Resource
%server.update(resource) : Resource
%server.delete(resource) : boolean
%server.patch(parameters) : Resource
%server.search(doPost, parameters) : Bundle
%server.capabilities(mode) : Resource
%server.validate(resource, mode, parameters) : OperationOutcome
%server.transform(source, content) : Resource
%server.everything(type, id, parameters) : Bundle
%server.apply(resource, subject, parameters) : Bundle
</pre>

<pre class="fhirpath">
  %terminologies.at(url) : Server
</pre>
<p>
Get a server object pointing at a particular server.
Note: The %server object points to the default server as specified by the application evaluating the FHIRPath.
</p>
<p>
Parameters:
</p>
<ul>
  <li><b>url</b>: A URL that points to a FHIR RESTful API.</li>
</ul>
<p><b>Return Value:</b> A server that points at the specified URL. No errors - they will come when/if the server object is used.</p>
  

<pre class="fhirpath">
  %server.read(type, id) : Resource
</pre>
<p>
Get a resource from the server.
</p>
<p>
Parameters:
</p>
<ul>
  <li><b>type</b>: The type of the resource to read.</li>
  <li><b>id</b>: The id of the resource to read.</li>
</ul>
<p><b>Return Value:</b> The resource at type/id, or null.</p>


<pre class="fhirpath">
  %server.create(resource) : Resource
</pre>
<p>
Create a resource on the server.
</p>
<p>
Parameters:
</p>
<ul>
  <li><b>resource</b>: The resource to create. If the resource has an id, it will be ignored.</li>
</ul>
<p><b>Return Value:</b> The resource after it was stored, or null if the create operation failed.</p>

<pre class="fhirpath">
  %server.update(resource) : Resource
</pre>
<p>
Store a resource on the server.
</p>
<p>
Parameters:
</p>
<ul>
  <li><b>resource</b>: The resource to create. The resource must have an id.</li>
</ul>
<p><b>Return Value:</b> The resource after it was stored, or null if the create operation failed.</p>

<pre class="fhirpath">
  %server.delete(resource) : boolean
</pre>
<p>
Delete a resource on the server.
</p>
<p>
Parameters:
</p>
<ul>
  <li><b>resource</b>: The resource to delete (must have an id).</li>
</ul>
<p><b>Return Value:</b> true if the resource was deleted, or false.</p>

<pre class="fhirpath">
  %server.search(doPost, parameters) : Bundle
</pre>
<p>
Perform a search on the server.
</p>
<p>
Parameters:
</p>
<ul>
  <li><b>doPost</b>: A boolean value - true to use a POST, false to use a GET</li>
  <li><b>parameters</b>: A parameters resource, or a string with URL parameters (name=value&etc)</li>
</ul>
<p><b>Return Value:</b> A bundle with the search results, or null.</p>

<pre class="fhirpath">
  %server.patch(parameters) : Resource
</pre>
<p>
Perform a patch operation on the server.
</p>
<p>
Parameters:
</p>
<ul>
  <li><b>parameters</b>: A parameters resource for <a href="fhirpatch.html">FHIRPath Patch</a></li>
</ul>
<p><b>Return Value:</b> The resource after the patch, or null.</p>

<pre class="fhirpath">
  %server.capabilities(mode) : Resource
</pre>
<p>
Get the capabilities from the server
</p>
<p>
Parameters:
</p>
<ul>
  <li><b>mode</b>: Optional: the mode to fetch.</li>
</ul>
<p><b>Return Value:</b> The resource returned (CapabilitiesStatement or TerminologyCapabilities resource), or null.</p>

<pre class="fhirpath">
  %server.validate(resource, mode, parameters) : OperationOutcome
</pre>
<p>
Validate a resource on the server.
</p>
<p>
Parameters:
</p>
<ul>
  <li><b>resource</b>: The resource to validate.</li>
  <li><b>mode</b>: how to validate - see <a href="resource-operation-validate.html">Validation Operation</a>.</li>
  <li><b>parameters</b>: A parameters resource, or a string with URL parameters (name=value&etc)</li>
</ul>
<p><b>Return Value:</b> An operation outcome with issues, or null if the validation couldn't be performed.</p>

<pre class="fhirpath">
  %server.transform(source, content) : Resource
</pre>
<p>
Run the $transform operation on the server.
</p>
<p>
Parameters:
</p>
<ul>
  <li><b>source</b>: The structure map to use.</li>
  <li><b>content</b>: The resource to convert (often a binary)</li>
</ul>
<p><b>Return Value:</b> The resource returned from the transform, or null.</p>

<pre class="fhirpath">
  %server.everything(type, id, parameters) : Bundle
</pre>
<p>
Get a resource from the server.
</p>
<p>
Parameters:
</p>
<ul>
  <li><b>type</b>: The type of the resource to read.</li>
  <li><b>id</b>: The id of the resource to read.</li>
  <li><b>parameters</b>: A parameters resource, or a string with URL parameters (name=value&etc)</li>
</ul>
<p><b>Return Value:</b> The Bundle for type/id, or null.</p>

<pre class="fhirpath">
  %server.apply(resource, subject, parameters) : Bundle
</pre>
<p>
Get a resource from the server.
</p>
<p>
Parameters:
</p>
<ul>
  <li><b>resource</b>: The resource to drive the $apply operation (PlanDefinition, ActivityDefinition).</li>
  <li><b>subject</b>: The subject top apply to - can be a resource, or a string containing type/id for the subject.</li>
  <li><b>parameters</b>: A parameters resource, or a string with URL parameters (name=value&etc)</li>
</ul>
<p><b>Return Value:</b> The bundle from $apply, or null.</p>


</div>

[%file newfooter%]
</body>
</html>