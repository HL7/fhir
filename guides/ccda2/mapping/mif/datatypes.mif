<?xml version="1.0" encoding="UTF-8"?>
<mif:datatypeModelLibrary xmlns:mif="urn:hl7-org:v3/mif2" packageKind="version" name="1.0"
                          title="Data Types - Abstract Specification"
                          schemaVersion="2.1.5">
   <mif:packageLocation combinedId="DEFN=UV=DT=1.0" root="DEFN" artifact="DT" realmNamespace="UV"
                        version="1.0"/>
   <mif:header>
      <mif:contributor>
         <mif:role>Chair/Editor</mif:role>
         <mif:name name="Gunther Schadow"/>
         <mif:affiliation>Regenstrief Institute for Health Care</mif:affiliation>
         <mif:email>mailto://gunther@aurora.rg.iupui.edu</mif:email>
      </mif:contributor>
      <mif:contributor>
         <mif:role>Editor</mif:role>
         <mif:name name="Paul Biron"/>
         <mif:affiliation>Kaiser Permanente, Southern California</mif:affiliation>
         <mif:email>mailto://paul.v.biron@kp.org</mif:email>
      </mif:contributor>
      <mif:contributor>
         <mif:role>Editor</mif:role>
         <mif:name name="Lloyd McKenzie"/>
         <mif:affiliation>IBM Global Services</mif:affiliation>
         <mif:email>mailto://lmckenzi@ca.ibm.com</mif:email>
      </mif:contributor>
      <mif:contributor>
         <mif:role>Editor</mif:role>
         <mif:name name="Grahame Grieve"/>
         <mif:affiliation>Kestral Computing Pty. Ltd.</mif:affiliation>
         <mif:email>mailto://grahame@kestral.com.au</mif:email>
      </mif:contributor>
      <mif:contributor>
         <mif:role>Editor</mif:role>
         <mif:name name="Doug Pratt"/>
         <mif:affiliation>Siemens</mif:affiliation>
         <mif:email>mailto://Douglas.Pratt@siemens.com</mif:email>
      </mif:contributor>
      <mif:approvalInfo approvalStatus="Approved Normative Standard" ballotOccurrence="2"/>
   </mif:header>
   <mif:importedVocabularyModelPackage combinedId="DEFN=UV=VO" root="DEFN" realmNamespace="UV" artifact="VO"/>
   <mif:datatype name="ANY" title="DataValue" isAbstract="true" datatypeKind="Definition"
                 visibility="public">
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
Defines the basic properties of every data value. This is an abstract
type, meaning that no value can be just a data value without belonging
to any concrete type. Every concrete type is a specialization of this
general abstract DataValue type.
      </mif:text>
            </mif:definition>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
abstract type DataValue alias ANY {
    TYPE  dataType;
    BN  nonNull;
    BN  isNull;
    CS  nullFlavor;
    BL  notApplicable;
    BL  unknown;
    BL  other;
    BL  equal(ANY x);
};
      </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="dataType" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Data Type"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
Represents the fact that every data value implicitly carries
information about its own data type. Thus, given a data value one can
inquire about its data type.
        </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="TYPE"/>
      </mif:property>
      <mif:property name="nonNull" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Proper Value"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
Indicates that a value is a non-exceptional value of the data type.
        </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
When a property, RIM attribute, or message field is called
<mif:b>mandatory</mif:b> this means that any non-NULL value of the type
to which the property belongs has a non-NULL value for that
property, in other words, a field may not be NULL, providing that its
container (object, segment, etc.) is to have a non-NULL value.
        </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="BN"/>
      </mif:property>
      <mif:property name="isNull" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Exceptional Value"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
Indicates that a value is an exceptional value, or a NULL-value. A
null value means that the information does not exist, is not
available or cannot be expressed in the data type's normal value
set.
        </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
Every data element has either a proper value or it is
considered NULL. If (and only if) it is NULL, the <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> provides
more detail as to in what way or why no proper value is supplied.
        </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="BN"/>
      </mif:property>
      <mif:property name="nullFlavor" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Exceptional Value Detail"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
If a value is an exceptional value (NULL-value), this specifies in
what way and why proper information is missing.
        </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
The null flavors are a general domain extension of all normal data
types. Note the distinction between value domain of any data type and
the vocabulary domain of coded data types. A vocabulary domain is a
value domain for coded values, but not all value domains are
vocabulary domains.
        </mif:p>
                     <mif:p>
The null flavor "other" is used whenever the actual value is not in
the required value domain, this may be, for example, when the value
exceeds some constraints that are defined too restrictive (e.g., age
less than 100 years.)
        </mif:p>
                     <mif:p>
Some of these null flavors are associated with named properties that can be
used as simple predicates for all data values. This is done to
simplify the formulation of invariants in the remainder of this
specification.
        </mif:p>
                     <mif:p>
Remember the difference between semantic properties and
representational "components" of data values. An ITS must only
represent those components that are needed to <mif:b>infer</mif:b> the
semantic properties. The null-flavor predicates
<mif:object name="propertyRef">
                           <mif:param name="datatypeName" value="ANY"/>
                           <mif:param name="propertyName" value="nonNull"/>
                        </mif:object>,
<mif:object name="propertyRef">
                           <mif:param name="datatypeName" value="ANY"/>
                           <mif:param name="propertyName" value="isNull"/>
                        </mif:object>, <mif:object name="propertyRef">
                           <mif:param name="datatypeName" value="ANY"/>
                           <mif:param name="propertyName" value="notApplicable"/>
                        </mif:object>,
<mif:object name="propertyRef">
                           <mif:param name="datatypeName" value="ANY"/>
                           <mif:param name="propertyName" value="unknown"/>
                        </mif:object>, and
<mif:object name="propertyRef">
                           <mif:param name="datatypeName" value="ANY"/>
                           <mif:param name="propertyName" value="other"/>
                        </mif:object> can all be inferred from the <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object>
property.
        </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="CS"/>
      </mif:property>
      <mif:property name="notApplicable" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Inapplicable Proper Value"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A predicate indicating that this exceptional value is of
<mif:object name="propertyRef">
                        <mif:param name="datatypeName" value="ANY"/>
                        <mif:param name="propertyName" value="nullFlavor"/>
                     </mif:object> not-applicable (NA), i.e., that a proper
value is not meaningful in the given context.
        </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="unknown" sortKey="06" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="unknown"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A predicate indicating that this exceptional value is of <mif:object name="propertyRef">
                        <mif:param name="datatypeName" value="ANY"/>
                        <mif:param name="propertyName" value="nullFlavor"/>
                     </mif:object> unknown (UNK).
        </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="other" sortKey="07" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Value Domain Exception"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A predicate indicating that this exceptional value is of
<mif:object name="propertyRef">
                        <mif:param name="datatypeName" value="ANY"/>
                        <mif:param name="propertyName" value="nullFlavor"/>
                     </mif:object> other (OTH), i.e., that the required
value domain does not contain the appropriate value.
        </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="equal" sortKey="08" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
Equality is a reflexive, symmetric, and transitive relation between
any two data values. Only proper values can be equal, null values
never are equal (even if they have the same null flavor.)
        </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
How equality is determined must be defined for each data type. If
nothing else is specified, two data values are equal if they are
indistinguishable, that is, if they differ in none of their semantic
properties. A data type can "override" this general definition of
equality, by specifying its own equal relationship. This overriding
of the equality relation can be used to exclude semantic properties
from the equality test. If a data type excludes semantic properties
from its definition of equality, this implies that certain properties
(or aspects of properties) that are not part of the equality test are
not essential to the meaning of the value.
        </mif:p>
                     <mif:p>
For example the physical quantity has the two semantic properties (1)
a real number and (2) a coded unit of measure. The equality test,
however, must account for the fact that, e.g., 1 meter equals 100
centimeters; independent equality of the two semantic properties is
too strong a criterion for the equality test. Therefore, physical
quantity must override the equality definition.
        </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ANY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="TYPE" title="DataType" datatypeKind="Definition" visibility="private">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ANY"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
A meta-type declared in order to allow the formal definitions to speak
about the data type of a value. Any data type defined in this
specification is a value of the type DataType.
        </mif:text>
            </mif:definition>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
private type DataType alias TYPE specializes ANY {
    CS  shortName;
    CS  longName;

    BN	implies(TYPE that);
};

        </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="shortName" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Short Name"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="CS"/>
                     </mif:object> specifying the alias of the data type.
           </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="CS"/>
      </mif:property>
      <mif:property name="longName" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Long Name"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="CS"/>
                     </mif:object> specifying the full name of the data type.
          </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="CS"/>
      </mif:property>
      <mif:property name="implies" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Implies"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A data type implies another data type if it has the same type or is
a specialisation of it.
          </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="that" sortKey="1">
            <mif:type name="TYPE"/>
         </mif:parameter>
         <mif:type name="BN"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="BL" title="Boolean" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ANY"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
The Boolean type stands for the values of two-valued logic. A Boolean
value can be either <mif:b>true</mif:b> or <mif:b>false</mif:b>, or, as
any other value may be NULL.
    </mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
With any data value potentially being NULL, the two-valued logic is
effectively extended to a three-valued logic as shown in the following
truth tables:
    </mif:p>
                  <mif:table hl7Id="BL-truth-tables-not">
                     <mif:caption>Truth Table: NOT</mif:caption>
                     <mif:col width="10" span="1"/>
                     <mif:col width="10" span="1"/>
                     <mif:thead>
                        <mif:tr>
                           <mif:th>NOT</mif:th>
                           <mif:th> </mif:th>
                        </mif:tr>
                     </mif:thead>
                     <mif:tbody>
                        <mif:tr>
                           <mif:th>true</mif:th>
                           <mif:td>false</mif:td>
                        </mif:tr>
                        <mif:tr>
                           <mif:th>false</mif:th>
                           <mif:td>true</mif:td>
                        </mif:tr>
                        <mif:tr>
                           <mif:th>NULL</mif:th>
                           <mif:td>NULL</mif:td>
                        </mif:tr>
                     </mif:tbody>
                  </mif:table>
                  <mif:table hl7Id="BL-truth-tables-and">
                     <mif:caption>Truth Table: AND</mif:caption>
                     <mif:thead>
                        <mif:tr>
                           <mif:th>AND</mif:th>
                           <mif:th>true</mif:th>
                           <mif:th>false</mif:th>
                           <mif:th>NULL</mif:th>
                        </mif:tr>
                     </mif:thead>
                     <mif:tbody>
                        <mif:tr>
                           <mif:th>true</mif:th>
                           <mif:td>true</mif:td>
                           <mif:td>false</mif:td>
                           <mif:td>NULL</mif:td>
                        </mif:tr>
                        <mif:tr>
                           <mif:th>false</mif:th>
                           <mif:td>false</mif:td>
                           <mif:td>false</mif:td>
                           <mif:td>false</mif:td>
                        </mif:tr>
                        <mif:tr>
                           <mif:th>NULL</mif:th>
                           <mif:td>NULL</mif:td>
                           <mif:td>false</mif:td>
                           <mif:td>NULL</mif:td>
                        </mif:tr>
                     </mif:tbody>
                  </mif:table>
                  <mif:table hl7Id="BL-truth-tables-or">
                     <mif:caption>Truth Table: OR</mif:caption>
                     <mif:thead>
                        <mif:tr>
                           <mif:th>OR</mif:th>
                           <mif:th>true</mif:th>
                           <mif:th>false</mif:th>
                           <mif:th>NULL</mif:th>
                        </mif:tr>
                     </mif:thead>
                     <mif:tbody>
                        <mif:tr>
                           <mif:th>true</mif:th>
                           <mif:td>true</mif:td>
                           <mif:td>true</mif:td>
                           <mif:td>true</mif:td>
                        </mif:tr>
                        <mif:tr>
                           <mif:th>false</mif:th>
                           <mif:td>true</mif:td>
                           <mif:td>false</mif:td>
                           <mif:td>NULL</mif:td>
                        </mif:tr>
                        <mif:tr>
                           <mif:th>NULL</mif:th>
                           <mif:td>true</mif:td>
                           <mif:td>NULL</mif:td>
                           <mif:td>NULL</mif:td>
                        </mif:tr>
                     </mif:tbody>
                  </mif:table>
                  <mif:p>
Where a boolean operation is performed upon 2 data types with different
nullFlavors, the nullFlavor of the result is the first common ancestor
of the 2 different nullFlavors, though conformant applications may also
create a result that is any common ancestor
    </mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type Boolean alias BL specializes ANY
    values(true, false)
{
            BL  not;
            BL  and(BL x);
            BL  or(BL x);
            BL  xor(BL x);
            BL  implies(BL x);
  literal   ST;
};
    </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:enumerationValue>true</mif:enumerationValue>
      <mif:enumerationValue>false</mif:enumerationValue>
      <mif:property name="not" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Negation"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
Negation of a Boolean turns <mif:b>true</mif:b> into <mif:b>false</mif:b>
and <mif:b>false</mif:b> into <mif:b>true</mif:b> and is NULL for NULL
values.
      </mif:text>
               </mif:definition>
               <mif:otherAnnotation type="DTDL">
                  <mif:data>
invariant(BL x) {
  true.not.equal(false);
  false.not.equal(true);
  x.isNull.equal(x.not.isNull);
};
      </mif:data>
               </mif:otherAnnotation>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="and" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Conjunction"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
Conjunction (AND) is associative and commutative, with
<mif:b>true</mif:b> as a neutral element. <mif:b>False</mif:b> AND any
Boolean value is <mif:b>false</mif:b>. These rules hold even if one or
both of the operands are NULL. If both operands for AND are NULL,
the result is NULL.
      </mif:text>
               </mif:definition>
               <mif:otherAnnotation type="DTDL">
                  <mif:data>
invariant(BL x) {
  x.and(true).equal(x);
  x.and(false).equal(false);
  x.isNull.implies(x.and(y).isNull);
};
      </mif:data>
               </mif:otherAnnotation>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="BL"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="or" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Disjunction"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The disjunction <mif:b>x</mif:b> OR <mif:b>y</mif:b> is <mif:b>false</mif:b>
if and only if <mif:b>x</mif:b> is <mif:b>false</mif:b> and <mif:b>y</mif:b>
is <mif:b>false</mif:b>.
      </mif:text>
               </mif:definition>
               <mif:otherAnnotation type="DTDL">
                  <mif:data>
invariant(BL x, y) {
  x.or(y).equal(x.not.and(y.not).not);
};
      </mif:data>
               </mif:otherAnnotation>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="BL"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="xor" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Exclusive Disjunction"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The exclusive-OR constrains OR such that the two operands may not both
be <mif:b>true</mif:b>.
      </mif:text>
               </mif:definition>
               <mif:otherAnnotation type="DTDL">
                  <mif:data>
invariant(BL x, y) {
  x.xor(y).equal(x.or(y).and(x.and(y).not));
};
      </mif:data>
               </mif:otherAnnotation>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="BL"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="implies" sortKey="05" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Implication"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A rule of the form IF <mif:b>condition</mif:b> THEN
<mif:b>conclusion</mif:b>. Logically the implication is defined as the
disjunction of the negated condition and the conclusion, meaning that
when the condition is <mif:b>true</mif:b> the conclusion must be
<mif:b>true</mif:b> to make the overall statement <mif:b>true</mif:b>.
The logical implication is important to make invariant statements. 
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
The implication is not reversible and does not specify what is
<mif:b>true</mif:b> when the condition is <mif:b>false</mif:b> (<mif:b>ex
falso quodlibet</mif:b> lat. “from false follows anything”).
      </mif:p>
                  </mif:text>
               </mif:designComments>
               <mif:otherAnnotation type="DTDL">
                  <mif:data>
invariant(BL condition, conclusion) {
  condition.implies(conclusion).equal(
         condition.not.or(conclusion));
};
      </mif:data>
               </mif:otherAnnotation>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="BL"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="literal" sortKey="06" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
The literal form of the Boolean is determined by the named values
specified in the values clause, i.e., <mif:code>true</mif:code> and
<mif:code>false</mif:code>.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="ST"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="BN" title="BooleanNonNull" datatypeKind="Definition" visibility="private">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="BL"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
The BooleanNonNull constrains the boolean type so that the value may not be NULL.
This type is created for use within the data types specification where it is not
appropriate for a null value to be used
    </mif:text>
            </mif:definition>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
private type BooleanNonNull alias BN specializes BL;
    </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="isNull" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="isNull"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:type name="BN"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="BIN" title="BinaryData" datatypeKind="Definition" visibility="protected">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="LIST">
            <mif:argumentDatatype name="BN"/>
         </mif:targetDatatype>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
Binary data is a raw block of bits. Binary data is a protected
type that should not be declared outside the data type specification.
    </mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
A bit is semantically identical with a non-null Boolean value. Thus,
all binary data is — semantically — a sequence of non-null
Boolean values.
    </mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
protected type BinaryData alias BIN specializes LIST&lt;BN&gt;;
    </mif:data>
            </mif:otherAnnotation>
            <mif:otherAnnotation type="ITS-Note">
               <mif:text>
                  <mif:p>
the representation of arbitrary binary data is the responsibility of
an ITS. How the ITS accomplishes this depends on the underlying
Implementation Technology (whether it is character-based or binary)
and on the represented data. Semantically character data is
represented as binary data, however, a character-based ITS should not
convert character data into arbitrary binary data and then represent
binary data in a character encoding. Ultimately even character-based
implementation technology will communicate binary data.
      </mif:p>
               </mif:text>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text>
An empty sequence is not considered binary data but counts as a
NULL-value. In other words, non-NULL binary data contains at least one
bit. No bit in a non-NULL binary data value can be NULL.
      </mif:text>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(BIN x) where x.nonNull {
  x.notEmpty;
  x.length.greaterThan(0);
};
      </mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="ED" title="EncapsulatedData" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="BIN"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
Data that is primarily intended for human interpretation or for
further machine processing outside the scope of HL7. This includes
unformatted or formatted written language, multimedia data, or
structured information in as defined by a different standard (e.g.,
XML-signatures.)  Instead of the data itself, an <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="ED"/>
                  </mif:object>
may contain only a reference (see <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="TEL"/>
                  </mif:object>.) Note that
the <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="ST"/>
                  </mif:object> data type is a specialization of the
<mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="ED"/>
                  </mif:object> data type when the <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="ED"/>
                  </mif:object> media
type is text/plain.
    </mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
Encapsulated data can be present in two forms, inline or by
reference. Inline data is communicated or moved as part of the
encapsulated data value, whereas by-reference data may reside at a
different (remote) location. The data is the same whether it is
located inline or remote.
    </mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type EncapsulatedData alias ED specializes  BIN {
  CS   mediaType;
  CS   charset;
  CS   language;
  CS   compression;
  TEL  reference;
  BIN  integrityCheck;
  CS   integrityCheckAlgorithm;
  ED   thumbnail;
};
    </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="mediaType" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="text/plain"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Media Type"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
Identifies the type of the encapsulated data and identifies a
method to interpret or render the data.
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
The IANA defined domain of media types is established by the Internet
standard RFC 2045 [<mif:a href="http://www.ietf.org/rfc/rfc2045.txt"/>]
and 2046 [<mif:a href="http://www.ietf.org/rfc/rfc2046.txt"/>].
RFC 2046 defines the media type to consist of two parts:
      </mif:p>
                     <mif:ol>
                        <mif:li>
                           <mif:p>top level media type, and</mif:p>
                        </mif:li>
                        <mif:li>
                           <mif:p>media subtype.</mif:p>
                        </mif:li>
                     </mif:ol>
                     <mif:p>
However, this specification treats the entire media type as one atomic
code symbol in the form defined by IANA, i.e., top level type followed
by a slash "/" followed by media subtype. Currently defined media
types are registered in a database
[<mif:a href="http://www.iana.org/assignments/media-types/index.html"/>]
maintained by IANA. Currently more than 160 different MIME media types are
defined, with the list growing rapidly. In general, all those types
defined by the IANA may be used.
      </mif:p>
                     <mif:p>
To promote interoperability, this specification prefers certain media
types to others. This is to define a greatest common denominator on
which interoperability is not only possible, but that is powerful
enough to support even advanced multimedia communication needs.
      </mif:p>
                     <mif:p>
							                 <mif:object name="conceptDomainRef">
                           <mif:param name="name" value="MediaType"/>
                        </mif:object> below assigns a status to
certain MIME media types, where the status means one of the following:
      </mif:p>
                     <mif:ul>
                        <mif:li>
                           <mif:p>
									                     <mif:strong>required</mif:strong>: Every HL7 application
must support at least the required media types if it supports a given
kind of media. One required media-type for each kind of media
exists. Some media types are required for a specific purpose, which is
then indicated as "required for ..."
          </mif:p>
                        </mif:li>
                        <mif:li>
                           <mif:p>
									                     <mif:strong>recommended</mif:strong>: Other media types are
recommended for a particular purpose. For any given purpose there
should be only very few additionally recommended media types and the
rationale, conditions and assumptions of such recommendations must be
made very clear.
          </mif:p>
                        </mif:li>
                        <mif:li>
                           <mif:p>
									                     <mif:strong>indifferent</mif:strong>: This status means, HL7
neither forbids nor endorses the use of this media type. All media
types not mentioned in <mif:object name="conceptDomainRef">
                                 <mif:param name="name" value="MediaType"/>
                              </mif:object> have status indifferent by default.
Since there is one required and several recommended media types for most
practically relevant use cases, media types of this status should be used
very conservatively.
          </mif:p>
                        </mif:li>
                        <mif:li>
                           <mif:p>
									                     <mif:strong>deprecated</mif:strong>: Deprecated media types
should not be used, because these media types are flawed, because
there are better alternatives, or because of certain risks. Such risks
could be security risks, for example, the risk that such a media type
could spread computer viruses. Not every flawed media type is marked
as deprecated, though. A media type that is not mentioned in Table 6,
and thus has status indifferent, may well be flawed.
          </mif:p>
                        </mif:li>
                     </mif:ul>
                     <mif:p>
The set of required media types is very small so that no undue
requirements are forced on HL7 applications, especially legacy
systems. In general, no HL7 application is forced to support any given
kind of media other than written text. For example, many systems just
do not want to receive audio data, because those systems can only show
written text to their users. It is a matter of application conformance
statements to say: "I will not handle audio". Only if a system claims
to handle audio media, it must support the required media type for
audio.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text>
The mediaType is a mandatory property, i.e., every non-NULL instance of
ED must have a non-NULL medaType property.
        </mif:text>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ED x) where x.nonNull {
  x.mediaType.nonNull;
};
        </mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="MediaType"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="charset" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Charset"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
For character-based encoding types, this property specifies the
character set and character encoding used. The charset shall be
identified by an Internet Assigned Numbers Authority (IANA) 
Charset Registration [<mif:a href="http://www.iana.org/assignments/character-sets"/>] 
in accordance with RFC 2978 [<mif:a href="http://www.ietf.org/rfc/rfc2978.txt"/>].
        </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
The charset domain is maintained by the <mif:b>Internet Assigned
Numbers Authority</mif:b> (IANA) [<mif:a href="http://www.iana.org/assignments/character-sets"/>].
The IANA source specifies names and multiple aliases for most character
sets. For HL7's purposes, use of multiple alias names is not
allowed. The standard name for HL7 is the one marked by IANA as
"preferred for MIME."  If IANA has not marked one of the aliases as
"preferred for MIME" the main name shall be the one used for HL7.
        </mif:p>
                     <mif:p>
							                 <mif:object name="conceptDomainRef">
                           <mif:param name="name" value="Charset"/>
                        </mif:object> lists a few of the IANA defined
character sets that are of interest to current HL7 members.

						</mif:p>
                     <mif:p>
The charset property needs to be known where the data of the ED is character type
data in any form. If the data is provided in-line, then the charset must be 
known. If the data is provided as a reference, and the access method does not provide
the charset for the data, typically as a mime header, then the charset must be 
conveyed as part of the ED. 
						</mif:p>
                     <mif:p>
Interested readers may also want to consult the "Character Model for
the World Wide Web" [http://www.w3.org/TR/charmod] for a more complete
discussion of character set and related issues
</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="Charset"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="language" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Language"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
For character based information the language property specifies the
human language of the text.
        </mif:text>
               </mif:definition>
               <mif:rationale>
                  <mif:text>
The need for a language code for text data values is documented in RFC
2277, IETF Policy on Character Sets and Languages [<mif:a href="http://www.ietf.org/rfc/rfc2277.txt"/>]. Further background
information can be found in Using International Characters in Internet
Mail [<mif:a href="http://www.imc.org/mail-i18n.html"/>], a memo by the
Internet Mail Consortium.
        </mif:text>
               </mif:rationale>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
The principles of the code domain of this attribute are specified by
the Internet standard <mif:a href="http://www.ietf.org/rfc/rfc3066.txt"/>. The RFC 3066
coding scheme is constructed from a primary subtag component encoded
using the language codes of ISO 639, plus two codes for extensions
for languages not represented in ISO 639.  The code optionally includes a
second subtag component encoded using the two letter country codes of ISO
3166, or a language code extension registered by the Internet Assigned
Names Authority [http://www.iana.org/assignments/language-tags].<mif:object name="footnote">
									RFC 3066 is
the HL7-approved coding system for all reference to human languages,
in data types and elsewhere.
            </mif:object>
						               </mif:p>
                     <mif:p>
While Language tags usually alter the meaning of the text, the language does
not alter the meaning of the characters in the text.
            <mif:object name="footnote">
For this reason, a system or site that does not deal with multilingual
text or names in the real world can safely ignore the language
property.
            </mif:object>
						               </mif:p>
                     <mif:p>
The language tag should not be mandatory if it is not mandatory in the
implementation technology. Semantically, language tagging of strings
follows a default-logic. In circumstances where a realm may support
multiple langauges, it is up to the realm to define rules to handle
language where none is specified when no language is specified. If no
other rule is specified, the local language of the reader is assumed.
If a language is set for an entire message or document, that language
is the default. If any information element or value that is superior in
the syntax hierarchy specifies a language, that language is the default
for all subordinate text values.
        </mif:p>
                     <mif:p>
If language tags are present in the beginning of the encoded binary
text (e.g., through Unicode's plane-14 tags) this is the source of the
language property of the encapsulated data value.
        </mif:p>
                  </mif:text>
               </mif:designComments>
               <mif:otherAnnotation type="ITS-Note">
                  <mif:text>
                     <mif:p>
Representation of language tags to text is highly dependent on the
ITS. An ITS may use the native way of language tagging provided by
its target implementation technology. Some may have language
information in a separate component, e.g., XML has the xml:lang tag
for strings. Others may rely on language tags as part of the binary
character string representation, e.g., ISO 10646 (Unicode) and its
"plane-14" language tags.
          </mif:p>
                  </mif:text>
               </mif:otherAnnotation>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="HumanLanguage"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="compression" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="NullFlavor.NI"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1">
         <mif:businessName name="Compression"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
Indicates whether the raw byte data is compressed, and what
compression algorithm was used.
        </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							
							                 <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="ST"/>
                        </mif:object> may never be compressed.
        </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="CompressionAlgorithm"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="reference" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1">
         <mif:businessName name="Reference"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A telecommunication address (TEL), such as a URL for HTTP or FTP,
which will resolve to precisely the same binary data that could as
well have been provided as inline data.
        </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
The semantic value of an encapsulated data value is the same,
regardless whether the data is present inline data or just
by-reference. However, an encapsulated data value without inline data
behaves differently, since any attempt to examine the data requires
the data to be downloaded from the reference. An encapsulated data
value may have both inline data and a reference.
        </mif:p>
                     <mif:p>
The reference must point to the same data as provided inline.
It is an error if the data resolved through the reference does
not match either the integrity check, in-line data, or data that
had earlier been retrieved through the reference and then cached.
        </mif:p>
                     <mif:p>
The reference may contain a usablePeriod to indicate that the
data may only be available for a limited period of time. Whether
the reference is limited by a usablePeriod or not, the content of
the reference is fixed for all time. Any application using the
reference must always receive the same data. The reference cannot
be reused to send a different version of the same data, or different
data.
        </mif:p>
                     <mif:p>
By-reference encapsulated data may not be allowed depending on the
attribute or component that is declared encapsulated data.
<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="ST"/>
                        </mif:object> must always be inline.
        </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="TEL"/>
      </mif:property>
      <mif:property name="integrityCheck" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1">
         <mif:businessName name="Integrity Check"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The integrity check is a short binary value representing a
cryptographically strong checksum that is calculated over the binary
data. The purpose of this property, when communicated with a reference
is for anyone to validate later whether the reference still resolved
to the same data that the reference resolved to when the encapsulated
data value with reference was created.
        </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
It is an error if the data resolved through the reference does not match
the integrity check.
        </mif:p>
                     <mif:p>
The integrity check is calculated according to the <mif:object name="propertyRef">
                           <mif:param name="datatypeName" value="ED"/>
                           <mif:param name="propertyName" value="integrityCheckAlgorithm"/>
                        </mif:object>. By default, the <mif:b>Secure
Hash Algorithm-1</mif:b> (SHA-1) shall be used. The integrity check is
binary encoded according to the rules of the integrity check
algorithm.
        </mif:p>
                     <mif:p>
The integrity check is calculated over the raw binary data that is
contained in the data component, or that is accessible through the
reference. No transformations are made before the integrity check is
calculated. If the data is compressed, the Integrity Check is
calculated over the compressed data.
        </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="BIN"/>
      </mif:property>
      <mif:property name="integrityCheckAlgorithm" sortKey="07" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="SHA-1"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Integrity Check Algorithm"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
Specifies the algorithm used to compute the integrityCheck
value.<mif:object name="footnote">
The cryptographically strong checksum algorithm Secure Hash
Algorithm-1 (SHA-1) is currently the industry standard. It has
superseded the MD5 algorithm only a couple of years ago, when certain
flaws in the security of MD5 were discovered. Currently the SHA-1 hash
algorithm is the default choice for the integrity check algorithm.
Note that SHA-256 is also entering widespread usage.
            </mif:object>
						            </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="IntegrityCheckAlgorithm"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="thumbnail" sortKey="08" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="NullFlavor.NI"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1">
         <mif:businessName name="Thumbnail"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
An abbreviated rendition of the full data. A thumbnail requires
significantly fewer resources than the full data, while still
maintaining some distinctive similarity with the full data. A
thumbnail is typically used with by-reference encapsulated data. It
allows a user to select data more efficiently before actually
downloading through the reference.
        </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
Originally, the term thumbnail refers to an image in a lower
resolution (or smaller size) than another image. However, the
thumbnail concept can be metaphorically used for media types other
than images. For example, a movie may be represented by a shorter
clip; an audio-clip may be represented by another audio-clip that is
shorter, has a lower sampling rate, or a lossy compression.
        </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text>
Thumbnails may not be allowed depending on the attribute or component
that is declared encapsulated data. <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="ST"/>
                     </mif:object> never have thumbnails, and a thumbnail may not itself
contain a thumbnail.
          </mif:text>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ED x) where x.thumbnail.nonNull {
  x.thumbnail.thumbnail.isNull;
};
          </mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ED"/>
      </mif:property>
      <mif:property name="equal" sortKey="09" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
Two values of type ED are equal if and only if their mediatype
and data are equal. For those <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="ED"/>
                        </mif:object> values
with compressed data or referenced data, only the de-referenced and
uncompressed data counts for the equality test. The compression, thumbnail
and reference property themselves are excluded from the equality test.
In addition the language property is excluded from the test, due to the
problems this would introduce values of type ED where the language is not
specified. If the ED.mediaType is character based and the charset property
is not equal, the charset property must be resolved through mapping of the
data between the different character sets.
        </mif:p>
                     <mif:p>
The integrity check algorithm and integrity check is excluded from the
equality test. However, since equality of integrity check value is
strong indication for equality of the data, the equality test can be
practically based on the integrity check, given equal integrity check
algorithm properties.
        </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ANY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="ST" title="CharacterString" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="ED"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
The character string data type stands for text data, primarily
intended for machine processing (e.g., sorting, querying, indexing,
etc.) Used for names, symbols, and formal expressions.
    </mif:text>
            </mif:definition>
            <mif:requirements>
               <mif:text>
					             <mif:p>
						               <mif:strong>Requirement</mif:strong>:<mif:br/>
ST is a specialization of ED so that any RIM attribute which has the type
ED can be constrained to a ST. The most important case is Act.text, which is
an ED to cater for the use of references and multimedia data, but is often
constrained to plain text.
</mif:p>
				           </mif:text>
            </mif:requirements>
            <mif:designComments>
               <mif:text>
                  <mif:p>
The character string is a restricted encapsulated data type (<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="ED"/>
                     </mif:object>),
whose type property is fixed to <mif:b>text/plain</mif:b>, and whose data must be
inlined and not compressed. Thus, the properties compression, reference,
integrity check, algorithm, and thumbnail are not applicable. The character
string data type is used when the appearance of text does not bear meaning,
which is true for formalized text and all kinds of names.
    </mif:p>
                  <mif:p>
The character string (ST) data type interprets the encapsulated data
as character data (as opposed to bits), depending on the charset
property of the encapsulated data type.
    </mif:p>
                  <mif:p>
The headCharacter and tailString properties define ST as a sequence
of entities each of which uniquely identifies one character from the
joint set of all characters known by any language of the world. <mif:object name="footnote">
ISO/IEC 10646-1: 1993 defines a character as "A member of a set of
elements used for the organization, control, or representation of
data."  ISO/IEC TR 15285 - An operational model for characters and
glyphs. Discusses the problems involved in defining
characters. Notably, characters are abstract entities of information,
independent of type font or language. The ISO 10646 (UNICODE
[http://www.unicode.org]) - or in Japan, JIS X0221 - is a globally
applicable character set that uniquely identifies all characters of
any language in the world.
        
In this specification, ISO 10646 serves as a semantic model for
character strings. The important point is that for semantic purposes,
there is no notion of separate character sets and switching between
character sets. Character set and character encoding are ITS layer
considerations. The formal definition gives indication to this effect
because each character is by itself an  value that
has a charset property. Thus, the binary encoding of each character is
always understood in the context of a certain character set. This does
not mean that the ITS should represent a character string as a
sequence of full blown  values. What it means is that
on the application layer the notion of character encoding is
irrelevant when we deal with character strings.
        </mif:object>
The length of a character string is the number of characters in the string.
    </mif:p>
                  <mif:p>
The head of a string is a string of only one character. A character
string must at least have one character or else it is NULL. A
zero-length string is an exceptional value (NULL), not a proper
character string value.
    </mif:p>
                  <mif:p>
The length of a string is the number of characters, not the number of
encoded bytes. Byte encoding is an ITS issue and is not relevant on
the application layer.
    </mif:p>
                  <mif:p>
The following rules apply to whitespace contained within character strings:
    </mif:p>
                  <mif:ul>
                     <mif:li>
                        <mif:p>
TAB, space and end-of-line are all considered whitespace characters.
            </mif:p>
                     </mif:li>
                     <mif:li>
                        <mif:p>
Both preceding and trailing whitespace is significant.
            </mif:p>
                     </mif:li>
                     <mif:li>
                        <mif:p>
Different whitespace characters are not interchangable.
            </mif:p>
                     </mif:li>
                     <mif:li>
                        <mif:p>
Different representations of end-of-line are normalised according to the
method described in the XML specification
[<mif:a href="http://www.w3.org/TR/2000/REC-xml-20001006#sec-line-ends"/>]
            </mif:p>
                     </mif:li>
                     <mif:li>
                        <mif:p>
Sequences of whitespace cannot be compressed to shorter sequences.
            </mif:p>
                     </mif:li>
                  </mif:ul>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type CharacterString alias ST specializes ED {
    ST    headCharacter;
    ST    tailString;
    literal ST;
};
    </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="mediaType" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="text/plain"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Media Type"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
Fixed to be "text/plain".
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="MediaType"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="charset" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Charset"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
Values of type ST must have a known charset. 
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="Charset"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="compression" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="NullFlavor.NA"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Compression"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
Values of type ST cannot be compressed.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="CompressionAlgorithm"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="reference" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="NullFlavor.NA"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Reference"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
Values of type ST may not reference content from some other location.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="TEL"/>
      </mif:property>
      <mif:property name="integrityCheck" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="NullFlavor.NA"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Integrity Check"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
Integrity check code is not used with values of type ST.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="BIN"/>
      </mif:property>
      <mif:property name="integrityCheckAlgorithm" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="NullFlavor.NA"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Integrity Check Algorithm"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
Integrity check code is not used with values of type ST.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="IntegrityCheckAlgorithm"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="thumbnail" sortKey="07" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="NullFlavor.NA"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Thumbnail"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
Values of type ST do not have thumbnails.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="ED"/>
      </mif:property>
      <mif:property name="headCharacter" sortKey="08" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="HeadCharacter"/>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="tailString" sortKey="09" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="TailString"/>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="literal" sortKey="10" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
Two variations of character string literals are defined, a token form
and a quoted string.<mif:object name="footnote">
A character string literal is a conversion from a character string to
another data type. Obviously, character string literals for character
strings is a cyclical if not redundant feature. This literal form,
therefore, mainly specifies how character strings are parsed in the
data type specification language.
          </mif:object>
The token form consists only of the lower case and upper case Latin
alphabet, the ten decimal digits and the underscore. The quoted string
can contain any character between double-quotes. The double quotes
prevent a character string from being interpreted as some other
literal. The token form allows keywords and names to be parsed from
the data type specification language.
      </mif:p>
                  </mif:text>
               </mif:designComments>
               <mif:otherAnnotation type="LiteralFormat">
                  <mif:data>
ST.literal ST {
  ST : /"[^]+"/ { $.equal($1); }         /* quoted string */
     | /[a-zA-Z0-9_]+/ { $.equal($1); }; /* token form */
};
      </mif:data>
               </mif:otherAnnotation>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="ST"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="CD" title="ConceptDescriptor" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ANY"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
A concept descriptor represents any kind of concept usually by
giving a code defined in a code system.

A concept descriptor can contain the original text or phrase that
served as the basis of the coding and one or more translations into
different coding systems.

A concept descriptor can also contain qualifiers to describe, e.g., the
concept of a "left foot" as a postcoordinated term built from the
primary code "FOOT" and the qualifier "LEFT".

In cases of an exceptional value, the concept descriptor need not contain a code
but only the original text describing that concept.
    </mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
The concept descriptor is mostly used in one of its restricted or
“profiled” forms, CS, CE, CV.
    </mif:p>
                  <mif:p>
Use of the full concept descriptor data type is not common. It
requires a conscious decision and documented rationale. In all other
cases, one of the <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="CD"/>
                     </mif:object> restrictions shall be
used.<mif:object name="footnote">
The advantage of the concept descriptor data type is its expressiveness,
however, if all of its features, such as coding exceptions, text, translations 
and qualifiers are used at all times, implementation and use become very 
difficult and unsafe. Therefore, the  type is most often
used in a restricted form with reduced features.
      </mif:object>
				              </mif:p>
                  <mif:p>
All <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="CD"/>
                     </mif:object> restrictions constrain certain properties of the
<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="CD"/>
                     </mif:object>. Properties may be constrained to the extent that
only one value may be allowed for that property, in which case
mentioning the property becomes redundant. Constraining a property to
one value is referred to as suppressing that property. Although,
conceptually a suppressed property is still semantically applicable,
it is safe for an HL7 interface to assume the implicit default value
without testing.
  </mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type ConceptDescriptor alias CD specializes ANY {
            ST    code;
            UID   codeSystem;
            ST    codeSystemName;
            ST    codeSystemVersion;
            ST    displayName;
            ED    originalText;
            SET&lt;CD&gt;   translation;
            LIST&lt;CR&gt;  qualifier;
            BL  implies(CD x);
};
    </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="code" sortKey="01" propertyKind="variableProperty" visibility="public"
                    defaultValue="NullFlavor.NI"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Code"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The plain code symbol defined by the code system. For example,
"784.0" is the code symbol of the ICD-9 code "784.0" for headache.
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
A non-exceptional <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="CD"/>
                        </mif:object> value has a non-NULL code property
whose value is a character string that is a symbol defined by the
coding system identified by the codeSystem property. Conversely, a
<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="CD"/>
                        </mif:object> value without a value for the code property, or with
a value that is not from the cited coding system is an exceptional
value (NULL of flavor <mif:b>other</mif:b>).
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="codeSystem" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Code System"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
Specifies the code system that defines the code.
    </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
Code systems shall be referred to by Unique Identifier
(<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="UID"/>
                        </mif:object>). The <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="UID"/>
                        </mif:object> allows unambiguous 
reference to standard HL7 codes, other standard code systems, as well as local
codes. HL7 shall assign an <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="UID"/>
                        </mif:object> to each of its code
tables as well as to external standard coding systems that are being
used with HL7. Local sites must use their ISO Object Identifier
(<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="OID"/>
                        </mif:object>) to construct a globally unique local coding
system identifier.
      </mif:p>
                     <mif:p>
Under HL7's branch, 2.16.840.1.113883, the sub-branches 5 and 6
contain HL7 standard and external code system identifiers
respectively. The HL7 Vocabulary Technical Committee maintains these
two branches.
      </mif:p>
                     <mif:p>
A non-exceptional <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="CD"/>
                        </mif:object> value (i.e. a <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="CD"/>
                        </mif:object>
value that has a non-null code property) has a non-NULL code system
specifying the system of concepts that defines the code. In other
words whenever there is a code there is also a code system.
      </mif:p>
                     <mif:p>
An exceptional <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="CD"/>
                        </mif:object> of NULL-flavor "other" indicates that
a concept could not be coded in the coding system specified. Thus, for
these coding exceptions, the code system that did not contain the
appropriate concept must be provided in the code system property.
      </mif:p>
                     <mif:p>
Some code domains are qualified such that they include the portion of
any pertinent local coding system that does not simply paraphrase the
standard coding system (<mif:b>coded with extensibility</mif:b>, CWE.)
If a CWE qualified field actually contains such a local code, the
coding system must specify the local coding system from which the
local code was taken. However, for CWE domains the local code is a
valid member of the domain, so that local codes in CWE domains
constitute neither an error nor an exceptional (NULL/other) value in
the sense of this specification.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="UID"/>
      </mif:property>
      <mif:property name="codeSystemName" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="NullFlavor.NI"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Code System Name"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The common name of the coding system.
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
The code system name has no computational value. The purpose of a code
system name is to assist an unaided human interpreter of a code value to
interpret the code system <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="UID"/>
                        </mif:object>. It is suggested — though
not absolutely required — that ITS provide for code system name fields in
order to annotate the <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="UID"/>
                        </mif:object> for human comprehension.
      </mif:p>
                     <mif:p>
HL7 systems must not functionally rely on the code system name. The
code system name can never modify the meaning of the code system
<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="UID"/>
                        </mif:object> value and cannot exist without the 
<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="UID"/>
                        </mif:object> value.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="codeSystemVersion" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="NullFlavor.NI"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1">
         <mif:businessName name="Code System Version"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
If applicable, a version descriptor defined specifically for the given
code system.
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
HL7 shall specify how these version strings are formed for each
external code system. If HL7 has not specified how version strings are
formed for a particular coding system, version designations have no
defined meaning for such coding system.
      </mif:p>
                     <mif:p>
Different versions of one code system must be compatible. Whenever a
code system changes in an incompatible way, it will constitute a new
code system, not simply a different version, regardless of how the
vocabulary publisher calls it.
      </mif:p>
                     <mif:p>
For example, the publisher of ICD-9 and ICD-10 calls these code
systems, "revision 9" and "revision 10" respectively. However, ICD-10
is a complete redesign of the ICD code, not a backward compatible
version. Therefore, for the purpose of this data type specification,
ICD-9 and ICD-10 are different code systems, not just different
versions. By contrast, when LOINC updates from revision "1.0j" to
"1.0k", HL7 would consider this to be just another version of LOINC,
since LOINC revisions are backwards compatible.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="displayName" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="NullFlavor.NI"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Display Name"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A name or title for the code, under which the sending system shows the
code value to its users.
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
The display name is included both as a courtesy to an unaided human
interpreter of a code value and as a documentation of the name used to
display the concept to the user. The display name has no functional
meaning; it can never exist without a code;  and it can never
modify the meaning of the code.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="originalText" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="NullFlavor.NI"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Original Text"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The text or phrase used as the basis for the coding.
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
The original text exists in a scenario where an originator of the
information does not assign a code, but where the code is assigned
later by a coder (post-coding.)  In the production of a concept
descriptor, original text may thus exist without a code.
            </mif:p>
                     <mif:p>
Values of type <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="CD"/>
                        </mif:object> may have a non-NULL original text
property despite having a NULL code property. Any <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="CD"/>
                        </mif:object> value
with the code property of NULL signifies a coding exception. In this case,
the originalText property is a name or description of the concept that was
not coded. Such exceptional <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="CD"/>
                        </mif:object> may contain translations.
Such translations directly encode the concept described in the original text
property.
      </mif:p>
                     <mif:p>
A concept descriptor can be demoted into a character string (<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="ST"/>
                        </mif:object>)
value representing only the original text of the <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="CD"/>
                        </mif:object> value.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="ED"/>
      </mif:property>
      <mif:property name="translation" sortKey="07" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="NullFlavor.NI"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*">
         <mif:businessName name="Translation"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A set of other concept descriptors that translate this concept
descriptor into other code systems.
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
The translation property is a set of other concept descriptors that
each translate the first concept descriptor into different code
systems. Each element of the translation set was translated from the
first concept descriptor. Each translation may, however, also contain
translations. Thus, when a code is translated multiple times the
information about which code served as the input to which translation
will be preserved.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="SET">
            <mif:argumentDatatype name="CD"/>
         </mif:type>
      </mif:property>
      <mif:property name="qualifier" sortKey="08" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="NullFlavor.NI"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*">
         <mif:businessName name="Qualifier"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
Specifies additional codes that increase the specificity of the the
primary code.
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
The primary code and all the qualifiers together make up one
concept. A concept descriptor with qualifiers is also called a
<mif:b>code phrase</mif:b> or <mif:b>postcoordinated expression</mif:b>.
      </mif:p>
                     <mif:p>
Qualifiers constrain the meaning of the primary code, but cannot negate
it or change it's meaning to that of another value in the primary coding
system
      </mif:p>
                     <mif:p>
Qualifiers can only be used according to well-defined rules of
post-coordination. A value of type CD may only have qualifiers if it's
code system defines the use of such qualifiers or if there is a third
code system that specifies how other code systems may be combined.
      </mif:p>
                     <mif:p>
For example, SNOMED CT allows constructing concepts as a combination
of multiple codes. SNOMED CT defines a concept "cellulitis (disorder)"
(128045006) an attribute "finding site" (363698007) and another
concept "foot structure (body structure)" (56459004). SNOMED CT allows
one to combine these codes in a code phrase:
</mif:p>
                     <mif:p>
In this example, there is one code system, SNOMED-CT that defines all the
primary code and the qualifiers and how these are used, which is why in our
example representation the codeSystem does not need to be mentioned for the
qualifier name and value (the codeSystem is inherited from the primary code.)
      </mif:p>
                     <mif:p>
It is important to note that the allowable qualifiers are specified by
the code system. For instance, in SNOMED CT, there is a defined set of
qualifying attributes, and only Findings and Disorders can be
qualified with the "finding site" attribute. Use of qualifiers outside
the boundaries specified by the code system is a non-conformant use of
the CD data type. Adherence to the rules specified by the code system
enables post-coordinated expressions to be compared with
pre-coordinated concepts (such as where one might compare the above
code phrase to the pre-coordinated concept "cellulitis of foot
(disorder)" (128276007), which is defined within SNOMED CT as having a
finding site of foot structure).   The CD datatype does not provide
for normalization of compositional expressions, therefore it is
possible to create ambiguous expressions.  Users should understand
that they must provide the additional constraints necessary to assure
unambiguous data representation, if they are planning to create
compositional expressions using the CD datatype.  Otherwise, they risk
the inability to retrieve a complete set of all records corresponding
to any given query.
      </mif:p>
                     <mif:p>
Another common example is the U.S. Centers for Medicare and Medicaid
Services (CMS) (previously known as the Health Care Financing
Administration, HCFA) procedure codes. CMS procedure codes (HCPCS) are
based on CPT-4 and add additional qualifiers to it. For example, the
patient with above finding (plus peripheral arterial disease, diabetes
mellitus, and a chronic skin lesion at the left great toe) may have an
amputation of that toe. The CPT-4 concept is "Amputation, toe
metatarsophalangeal joint" (28820) and a HCPCS qualifier needs to be
added to indicate "left foot, great toe" (TA). Thus we code:
      </mif:p>
                     <mif:p>
In this example, the code system of the qualifier (HCPCS) is different
than the code system of the primary code (CPT-4.) It is only because
there are well-defined rules that define how these codes can be
combined, that the qualifier may be used. Note also, that the role
name is optional, and for HCPCS codes there are no distinguished role
names.
      </mif:p>
                     <mif:p>
The order of qualifiers is preserved, particularly for the case where
the coding system allows post-coordination but defines no role
names. (e.g., some ICD-9CM codes, or the old SNOMED "multiaxial"
coding.)
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:staticExample itsName="XML">
                  <mif:data>
                     <example noxmlspace="preserve">
                        <observation>
  ...
  <value code="128045006" codeSystem="&amp;SNOMED-CT;" displayName="cellulitis (disorder)">
                              <qualifier code="56459004" displayName="foot structure">
                                 <name code="363698007" displayName="finding site"/>
                              </qualifier>
                           </value>
  ...
</observation>
						               </example>
                  </mif:data>
               </mif:staticExample>
               <mif:staticExample itsName="XML">
                  <mif:data>
                     <example noxmlspace="preserve">
                        <procedure>
  ...
  <cd code="28820" codeSystem="&amp;CP4;"
                               displayName="Amputation, toe metatarsophalangeal joint">
                              <qualifier code="TA" codeSystem="&amp;HCP;" displayName="left foot, great toe"/>
                           </cd>
  ...
</procedure>
						               </example>
                  </mif:data>
               </mif:staticExample>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="LIST">
            <mif:argumentDatatype name="CR"/>
         </mif:type>
      </mif:property>
      <mif:property name="equal" sortKey="09" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
The main use of concept descriptors is for the purpose of indexing,
querying and decision-making based on a coded value. A semantically
unambiguous specification of coded values therefore requires a clear
definition of what equality of concept descriptor values means and how
<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="CD"/>
                        </mif:object> values should be compared. (For more details on
comparing pre- and post-coordinated expressions, see Dolin RH,
Spackman KA, Markwell D. Selective Retrieval of Pre- and
Post-coordinated SNOMED Concepts. Fall AMIA 2002; 210-14, or the July
2003 SNOMED CT Implementation Guide.)
    </mif:p>
                     <mif:p>
The equality of two concept descriptor values is determined solely
based upon the code and coding system. The code system version is
excluded from the equality test.<mif:object name="footnote">
The code system versions do not count in the equality test since by
definition a code symbol must have the same meaning throughout all
versions of a code system. Between versions, codes may be retired but
not withdrawn or reused.
          </mif:object>
If qualifiers are present, the qualifiers are included in the equality
test. Translations are not included in the equality test.<mif:object name="footnote">
Translations are not included in the equality test of concept
descriptors for safety reasons. An alternative would have been to
consider two  values equal if any of their
translations are equal. However, some translations may be equal
because the coding system of that translation is very
coarse-grained. More sophisticated comparisons between concept
descriptors are application considerations that are not covered by
this specification.
          </mif:object>
Exceptional concept descriptor values are not equal even if they have
the same NULL-flavor or the same original text.<mif:object name="footnote">
NULL-values are exceptional values, not proper concepts. It would be unsafe to 
equate two values merely on the basis that both are exceptional (e.g., not 
codable or unknown.)  Likewise there is no guarantee that original text
represents a meaningful or unique description of the concept so that equality 
of that original text does not constitute concept equality. The reverse is 
also true: since there is more than one possible original text for a concept, 
the fact that original text differs does not constitute a difference of the 
concepts.
          </mif:object>
						               </mif:p>
                     <mif:p>
Some code systems define certain style options to their code
values. For example, the U.S. National Drug Code (NDC) has a dash and
a non-dash form. An example for the dash form may be 1234-5678-90 when
the non-dash form is 01234567890. Another example for this problem is
when certain ISO or ANSI code tables define optional alphanumeric and
numeric forms of two or three character lengths all in one standard.
      </mif:p>
                     <mif:p>
In the case where code systems provide for multiple representations,
HL7 shall make a ruling about which is the preferred form. HL7 shall
document that ruling where that respective external coding system is
recognized. HL7 shall decide upon the preferred form based on criteria
of practicality and common use. In absence of clear criteria of
practicality and common use, the safest, most extensible, and least
stylized (the least decorated) form shall be given
preference.<mif:object name="footnote">
This ruling at design-time is necessary to prevent HL7 interfaces from
being burdened by code literal style conversions at runtime. This is
notwithstanding the fact that some applications may require mapping
from one form into another if that application has settled with the
representation option that was not chosen by HL7.
          </mif:object>
						               </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ANY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="implies" sortKey="10" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Implies"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
Specifies whether this concept descriptor is a specialization of
the operand concept descriptor.
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
Naturally, concepts can be narrowed and widened to include or exclude
other concepts. Many coding systems have an explicit notion of concept
specialization and generalization. The HL7 vocabulary principles also
provide for concept specialization for HL7 defined value sets. The
<mif:b>implies</mif:b>-property is a predicate that compares whether one
concept is a specialization of another concept, and therefore implies
that other concept.
      </mif:p>
                     <mif:p>
When writing predicates (e.g., conditional statements) that compare
two codes, one should usually test for implication not equality of
codes.
      </mif:p>
                     <mif:p>
For example, in <mif:object name="conceptDomainRef">
                           <mif:param name="name" value="TelecommunicationAddressUse"/>
                        </mif:object> the
"telecommunication use" concepts: work (W), home (H), primary home
(HP), and vacation home (HV) are defined, where both HP and HV imply
H. When selecting any home phone number, one should test whether the
given use-code <mif:b>c</mif:b> 
              <mif:b>implies</mif:b> H. Testing for
<mif:b>c</mif:b> 
              <mif:b>equal</mif:b> H would only find unspecified home
phone numbers, but not the primary home phone number.
      </mif:p>
                     <mif:p>
Operationally, implication can be evaluated in one of two ways. The
code system literals may be designed such that one single hierarchy is
reflected in the code literal itself (e.g., ICD-9.) Apart from such
special cases, however, a terminological knowledge base and an
appropriate subsumption algorithm will be required to evaluate
implication statements. For post-coordinated coding systems, designing
such a subsumption algorithm is a non-trivial task.<mif:object name="footnote">
This is one reason why the CD.qualifiers for post-coordination are to
be used sparingly and with caution. An additional problem of
post-coordinated coding is that a general rule for equality may not
exist at all.
          </mif:object>
						               </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="CD"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="CR" title="ConceptRole" datatypeKind="Definition" visibility="protected">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ANY"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
A concept qualifier code with optionally named role.  Both qualifier
role and value codes must be defined by the coding system of the CD containing
the concept qualifier.  For example, if SNOMED RT defines a concept "leg", a
role relation "has-laterality", and another concept "left", the concept role
relation allows to add the qualifier "has-laterality: left" to a
primary code "leg" to construct the meaning "left leg".
    </mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
The use of qualifiers is strictly governed by the code system
used. The <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="CD"/>
                     </mif:object> data type does not permit using code
qualifiers with code systems that do not provide for qualifiers
(e.g. pre-coordinated systems, such as LOINC, ICD-10 PCS.)
    </mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
protected type ConceptRole alias CR specializes ANY {
  CV  name;
  CD  value;
  BN  inverted;
};
    </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="name" sortKey="01" propertyKind="variableProperty" visibility="public"
                    defaultValue="NullFlavor.NI"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1">
         <mif:businessName name="Name"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
Specifies the manner in which the concept role value contributes to
the meaning of a code phrase.  For example, if SNOMED RT defines a
concept "leg", a role relation "has-laterality", and another concept
"left", the concept role relation allows to add the qualifier
"has-laterality: left" to a primary code "leg" to construct the
meaning "left leg".  In this example "has-laterality" is the CR.name.
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
If the coding system of the CD containing the CR allows postcoordination
but no role names (e.g. SNOMED) the name attribute can be NULL.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="CV"/>
      </mif:property>
      <mif:property name="value" sortKey="02" propertyKind="variableProperty" visibility="public"
                    defaultValue="NullFlavor.NI"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Value"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The concept that modifies the primary code of a code phrase through
the role relation.  For example, if SNOMED RT defines a concept "leg",
a role relation "has-laterality", and another concept "left", the
concept role relation allows adding the qualifier "has-laterality:
left" to a primary code "leg" to construct the meaning "left leg".  In
this example "left" is the CR.value.
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
This property is of type concept descriptor and thus can in turn have
qualifiers. This allows qualifiers to nest. Qualifiers can only be
used as far as the underlying code system defines them. It is not
allowed to use any kind of qualifiers for code systems that do not
explicitly allow and regulate such use of qualifiers.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="CD"/>
      </mif:property>
      <mif:property name="inverted" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="false"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Inversion Indicator"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
Indicates if the sense of the role name is inverted.  This can be used
in cases where the underlying code system defines inversion but does
not provide reciprocal pairs of role names. By default, inverted is
false.
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
For example, a code system may define the role relation "causes"
besides the concepts "Streptococcus pneumoniae" and "Pneumonia". If
that code system allows its roles to be inverted, one can construct
the post-coordinated concept "Pneumococcus pneumonia" through
"Pneumonia - causes, inverted - Streptococcus pneumoniae."
      </mif:p>
                     <mif:p>
Roles may only be inverted if the underlying coding system allows such
inversion. Notably, if a coding system defines roles in inverse pairs
or intentionally does not define certain inversions, the appropriate
role code (e.g. "caused-by") must be used rather than inversion. It
must be known whether the inverted property is <mif:b>true</mif:b> or
<mif:b>false</mif:b>, since if it is NULL, the role cannot be interpreted.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="BN"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="CS" title="CodedSimpleValue" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="CV"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
XCoded data in its simplest form, where only the code is not predetermined.
The code system and code system version are fixed by the context in which
the CS value occurs. CS is used for coded attributes that have a single
HL7-defined value set.
    </mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
					                <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="CS"/>
                     </mif:object> can only be used in either of the following
          cases:
    </mif:p>
                  <mif:ol>
                     <mif:li>
                        <mif:p>
for a coded attribute which has a single HL7-defined code system, and
where code additions to that value set require formal HL7 action (such
as harmonization.) Such coded attributes must be assigned the
<mif:object name="datatypeRef">
                              <mif:param name="datatypeName" value="CS"/>
                           </mif:object> restriction.
        </mif:p>
                     </mif:li>
                     <mif:li>
                        <mif:p>
for a property in this specification that is assigned to a single code
system defined either in this specification or defined outside HL7 by a body
that has authority over the concept and the maintenance of that code system.
        </mif:p>
                     </mif:li>
                  </mif:ol>
                  <mif:p>
For example, since the <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="ED"/>
                     </mif:object> type subscribes to the MIME
design, it trusts IETF to manage the media type. This includes that this
specification subscribes to the extension mechanism built into the MIME media
type code (e.g., "application/x-myapp").
    </mif:p>
                  <mif:p>
For <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="CS"/>
                     </mif:object> values, the designation of the domain qualifier
will always be CNE (<mif:b>coded, non-extensible</mif:b>) and the
context will determine which HL7 values to use. <mif:object name="footnote">
This is not withstanding the fact that an external referenced domain,
such as the IETF MIME media type may include an extension
mechanism. These extended MIME type codes would not be considered
"extensions" in the sense of violating the CNE provision. The CNE
provision is only violated if an attempt is made in using a different
code system (by means of the CD.codeSystem property), which is not
possible with the  data type.
        </mif:object>
				              </mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type CodedSimpleValue alias CS specializes CV {
  literal   ST;
};
    </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="code" sortKey="01" propertyKind="variableProperty" visibility="public"
                    defaultValue="NullFlavor.NI"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Code"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="codeSystem" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Code System"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
Every non-NULL <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> value has a defined code system.  The
ITS representation of the <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> needs not explicitly mention
the code system, because the context mandates one and only one code
system to be used. Specifying the code system explicitly would be
redundant. However, the code system property assumes that
context-specific default value and is not NULL.
      </mif:p>
                     <mif:p>
An exceptional <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="CS"/>
                        </mif:object> of NULL-flavor "other" indicates that a
concept could not be coded in the coding system specified. In these cases,
the code must be Null.
     </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="UID"/>
      </mif:property>
      <mif:property name="codeSystemName" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="NullFlavor.NI"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Code System Name"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="codeSystemVersion" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="NullFlavor.NA"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Code System Version"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="displayName" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="NullFlavor.NA"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Display Name"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="originalText" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="NullFlavor.NA"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Original Text"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="ED"/>
      </mif:property>
      <mif:property name="translation" sortKey="07" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="NullFlavor.NA"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="NP">
         <mif:businessName name="Translation"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="SET">
            <mif:argumentDatatype name="CD"/>
         </mif:type>
      </mif:property>
      <mif:property name="qualifier" sortKey="08" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="NullFlavor.NA"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="NP">
         <mif:businessName name="Qualifier"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="LIST">
            <mif:argumentDatatype name="CR"/>
         </mif:type>
      </mif:property>
      <mif:property name="literal" sortKey="09" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
The string literal form of CS is primarily defined for the purposes of
this specification. The literal form is a representation of the code
for the codeSystem for the context of the CS in string format. You
cannot determine the codeSystem or version from the literal itself,
so the literal only has use where the context is known
      </mif:p>
                  </mif:text>
               </mif:designComments>
               <mif:otherAnnotation type="LiteralFormat">
                  <mif:data>
CS.literal ST {
  ST : /[a-zA-Z0-9_]+/  { $.equal($1); };
};
      </mif:data>
               </mif:otherAnnotation>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="ST"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="CV" title="CodedValue" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="CE"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
Coded data, specifying only a code, code system, and optionally
display name and original text. Used only as the data type for other
data types' properties.
    </mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
This type is used when any reasonable use case will require only a
single code value to be sent. Thus, it should not be used in
circumstances where multiple alternative codes for a given value are
desired. This type may be used with both the CNE (<mif:b>coded,
non-extensible</mif:b>) and the CWE (<mif:b>coded, with
extensibility</mif:b>) domain qualifiers.
    </mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
protected type CodedValue alias CV specializes CE;
    </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="code" sortKey="01" propertyKind="variableProperty" visibility="public"
                    defaultValue="NullFlavor.NI"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Code"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="codeSystem" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Code System"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="UID"/>
      </mif:property>
      <mif:property name="codeSystemName" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="NullFlavor.NI"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Code System Name"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="codeSystemVersion" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="NullFlavor.NI"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1">
         <mif:businessName name="Code System Version"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="displayName" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="NullFlavor.NI"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Display Name"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="originalText" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="NullFlavor.NI"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Original Text"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="ED"/>
      </mif:property>
      <mif:property name="translation" sortKey="07" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="NullFlavor.NA"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="NP">
         <mif:businessName name="Translation"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="SET">
            <mif:argumentDatatype name="CD"/>
         </mif:type>
      </mif:property>
      <mif:property name="qualifier" sortKey="08" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="NullFlavor.NA"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="NP">
         <mif:businessName name="Qualifier"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="LIST">
            <mif:argumentDatatype name="CR"/>
         </mif:type>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="CO" title="CodedOrdinal" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="CV"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
Coded data, where the domain from which the codeset comes is ordered. The
Coded Ordinal data type adds semantics related to ordering so that models
that make use of such domains may introduce model elements that involve
statements about the order of the terms in a domain.
    </mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
The relative order of this type's values need not be independently
obvious in their literal representation. It is expected that an
application will look up the ordering of these values from some
table.
    </mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type CodedOrdinal alias CO specializes CV {
  BL    lessOrEqual(CO o);
  BL    lessThan(CO o);
  BL    greaterThan(CO o);
  BL    greaterOrEqual(CO o);
};
    </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="lessOrEqual" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Less-or-equal"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The ordering relation is based on lessOrEqual which is taken as
primitive in this specification.
	 </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>All other order relations can be derived from this one.
Taking lessOrEqual as primitive accomodates partial orderings.</mif:p>
                     <mif:p>Order relationships typically hold only within a single coding 
system.</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="o" sortKey="1">
            <mif:type name="CO"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="lessThan" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Less-than"/>
         <mif:parameter name="o" sortKey="1">
            <mif:type name="CO"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="greaterThan" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Greater-than"/>
         <mif:parameter name="o" sortKey="1">
            <mif:type name="CO"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="greaterOrEqual" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Greater-or-equal"/>
         <mif:parameter name="o" sortKey="1">
            <mif:type name="CO"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="CE" title="CodedWithEquivalents" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="CD"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
Coded data that consists of a coded value (CV) and, optionally, coded
value(s) from other coding systems that identify the same
concept. Used when alternative codes may exist.
    </mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
The <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> type is used when the use case indicates that alternative
codes may exist and where it is useful to communicate these. The
<mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> type provides for a primary code value, plus a set of
alternative or equivalent representations.
    </mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type CodedWithEquivalents alias CE specializes CD;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="code" sortKey="01" propertyKind="variableProperty" visibility="public"
                    defaultValue="NullFlavor.NI"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Code"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="codeSystem" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Code System"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="UID"/>
      </mif:property>
      <mif:property name="codeSystemName" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="NullFlavor.NI"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Code System Name"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="codeSystemVersion" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="NullFlavor.NI"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1">
         <mif:businessName name="Code System Version"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="displayName" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="NullFlavor.NI"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Display Name"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="originalText" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="NullFlavor.NI"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Original Text"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="ED"/>
      </mif:property>
      <mif:property name="translation" sortKey="07" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="NullFlavor.NI"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*">
         <mif:businessName name="Translation"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="SET">
            <mif:argumentDatatype name="CD"/>
         </mif:type>
      </mif:property>
      <mif:property name="qualifier" sortKey="08" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="NullFlavor.NA"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="NP">
         <mif:businessName name="Qualifier"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="LIST">
            <mif:argumentDatatype name="CR"/>
         </mif:type>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="SC" title="CharacterStringWithCode" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ST"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
A character string that optionally may have a code attached. The text
must always be present if a code is present.  The code is often a
local code.
    </mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
This data type is used in cases where coding is exceptional (e.g.,
user text messages are essentially text messages, and a printable
message is the important content. Yet, sometimes messages come from a
catalog of canned messages, which the SC allows to reference.  
    </mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type CharacterStringWithCode alias SC specializes ST {
  CE code;
};
    </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text>
Any non-null SC value MAY have a code, however, a code MUST NOT be
given without the text.
      </mif:text>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(SC x) where x.nonNull {
  x.code.nonNull.implies(x.notEmpty);
};
      </mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="code" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1">
         <mif:businessName name="Code"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A code representing the string data. For example, the string data may
be a user-message out of a message-catalog where the code represents
the identifier of the message in the message catalog.
     </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="CE"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="UID" title="UniqueIdentifierString" datatypeKind="Definition"
                 visibility="protected">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ST"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
A unique identifier string is a character string which identifies an
object in a globally unique and timeless manner. The allowable formats
and values and procedures of this data type are strictly controlled by
HL7. At this time, user-assigned identifiers may be certain character
representations of ISO Object Identifiers (OID) and DCE Universally
Unique Identifiers (UUID). HL7 also reserves the right to assign other
forms of UIDs, such as mnemonic identifiers for code systems.
    </mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
The sole purpose of the UID is to be a globally and timelessly unique
identifier. The form of the UID, whether it is an OID, an UUID or any
other form is entirely irrelevant. As far as HL7 is concerned, the
only thing one can do with a UID is denote to the object for which it
stands. Comparison of UIDs is literal, i.e. if two UIDs are literally
identical, they are assumed to denote to the same object. If two UIDs
are not literally identical they <mif:b>may</mif:b> not denote to the
same object.
    </mif:p>
                  <mif:p>
No difference in semantics is recognized between the different
allowed forms of the UID. The different forms are not distinguished
by a component within or aside from the identifier string itself.
    </mif:p>
                  <mif:p>
Even though this specification recognizes no semantic difference
between the different forms of the unique identifier forms, there are
differences of how these identifiers are built and managed, which is
the sole reason to define subtypes to the UID for each of the
variants.
    </mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
protected type UniqueIdentifierString alias UID specializes ST;
    </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="OID" title="ObjectIdentifier" datatypeKind="Definition"
                 visibility="protected">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="UID"/>
      </mif:derivedFrom>
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="LIST">
            <mif:argumentDatatype name="INT"/>
         </mif:targetDatatype>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
A globally unique string representing an ISO Object Identifier
(OID) in a form that consists only of numbers and dots (e.g.,
"2.16.840.1.113883.3.1"). According to ISO, OIDs are paths in a tree
structure, with the left-most number representing the root and the
right-most number representing a leaf.
    </mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
Each branch under the root corresponds to an assigning authority. Each
of these assigning authorities may, in turn, designate its own set of
assigning authorities that work under its auspices, and so on down the
line. Eventually, one of these authorities assigns a unique (to it as
an assigning authority) number that corresponds to a leaf node on the
tree. The leaf may represent an assigning authority (in which case the
root OID identifies the authority), or an instance of an object. An
assigning authority owns a namespace, consisting of its sub-tree.
    </mif:p>
                  <mif:p>
OIDs are the preferred scheme for unique identifiers. OIDs should
always be used except if one of the inclusion criteria for other
schemes apply.
    </mif:p>
                  <mif:p>
ISO/IEC 8824:1990(E) clause 28 defines the Object Identifier as
    </mif:p>
                  <mif:blockquote>
                     <mif:p>
						                  <mif:b>28.9</mif:b> The semantics of an
object identifier value are defined by reference to an <mif:b>
object identifier tree</mif:b>. An object identifier tree is a tree whose root
corresponds to [the ISO/IEC 8824 standard] and whose vertices [i.e. nodes]
correspond to administrative authorities responsible for allocating arcs [i.e.
branches] from that vertex. Each arc from that tree is labeled by an object
identifier component, which is [an integer number]. Each information object to
be identified is allocated precisely one vertex (normally a leaf) and no other
information object (of the same or a different type) is allocated to
that same vertex. Thus an information object is uniquely and
unambiguously identified by the sequence of [integer numbers] (object
identifier components) labeling the arcs in a path from the root to
the vertex allocated to the information object.
      </mif:p>
                     <mif:p>
						                  <mif:b>28.10</mif:b> An object identifier value is
semantically an ordered list of object identifier component
values. Starting with the root of the object identifier tree, each
object identifier component value identifies an arc in the object
identifier tree. The last object identifier component value identifies
an arc leading to a vertex to which an information object has been
assigned. It is this information object, which is identified by the
object identifier value. [...]
      </mif:p>
                  </mif:blockquote>
                  <mif:p>
According to ISO/IEC 8824 an object identifier is a sequence of object
identifier component values, which are integer numbers. These
component values are ordered such that the root of the object
identifier tree is the head of the list followed by all the arcs down
to the leaf representing the information object identified by the
OID. The fact that OID specializes <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="LIST"/>
                     </mif:object>&lt;
<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="INT"/>
                     </mif:object>&gt; represents this path of object identifier component
values from the root to the leaf.
    </mif:p>
                  <mif:p>
The <mif:b>leaf</mif:b> and "<mif:b>butLeaf</mif:b>"
properties take the opposite view. The
leaf is the last object identifier component value in the list, and
the "butLeaf" property is all of the OID <mif:b>but</mif:b> the
<mif:b>leaf</mif:b>. In a sense, the leaf is the identifier value and
all of the OID but the leaf refers to the namespace in which the leaf
is unique and meaningful.
    </mif:p>
                  <mif:p>
However, what part of the OID is considered <mif:b>value</mif:b>
and what is <mif:b>namespace</mif:b> may be viewed differently. In
general, any OID component sequence to the left can be considered the namespace
in which the rest of the sequence to the right is defined as a
meaningful and unique identifier value. The value-property with a
namespace OID as its argument represents this point of view.<mif:object name="footnote">
The value/namespace view on ISO object identifiers has important
semantic relevance. It represents the notion of identifier value
versus identifier assigning authority (= namespace), which is common
in healthcare information systems in general, and HL7 v2.x in
particular.
        </mif:object>
				              </mif:p>
                  <mif:div title="HL7-Assigned OIDs">section-OID.procedures
HL7 shall establish an OID registry and assign OIDs in its branch for
HL7 users and vendors upon their request. HL7 shall also assign OIDs
to public identifier-assigning authorities both U.S. nationally (e.g.,
the U.S. State driver license bureaus, U.S. Social Security
Administration, HIPAA Provider ID registry, etc.) and internationally
(e.g., other countries Social Security Administrations, Citizen ID
registries, etc.) The HL7 registered OIDs must be used for these
organizations, regardless whether these organizations have other OIDs
assigned from other sources.
      
When assigning OIDs to third parties or entities, HL7 shall
investigate whether an OID is already assigned for such entities
through other sources. It this is the case, HL7 shall record such OID
in a catalog, but HL7 shall not assign a duplicate OID in the HL7
branch. If possible, HL7 shall notify a third party when an OID is
being assigned for that party in the HL7 branch.
      
Though HL7 shall exercise diligence before assigning an OID in the HL7
branch to third parties, given the lack of a global OID registry
mechanism, one cannot make absolutely certain that there is no
preexisting OID assignment for such third-party entity. Also, a
duplicate assignment can happen in the future through another
source. If such cases of supplicate assignment become known to HL7,
HL7 shall make efforts to resolve this situation. For continued
interoperability in the meantime, the HL7 assigned OID shall be the
preferred OID used.
      
While most owners of an OID will "design" their namespace sub-tree in
some meaningful way, there is no way to generally infer any meaning on
the parts of an OID. HL7 does not standardize or require any namespace
sub-structure. An OID owner, or anyone having knowledge about the
logical structure of part of an OID, may still use that knowledge to
infer information about the associated object; however, the techniques
cannot be generalized.
      
						Example for a tree of ISO object identifiers. HL7's OID
        is 2.16.840.1.113883.
						
					
						An HL7 interface must not rely on any
knowledge about the substructure of an OID for which it cannot control the
assignment policies.
					</mif:div>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
protected type ObjectIdentifier alias OID specializes UID, LIST&lt;INT&gt; {
  INT   leaf;
  OID   butLeaf;
  OID   value(OID namespace);
  literal ST;
};
    </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="leaf" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Leaf"/>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="butLeaf" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="All-But-The-Leaf"/>
         <mif:type name="OID"/>
      </mif:property>
      <mif:property name="value" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Value"/>
         <mif:parameter name="namespace" sortKey="1">
            <mif:type name="OID"/>
         </mif:parameter>
         <mif:type name="OID"/>
      </mif:property>
      <mif:property name="literal" sortKey="04" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
The structured definition of the OID is provided mostly to be faithful
to the OID specification. Within HL7, OIDs are used as UID strings
only, i.e., the literal string value is the only thing that is
communicated and is the only thing that a reciever should have to
consider when working with UIDs in the scope of the HL7 specification.
      </mif:p>
                     <mif:p>
For compatibility with the DICOM standard, the literal form of the OID
should not exceed 64 characters. (see DICOM part 5, section 9).
      </mif:p>
                  </mif:text>
               </mif:designComments>
               <mif:otherAnnotation type="LiteralFormat">
                  <mif:data>
OID.literal ST {
    OID : INT "." OID { $.head.equal($1);
      $.tail.equal($3); }
        | INT   { $.head.equal($1);
      $.tail.isEmpty; }
};
      </mif:data>
               </mif:otherAnnotation>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="ST"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="UUID" title="UniversalUniqueIdentifier" datatypeKind="Definition"
                 visibility="protected">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="UID"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
A globally unique string representing a DCE Universal Unique
Identifier (UUID) in the common UUID format that consists of 5
hyphen-separated groups of hexadecimal digits having 8, 4, 4, 4,
and 12 places respectively.
    </mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
Both the UUID and its string representation are defined by the Open
Group, CDE 1.1 Remote Procedure Call specification, Appendix A.
    </mif:p>
                  <mif:p>
UUIDs are assigned based on Ethernet MAC addresses, the point in time
of creation and some random component. This mix is believed to
generate sufficiently unique identifiers without any organizational
policy for identifier assignment (in fact this piggy-backs on the
organization of MAC address assignment.)
    </mif:p>
                  <mif:p>
UUIDs are <mif:b>not</mif:b> the preferred identifier
scheme for use as HL7 UIDs. UUIDs may be used when identifiers are
issued to objects representing individuals (e.g., entity instance
identifiers, act event identifiers, etc.) For objects describing
classes of things or events (e.g., catalog items), OIDs are the
preferred identifier scheme.
    </mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
protected type UniversalUniqueIdentifier alias UUID specializes UID {
  INT timeLow;
  INT timeMid;
  INT timeHighAndVersion;
  INT clockSequence;
  INT node;
   literal  ST;
};
    </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="timeLow" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Low Time"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The low field of the timestamp.
					</mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="timeMid" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Mid Time"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The middle field of the timestamp.
					</mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="timeHighAndVersion" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="High Time and Version"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The high field of the timestamp multiplexed with the version number.
					</mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="clockSequence" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Clock Sequence"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The high field of the clock sequence multiplexed with the variant and the low field of the clock sequence.
					</mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="node" sortKey="05" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Node"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The spatially unique node identifier (usually the host address). 
					</mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="literal" sortKey="06" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
The structured definition of the UUID is provided mostly to be
faithful to the UUID specification. Within HL7, UUIDs are used as UID
strings only, i.e., the literal string value is the only thing that is
communicated and is the only thing that a reciever should have to
consider when working with UIDs in the scope of the HL7 specification.
      </mif:p>
                     <mif:p>
The literal form for the UUID is defined according to the original
specification of the UUID. However, because the HL7 UIDs are case
sensitive, for use with HL7, the hexadecimal digits A-F in UUIDs
must be converted to upper case.
      </mif:p>
                  </mif:text>
               </mif:designComments>
               <mif:otherAnnotation type="LiteralFormat">
                  <mif:data>
UUID.literal ST {
  UUID : hex8 "-" hex4 "-" hex4 "-" hex4 "-" hex12 {
          $.timeLow.equal($1);
          $.timeMid.equal($3);
          $.timeHighAndVersion.equal($5);
          $.clockSequence.equal($7);
          $.node.equal($9);
  }

  INT hex4 :  hexDigit hexDigit hexDigit hexDigit {
          $.equal($1.times(16).plus($2)
	             .times(16).plus($3)
		     .times(16).plus($4);
  }

  INT hex8 :  hexDigit hexDigit hexDigit hexDigit
              hexDigit hexDigit hexDigit hexDigit {
          $.equal($1.times(16).plus($2)
	             .times(16).plus($3)
		     .times(16).plus($4)
	             .times(16).plus($5)
		     .times(16).plus($6)
	             .times(16).plus($7)
		     .times(16).plus($8);
  }

  INT hex12 : hexDigit hexDigit hexDigit hexDigit
              hexDigit hexDigit hexDigit hexDigit
              hexDigit hexDigit hexDigit hexDigit {
          $.equal($1.times(16).plus($2)
	             .times(16).plus($3)
		     .times(16).plus($4)
	             .times(16).plus($5)
		     .times(16).plus($6)
	             .times(16).plus($7)
		     .times(16).plus($8)
		     .times(16).plus($9)
	             .times(16).plus($10)
		     .times(16).plus($11)
		     .times(16).plus($12);
  }

  INT hexDigit
  : "0" { $.equal(0); }
  | "1" { $.equal(1); }
  | "2" { $.equal(2); }
  | "3" { $.equal(3); }
  | "4" { $.equal(4); }
  | "5" { $.equal(5); }
  | "6" { $.equal(6); }
  | "7" { $.equal(7); }
  | "8" { $.equal(8); }
  | "9" { $.equal(9); }
  | "A" { $.equal(10); }
  | "B" { $.equal(11); }
  | "C" { $.equal(12); }
  | "D" { $.equal(13); }
  | "E" { $.equal(14); }
  | "F" { $.equal(15); }
};
      </mif:data>
               </mif:otherAnnotation>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="ST"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="RUID" title="HL7ReservedIdentifierScheme" datatypeKind="Definition"
                 visibility="protected">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="UID"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
A globally unique string defined exclusively by HL7. Identifiers in
this scheme are only defined by balloted HL7 specifications. Local
communities or systems must never use such reserved identifiers based
on bilateral negotiations.
    </mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
HL7 reserved identifiers are strings that consist only of (US-ASCII)
letters, digits and hyphens, where the first character must be a
letter. HL7 may assign these reserved identifiers as mnemonic
identifiers for major concepts of interest to HL7.
    </mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
protected type HL7ReservedIdentifierScheme alias RUID specializes UID;</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="II" title="InstanceIdentifier" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ANY"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
An identifier that uniquely identifies a thing or object. Examples
are object identifier for HL7 RIM objects, medical record number,
order id, service catalog item id, Vehicle Identification Number
(VIN), etc. Instance identifiers are defined based on ISO object
identifiers.
    </mif:text>
            </mif:definition>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type InstanceIdentifier alias II specializes ANY {
  UID     root;
  ST      extension;
  ST      assigningAuthorityName;
  BL      displayable;
};
    </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="root" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Root"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A unique identifier that guarantees the global uniqueness of the
instance identifier. The root alone may be the entire instance
identifier.
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
In the presence of a non-null extension, the root is commonly
interpreted as the "assigning authority", that is, it is supposed that
the root somehow refers to an organization that assigns identifiers
sent in the extension. However, the root does not have to be an
organizational UID, it can also be a UID specifically registered for
an identifier scheme.<mif:object name="footnote">
DICOM objects are identified by UID only. For the purpose of DICOM/HL7
integration, it would be awkward if HL7 required the extension to be
mandatory and to consider the UID only as an assigning
authority. Since UID values are simpler and do not contain the risks
of containing meaningless decoration, we do encourage systems to use
simple UID identifiers as external references to their objects.
          </mif:object>
						               </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="UID"/>
      </mif:property>
      <mif:property name="extension" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="NullFlavor.NI"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1">
         <mif:businessName name="Extension"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A character string as a unique identifier within the scope of the
identifier root.
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
The extension is a character string that is unique in the namespace
designated by the root. If a non-NULL extension is exists, the root
specifies a namespace (sometimes called "assigning authority" or
"identifier type".)  The extension property may be NULL in which case
the root OID is the complete unique identifier.
      </mif:p>
                     <mif:p>
The root and extension scheme effectively means that the concatenation
of root and extension must be a globally unique identifier for the
item that this II value identifies.
      </mif:p>
                     <mif:p>
It is recommended that systems use the OID scheme for external
identifiers of their communicated objects. The extension property is
mainly provided to accommodate legacy alphanumeric identifier schemes.
      </mif:p>
                     <mif:p>
Some identifier schemes define certain style options to their code
values. For example, the U.S. Social Security Number (SSN) is normally
written with dashes that group the digits into a pattern
"123-12-1234". However, the dashes are not meaningful and a SSN can
just as well be represented as "123121234" without the dashes.
      </mif:p>
                     <mif:p>
In the case where identifier schemes provide for multiple
representations, HL7 shall make a ruling about which is the preferred
form. HL7 shall document that ruling where that respective external
identifier scheme is recognized. HL7 shall decide upon the preferred
form based on criteria of practicality and common use. In absence of
clear criteria of practicality and common use, the safest, most
extensible, and least stylized (the least decorated) form shall be
given preference.<mif:object name="footnote">
This ruling at design-time is necessary to prevent HL7 interfaces from
being burdened by identifier literal style conversions at
runtime. This is notwithstanding the fact that some applications may
require mapping from one form into another if that application has
settled with the representation option that was not chosen by HL7.
          
From practical experience it is recommended that II.extensions as
an alphanumeric identifier not contain leading zero digits (if any
zeroes at all), for these are often erroneously stripped. "000123"
and "123" would be different extension values, but this is prone
to be misunderstood, leading to false non-matches and duplicate
record entries. However applications should maintain any leading zero
digits encountered in II extensions. Leading zero digits are
prohibited in OID's, but may occur in UUID's, where they must be
maintained.
	  
There is no separate check digit property. Check digits are used
for human purpose and work best if kept completely transparent.
II.extensions MAY contain check digits anywhere, and the
particular check digit scheme (if any) would be implied by the
II.root. However, a separate check digit property is intentionally
not recognized by this specification.
	  </mif:object>
						               </mif:p>
                     <mif:p>
HL7 may also decide to map common external identifiers to the value
portion of the II.root OID. For example, the U.S. SSN could be
represented as 2.16.840.1.113883.4.1.123121234. The criteria of
practicality and common use will guide HL7's decision on each
individual case.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="assigningAuthorityName" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Assigning Authority Name"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A human readable name or mnemonic for the assigning authority. The Assigning
Authority Name has no computational value. The purpose of a Assigning Authority
Name is to assist an unaided human interpreter of an II value to interpret
the authority. Note: no automated processing must depend on the assigning
authority name to be present in any form.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="displayable" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Displayable"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
Specifies if the identifier is intended for human
display and data entry (displayable = true) as opposed to pure machine
interoperation (displayable = false).
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="scope" sortKey="05" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Scope"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						Specifies the scope in which the identifier applies to the object with which it is associated.
					</mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="IdentifierScope"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="reliability" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Reliability"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						Specifies the reliability with which the identifier is known. This attribute MAY be used to assist with identifier matching algorithms.
					</mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="IdentifierReliability"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="equal" sortKey="07" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
Two instance identifiers are equal if and only if their root and extension
properties are equal.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ANY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="URL" title="UniversalResourceLocator" datatypeKind="Definition"
                 visibility="protected">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ANY"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
A telecommunications address specified according to Internet standard
RFC 2396 [<mif:a href="http://www.ietf.org/rfc/rfc2396.txt"/>]. The
URI specifies the protocol and the contact point defined by that
protocol for the resource.  Notable uses of the telecommunication
address data type are for telephone and telefax numbers, e-mail
addresses, Hypertext references, FTP references, etc.
    </mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
The Internet standard RFC 2396 [<mif:a href="http://www.ietf.org/rfc/rfc2396.txt"/>] defines a URI as
follows:
    </mif:p>
                  <mif:blockquote>
                     <mif:p>
Just as there are many different methods of access to resources, there
are several schemes for describing the location of such resources.
The generic syntax for <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="URL"/>
                        </mif:object>s provides a framework for
new schemes to be established using protocols other than those defined
in this document.
      </mif:p>
                     <mif:p>
URLs are used to "locate" resources, by providing an abstract
identification of the resource location. Having located a resource, a
system may perform a variety of operations on the resource, as might
be characterized by such words as "access", "update", "replace", "find
attributes". In general, only the "access" method needs to be
specified for any <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="URL"/>
                        </mif:object> scheme.
      </mif:p>
                     <mif:p>
      </mif:p>
                  </mif:blockquote>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
protected type UniversalResourceLocator
                 alias URL specializes ANY {
  CS  scheme;
  ST  address;
  literal ST;
};
    </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="scheme" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Scheme"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
Identifies the protocol used to interpret the address string and 
to access the resource so addressed.
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
Some URL schemes are registered by the <mif:b>Internet Assigned Numbers
Authority</mif:b> (IANA) [http://www.iana.org], however IANA only
registers URL schemes that are defined in Internet RFC documents. In
fact there are a number of URL schemes defined outside RFC documents,
part of which are registered with the World Wide Web Consortium
(W3C).<mif:object name="footnote">
The data type of the  is still  and for
HL7 purposes, the  is a CNE domain. This appears to be
at odds with the fact that there is no one official list of URL
schemes, and so many URL schemes in use may be defined locally.
However, we cannot allow extension of the  scheme
using the HL7 mechanism of local alternative code systems, which is
why technically the  is a  data type.
          </mif:object>
					                </mif:p>
                     <mif:p>
Similar to the <mif:object name="propertyRef">
                           <mif:param name="datatypeName" value="ED"/>
                           <mif:param name="propertyName" value="mediaType"/>
                        </mif:object>, HL7 makes
suggestions about <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> values classifying them as
<mif:b>required</mif:b>, <mif:b>recommended</mif:b>, <mif:b>other</mif:b>,
and <mif:b>deprecated</mif:b>. Any scheme not mentioned has status
<mif:b>other</mif:b>.
      </mif:p>
                     <mif:p>
Note that this specification explicitly limits itself to <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="URL"/>
                        </mif:object>s.
Universal Resource Names (URN) are not covered by this specification. URNs are a
kind of identifier scheme for other than accessible resources. This specification,
however, is only concerned with accessible resources, which belong into the
<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="URL"/>
                        </mif:object> category.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="CS"/>
      </mif:property>
      <mif:property name="address" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Address"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The address is a character string whose format is entirely defined by
the <mif:object name="propertyRef">
                        <mif:param name="datatypeName" value="URL"/>
                        <mif:param name="propertyName" value="scheme"/>
                     </mif:object>.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="literal" sortKey="03" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
While conceptually <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> has the properties scheme and address,
the common appearance of a URL is as a string literal formed according
to the Internet standard. The general syntax of the URL literal is:
      </mif:p>
                     <mif:p>
Note that there is no special data type for telephone numbers,
telephone numbers are <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="TEL"/>
                        </mif:object> and are specified as <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>.
      </mif:p>
                     <mif:p>
The telephone number URL is defined in Internet RFC 2806 [<mif:a href="http://www.ietf.org/rfc/rfc2806.txt"/>]. Its definition is
summarized in this subsection. This summary does not override or
change any of the Internet specification's rulings.
      </mif:p>
                     <mif:p>
The voice telephone URLs begin with "tel:" and fax URLs begin with
"fax:"
      </mif:p>
                     <mif:p>
The <mif:object name="propertyRef">
                           <mif:param name="datatypeName" value="URL"/>
                           <mif:param name="propertyName" value="address"/>
                        </mif:object> is the telephone number in
accordance with ITU-T E.123 <mif:b>Telephone Network and ISDN
Operation, Numbering, Routing and Mobile Service: Notation for
National and International Telephone Numbers (1993)</mif:b>. While HL7
does not add or withdraw from the URL specification, the preferred
subset of the <mif:object name="propertyRef">
                           <mif:param name="datatypeName" value="URL"/>
                           <mif:param name="propertyName" value="address"/>
                        </mif:object> address syntax is
given as follows:
      </mif:p>
                     <mif:p>
The global absolute telephone numbers starting with the "+" and
country code are preferred. Separator characters serve as decoration
but have no bearing on the meaning of the telephone number. For
example: "tel:+13176307960" and "tel:+1(317)630-7960" are both the
same telephone number; "fax:+49308101724" and "fax:+49(30)8101-724"
are both the same fax number.
      </mif:p>
                  </mif:text>
               </mif:designComments>
               <mif:otherAnnotation type="DTDL">
                  <mif:data>
URL.literal ST {
  URL : /[a-z0-9+.-]+/ ":" ST { $.scheme.equal($1);
                                $.address.equal($3); }
};
      </mif:data>
               </mif:otherAnnotation>
               <mif:otherAnnotation type="LiteralFormat">
                  <mif:data>
proctected type TelephoneURL specializes URL {
  literal ST {
    URL : /(tel)|(fax)/ ":" address   { $.scheme.equal($1);
                  $.address.equal($3); };
    ST address : "+" phoneDigits
    ST phoneDigits : digitOrSeparator
               phoneDigits | digitOrSeparator
    ST digitOrSeparator : digit | separator;
    ST digit : /[0..9]/;
    ST separator : /[().-]/;
  };
};
      </mif:data>
               </mif:otherAnnotation>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="ST"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="TEL" title="TelecommunicationAddress" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="URL"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
A telephone number (voice or fax), e-mail address, or other locator
for a resource mediated by telecommunication equipment. The address is
specified as a Universal Resource Locator (URL) qualified by time
specification and use codes that help in deciding which address to use
for a given time and purpose.
    </mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
The semantics of a telecommunication address is that a communicating
entity (the responder) listens and responds to that address, and
therefore can be contacted by an other communicating entity (the
initiator.)
    </mif:p>
                  <mif:p>
The responder of a telecommunication address may be an automatic
service that can respond with information (e.g., FTP or HTTP
services.)  In such case a telecommunication address is a reference to
that information accessible through that address. A telecommunication
address value can thus be resolved to some information (in the form of
encapsulated data, <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="ED"/>
                     </mif:object>.)
    </mif:p>
                  <mif:p>
The telecommunication address is an extension of the Universal
Resource Locator (<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="URL"/>
                     </mif:object>) specified according to Internet
standard RFC 2396 [<mif:a href="http://www.ietf.org/rfc/rfc2396.txt"/>].
The <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="URL"/>
                     </mif:object> specifies the protocol and the contact point
defined by that protocol for the resource. Notable use cases for the
telecommunication address data type are for telephone and fax numbers,
e-mail addresses, Hypertext references, FTP references, etc.
    </mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type TelecommunicationAddress alias TEL specializes URL {
  GTS   useablePeriod;
  SET&lt;CS&gt;   use;
};
    </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="useablePeriod" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Useable Period"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
Specifies the periods of time during which the telecommunication
address can be used.  For a telephone number, this can indicate the
time of day in which the party can be reached on that telephone.  For
a web address, it may specify a time range in which the web content is
promised to be available under the given address.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="GTS"/>
      </mif:property>
      <mif:property name="use" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:businessName name="Use Code"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
One or more codes advising a system or user which telecommunication
address in a set of like addresses to select for a given
telecommunication need.
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
The telecommunication use code is not a complete classification for
equipment types or locations. Its main purpose is to suggest or
discourage the use of a particular telecommunication address. There
are no easily defined rules that govern the selection of a
telecommunication address.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="SET">
            <mif:argumentDatatype name="CS"/>
         </mif:type>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="TelecommunicationAddressUse"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="equal" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
Two telecommunication address values are considered equal if both
their <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="URL"/>
                        </mif:object>s are equal. Use code and valid time are
excluded from the equality test.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ANY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="ADXP" title="AddressPart" datatypeKind="Definition"
                 visibility="protected">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="SC"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
A character string that may have a type-tag signifying its role in the
address. Typical parts that exist in about every address are street,
house number, or post box, postal code, city, country but other roles
may be defined regionally, nationally, or on an enterprise level
(e.g. in military addresses). Addresses are usually broken up into
lines, which are indicated by special line-breaking delimiter elements
(e.g., DEL).
    </mif:text>
            </mif:definition>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
protected type AddressPart alias ADXP specializes ST {
  CS  partType;
};
    </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="partType" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1">
         <mif:businessName name="Address Part Type"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
Specifies whether an address part names the street, city, country,
postal code, post box, etc. If the type is NULL the address part is
unclassified and would simply appear on an address label as is.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="AddressPartType"/>
         </mif:vocabularySpecification>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="AD" title="PostalAddress" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="LIST">
            <mif:argumentDatatype name="ADXP"/>
         </mif:targetDatatype>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
Mailing and home or office addresses. A sequence of address parts,
such as street or post office Box, city, postal code, country, etc.
    </mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
The <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> is primarily used to communicate data that will allow
printing mail labels, that will allow a person to physically visit
that address. The postal address data type is not supposed to be a
container for additional information that might be useful for finding
geographic locations (e.g., GPS coordinates) or for performing
epidemiological studies. Such additional information is captured by
other, more appropriate HL7 elements.
    </mif:p>
                  <mif:p>
Addresses are conceptualized as text with added logical mark-up. The
mark-up may break the address into lines and may describe in detail
the role of each address part if it is known. Address parts occur in
the address in the order in which they would be printed on a mailing
label. The approach is similar to HTML or XML markup of text (but it
is not technically limited to XML representations.)
    </mif:p>
                  <mif:p>
Addresses are essentially sequences of address parts, but add a "use"
code and a valid time range for information about if and when the
address can be used for a given purpose.
    </mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type PostalAddress alias AD specializes LIST&lt;ADXP&gt; {
  SET&lt;CS&gt;   use;
  GTS useablePeriod;
  BL  isNotOrdered;
  ST  formatted;
};
    </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="use" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:businessName name="Use Code"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A set of codes advising a system or user which address in a set of
like addresses to select for a given purpose.
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
An address without specific use code might be a default address useful
for any purpose, but an address with a specific use code would be
preferred for that respective purpose.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="SET">
            <mif:argumentDatatype name="CS"/>
         </mif:type>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="PostalAddressUse"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="useablePeriod" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1">
         <mif:businessName name="Useable Period"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A General Timing Specification (GTS) specifying the periods of time
during which the address can be used.  This is used to specify
different addresses for different times of the week or year.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="GTS"/>
      </mif:property>
      <mif:property name="isNotOrdered" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1">
         <mif:businessName name="Is Not Ordered"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A boolean value specifying whether the order of the address parts is known
or not. While the address parts are always a Sequence, the order in which
they are presented may or may not be known. Where this matters, the
isNotOrdered property can be used to convey this information.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="equal" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
Two address values are considered equal if both contain the same
address parts, independent of ordering. Use code and valid time are
excluded from the equality test.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ANY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="formatted" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Formatting Address"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A character string value with the address formatted in lines and with
proper spacing. This is only a semantic property to define the
function of some of the address part types.<mif:object name="footnote">
Remember that semantic properties are bare of all control flow
semantics. The  could be implemented
as a "procedure" that would "return" the formatted address, but it
would not usually be a variable to which one could assign a formatted
address. However, HL7 does not define applications but only the
semantics of exchanged data values. Hence, the semantic model
abstracts from concepts like "procedure", "return", and "assignment"
but speaks only of property and value.
          </mif:object>
						            </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
The <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> data type's main purpose is to capture postal addresses,
such that one can visit that address or send mail to it. Humans will
look at addresses in printed form, such as on a mailing label. The
<mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> data type defines precise rules of how its data is
formatted.<mif:object name="footnote">
These rules for formatting addresses are part of the semantics of
addresses because addresses are primarily defined as text displayed or
printed and consumed by humans. Other uses (e.g., epidemiology) are
secondary — although not forbidden, the 
data type might not serve these other use cases very well, and HL7
defines better ways to handle these use cases. Note that these
formatting rules are not ITS issues, since this formatting applies
to presentations for humans whereas ITS specifications are
presentations for computer interchange.
          </mif:object>
						               </mif:p>
                     <mif:p>
Addresses are ordered lists of address parts. Each address part is
printed in the order of the list from left to right and top to bottom
(or in any other language-specific reading direction, which to
determine is outside the scope of this specification.)  Every address
part value is printed. Most address parts are framed by white
space. The following six rules govern the setting of whitespace.
      </mif:p>
                     <mif:ol>
                        <mif:li>
                           <mif:p>
Whitespace never accumulates, i.e. two subsequent spaces are the same
as one. Subsequent line breaks can be reduced to one. Whitespace
around a line break is not significant.
          </mif:p>
                        </mif:li>
                        <mif:li>
                           <mif:p>
Literals may contain explicit whitespace, subject to the same white
space reduction rules. There is no notion of a literal line break
within the text of a single address part.
          </mif:p>
                        </mif:li>
                        <mif:li>
                           <mif:p>
Leading and trailing explicit whitespace is insignificant in all
address parts, except for delimiter (DEL) address parts.
          </mif:p>
                        </mif:li>
                        <mif:li>
                           <mif:p>
By default, an address part is surrounded by implicit whitespace.
          </mif:p>
                        </mif:li>
                        <mif:li>
                           <mif:p>
Delimiter (DEL) address parts are not surrounded by any implicit white
space.
          </mif:p>
                        </mif:li>
                        <mif:li>
                           <mif:p>
Leading and trailing explicit whitespace is significant in delimiter
(DEL) address parts.
          </mif:p>
                        </mif:li>
                     </mif:ol>
                     <mif:p>
This means that all address parts are generally surrounded by white
space, but whitespace does never accumulate. Delimiters are never
surrounded by implicit whitespace and every whitespace contributed
by preceding or succeeding address parts is discarded, whether it was
implicit or explicit.
      </mif:p>
                     <mif:p>
The following shows examples of addresses in the XML ITS form.
      </mif:p>
                     <mif:blockquote>
                        <mif:p>
1050 W Wishard Blvd,<mif:br/>
RG 5th floor,<mif:br/>
Indianapolis, IN 46240.
        </mif:p>
                     </mif:blockquote>
                     <mif:p>
Can be encoded in any of the following forms:<mif:object name="footnote">
The XML encoding shown here is according to the XML ITS only in order
to avoid introducing another instance notation. This does not imply
that the function would only work in XML, nor even that XML is the
preferred representation.
          </mif:object>
						               </mif:p>
                     <mif:p>
The first form would result from a system that only stores addresses
as free text or in a list of fields line1, line2, etc.:
</mif:p>
                     <mif:p>
The second form is more specific about the role of the address parts
than the first one:
</mif:p>
                     <mif:p>
This form is the typical form seen in the U.S., where street address
is sometimes separated, and city, state and ZIP code are always
separated.
</mif:p>
                     <mif:p>
The third is even more specific:
</mif:p>
                     <mif:p>
The latter form above is not used in the USA. However, it is useful
in Germany, where many systems keep house number as a distinct
field. For example, the German address:
</mif:p>
                     <mif:blockquote/>
                     <mif:p>
would most likely be encoded as follows:<mif:object name="footnote">
This example shows the strength of the mark-up approach to
addresses. A typical German system that stores house number and street
name in separate fields would print the address with street name first
followed by the house number. For U.S. addresses, this would be wrong
as the house number in the U.S. is written before the street name. The
marked-up address allows keeping the natural order of address parts
and still understanding their role.
    </mif:object>
						               </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:staticExample itsName="XML">
                  <mif:data>
                     <example noxmlspace="preserve">
                        <addr use="WP">
  1050 W Wishard Blvd,
  RG 5th floor,
  Indianapolis, IN 46240
</addr>
						               </example>
                  </mif:data>
               </mif:staticExample>
               <mif:staticExample itsName="XML">
                  <mif:data>
                     <example noxmlspace="preserve">
                        <addr use="WP">
                           <streetAddressLine>1050 W Wishard Blvd</streetAddressLine>,
  <streetAddressLine>RG 5th floor</streetAddressLine>,
  <city>Indianapolis</city>,
  <state>IN</state>
                           <postalCode>46240</postalCode>
                        </addr>
                     </example>
                  </mif:data>
               </mif:staticExample>
               <mif:staticExample itsName="XML">
                  <mif:data>
                     <example noxmlspace="preserve">
                        <addr use="WP">
                           <houseNumber>1050</houseNumber>
                           <direction>W</direction>
                           <streetName>Wishard Blvd</streetName>,
  <additionalLocator>RG 5th floor</additionalLocator>,
  <city>Indianapolis</city>,
  <state>IN</state>
                           <postalCode>46240</postalCode>
                        </addr>
                     </example>
                  </mif:data>
               </mif:staticExample>
               <mif:staticExample itsName="XML">
                  <mif:data>
                     <example noxmlspace="preserve">
                        <addr use="HP">
                           <streetName>Windsteiner Weg</streetName>
                           <houseNumber>54a</houseNumber>,
  <country>D</country>-
  <postalCode>14165</postalCode>
                           <city>Berlin</city>
                        </addr>
                     </example>
                  </mif:data>
               </mif:staticExample>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="ENXP" title="EntityNamePart" datatypeKind="Definition"
                 visibility="protected">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="SC"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
A character string token representing a part of a name. May have a
type code signifying the role of the part in the whole entity name,
and a qualifier code for more detail about the name part type.
Typical name parts for person names are given names, and family names,
titles, etc.
    </mif:text>
            </mif:definition>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
protected type EntityNamePart alias ENXP specializes ST {
  CS  partType;
  SET&lt;CS&gt;   qualifier;
};
    </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="partType" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1">
         <mif:businessName name="Name Part Type"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
Indicates whether the name part is a given name, family name, prefix,
suffix, etc.
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
Not every name part must have a type code, if the type code is
unknown, not applicable, or simply undefined this is expressed by a
NULL value (type.isNull). For example, a name may be "Rogan Sulma" and
it may not be clear which one is a given name or which is a last name,
or whether Rogan may be a title.
      </mif:p>
                     <mif:p>
Entity names are conceptualized as text with added mark-up. The
mark-up may describe in detail the role of each name part if it is
known. Name parts occur in the order in which they would be printed on
a mailing label. The model is similar to HTML or XML markup of text.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="EntityNamePartType"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="qualifier" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*">
         <mif:businessName name="Qualifier"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The qualifier is a set of codes each of which specifies a certain
subcategory of the name part in addition to the main name part type.
For example, a given name may be flagged as a nickname, a family name
may be a pseudonym or a name of public records.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="SET">
            <mif:argumentDatatype name="CS"/>
         </mif:type>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="EntityNamePartQualifier"/>
         </mif:vocabularySpecification>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="EN" title="EntityName" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="LIST">
            <mif:argumentDatatype name="ENXP"/>
         </mif:targetDatatype>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
A name for a person, organization, place or thing. A sequence of name
parts, such as given name or family name, prefix, suffix, etc.
Examples for entity name values are "Jim Bob Walton, Jr.", "Health
Level Seven, Inc.", "Lake Tahoe", etc. An entity name may be as simple
as a character string or may consist of several entity name parts,
such as, "Jim", "Bob", "Walton", and "Jr.", "Health Level Seven" and
"Inc.", "Lake" and "Tahoe".
    </mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
Entity names are conceptualized as text with added logical mark-up.
Name parts occur in a natural order in which they would be displayed,
as opposed to in a order detemined by name part. The ordeing of the
name parts is significant a feature that replaces the need for a
separate "display name" property. Applications may change that
ordering of name parts to account for their user's customary ordering
of name parts. The approach is similar to HTML or XML markup of text
(but it is not technically limited to XML representations.)
    </mif:p>
                  <mif:p>
Entity names are essentially sequences of entity name parts, but add a
"use" code and a valid time range for information about when the name
was used and how to choose between multiple aliases that may be valid
at the same point in time.
    </mif:p>
                  <mif:p>
Three restrictions to Entity Name are defined in order to allow making
specific constraints for certain kinds of entities, trivial name
(<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="TN"/>
                     </mif:object>), person name (<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="PN"/>
                     </mif:object>), and
organization name (<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="ON"/>
                     </mif:object>).
    </mif:p>
                  <mif:div title="Examples">
A very simple encoding of  "Adam A. Everyman" would be:
      

  Adam
  A.
  Everyman

					
None of the special qualifiers need to be mentioned if they are
unknown or irrelevant. The next example shows extensive use of
multiple given names, prefixes, suffixes, for academic degrees,
nobility titles, vorvoegsels ("van"), and professional
designations.
      

  Dr. phil. 
  Regina
  Johanna
  Maria
  Gräfin 
  Hochheim-Weilenfels
  NCFSA


The next example is an organization name, "Health Level Seven, Inc."
in simple string form:
      
Health Level Seven, Inc.
					
and as a fully parsed name
      
Health Level Seven, Inc.

					
The following example shows a Japanese name in the three forms:
ideographic (Kanji), syllabic (Hiragana), and alphabetic (Romaji).
      

  木村
  通男


  きむら
  みちお


  KIMURA
  MICHIO

					</mif:div>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type EntityName alias EN specializes LIST&lt;ENXP&gt; {
  SET&lt;CS&gt; use;
  IVL&lt;TS&gt; validTime;
  ST  formatted;
};
    </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="use" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:businessName name="Use Code"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A set of codes advising a system or user which name in a set of
names to select for a given purpose.
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
A name without specific use code might be a default name useful for
any purpose, but a name with a specific use code would be preferred
for that respective purpose.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="SET">
            <mif:argumentDatatype name="CS"/>
         </mif:type>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="EntityNameUse"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="validTime" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1">
         <mif:businessName name="Valid Time"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
An interval of time specifying the time during which the name is or
was used for the entity. This accomodates the fact that people change
names for people, places and things.
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
The <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> conforms to the history item data type extension (<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="HXIT"/>
                        </mif:object>).
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="IVL">
            <mif:argumentDatatype name="TS"/>
         </mif:type>
      </mif:property>
      <mif:property name="equal" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
Two name values are considered equal if both conatain the same name
parts, independent of ordering. Use code and valid time are excluded
from the equality test.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ANY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="formatted" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Formatting Entity Names"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A character string value with the entity name formatted with
proper spacing. This is only a semantic property to define the
function of some of the name part types.<mif:object name="footnote">
Remember that semantic properties are bare of all control flow
semantics. The  could be implemented
as a "procedure" that would "return" the formatted name, but it would
not usually be a variable to which one could assign a formatted
name. However, HL7 does not define applications but only the semantics
of exchanged data values. Hence, the semantic model abstracts from
concepts like "procedure", "return", and "assignment" but speaks only
of property and value.
          </mif:object>
						            </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
The <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> data type's main purpose is to capture names of people,
places, and things (entities), so that one can address and refer to
these entities in speech and writing. Humans will look at names in
printed form, such as on a mailing label. The <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> data type
therefore defines precise rules of how its data is
formatted.<mif:object name="footnote">
These rules for formatting names are part of the semantics of names
because the name parts have been designed with the important use case
of displaying and rendering on labels. Note that these formatting
rules are not ITS issues, since this formatting applies to
presentations for humans whereas ITS specifications are presentations
for computer interchange.
          </mif:object>
						               </mif:p>
                     <mif:p>
Entity names are ordered lists of entity name parts. Each entity name
part is printed in the order of the list from left to right (or in any
other language-specific reading direction.)  Every entity name part
(except for those marked "invisible") is printed. Most entity name
parts are framed by whitespace. The following six rules govern the
setting of whitespace.
      </mif:p>
                     <mif:ol>
                        <mif:li>
                           <mif:p>
Whitespace never accumulates, i.e. two subsequent spaces are the same
as one.
          </mif:p>
                        </mif:li>
                        <mif:li>
                           <mif:p>
Literals may contain explicit whitespace subject to the same white
space reduction rules.
          </mif:p>
                        </mif:li>
                        <mif:li>
                           <mif:p>
Except for <mif:b>prefix</mif:b>, <mif:b>suffix</mif:b> and
<mif:b>delimiter</mif:b> name parts, every name part is surrounded by
implicit whitespace. Leading and trailing explicit whitespace is
insignificant in all those name parts.
          </mif:p>
                        </mif:li>
                        <mif:li>
                           <mif:p>
Delimiter name parts are not surrounded by any implicit white
space. Leading and trailing explicit whitespace is significant in
delimiter name parts.
          </mif:p>
                        </mif:li>
                        <mif:li>
                           <mif:p>
Prefix name parts only have implicit leading whitespace but no
implicit trailing whitespace. Trailing explicit whitespace is
significant in prefix name parts.
          </mif:p>
                        </mif:li>
                        <mif:li>
                           <mif:p>
Suffix name parts only have implicit trailing whitespace but no
implicit leading whitespace. Leading explicit whitespace is
significant in suffix name parts.
          </mif:p>
                        </mif:li>
                        <mif:li>
                           <mif:p>
This means that all entity name parts are generally surrounded by
whitespace, but whitespace does never accumulate. Delimiters are never
surrounded by implicit whitespace, prefixes are not followed by
implicit whitespace and suffixes are not preceded by implicit white
space. Every whitespace contributed by preceding or succeeding name
parts around those special name parts is discarded, whether it was
implicit or explicit.
          </mif:p>
                        </mif:li>
                     </mif:ol>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="ST"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="TN" title="TrivialName" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="EN"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
A restriction of entity name that is effectively a simple string used
for a simple name for things and places.
    </mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
The <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> is a <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="EN"/>
                     </mif:object> that consists of only one name
part without any name part type or qualifier. The <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>, and its
single name part are therefore equivalent to a simple character
string. This equivalence is expressed by a defined demotion to
<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="ST"/>
                     </mif:object> and promotion from <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="ST"/>
                     </mif:object>.
    </mif:p>
                  <mif:p>
Trivial names are typically used for places and things, such as
<mif:b>Lake Erie</mif:b> or <mif:b>Reagan National Airport</mif:b>:
    </mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type TrivialName alias TN specializes EN {
 demotion ST;
 promotion  TN  (ST x);
};
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:staticExample itsName="XML">
               <mif:data>
                  <example noxmlspace="preserve">
                     <name>Lake Erie</name>
                     <name>Washington National Airport</name>
				              </example>
               </mif:data>
            </mif:staticExample>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="demotion" sortKey="01" propertyKind="demotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Demotion to ST"/>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="promotion" sortKey="02" propertyKind="promotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Promotion of String to Name"/>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ST"/>
         </mif:parameter>
         <mif:type name="TN"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="PN" title="PersonName" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="EN"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
An <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="EN"/>
                  </mif:object> used when the named Entity
is a Person. A sequence of name parts, such as given name or
family name, prefix, suffix, etc. A name part is a restriction of
entity name part that only allows those entity name parts qualifiers
applicable to person names. Since the structure of entity name is
mostly determined by the requirements of person name, the restriction
is very minor.
    </mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
Since most of the functionality of entity name is in support of person
names, the person name (<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="PN"/>
                     </mif:object>) is only a very minor
restriction on the entity name part qualifier.
    </mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type PersonName alias PN specializes EN;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="ON" title="OrganizationName" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="EN"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
An <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="EN"/>
                  </mif:object> used when the named Entity
is an Organization. A sequence of name parts.
    </mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
A name for an organization, such as "Health Level Seven, Inc."  An
organization name consists only of untyped name parts, prefixes,
suffixes, and delimiters.
    </mif:p>
                  <mif:div title="Examples">
The following is the organization name, "Health Level Seven, Inc." in
a simple string form:
      
Health Level Seven, Inc.;

And with the legal status "Inc." as a distinguished name part:
      
Health Level Seven, Inc.

					</mif:div>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type OrganizationName alias ON specializes EN;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="QTY" title="Quantity" isAbstract="true" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ANY"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
The quantity data type is an abstract generalization for all data
types (1) whose value set has an order relation (less-or-equal) and
(2) where difference is defined in all of the data type's totally
ordered value subsets.  The quantity type abstraction is needed in
defining certain other types, such as the interval and the probability
distribution.
    </mif:text>
            </mif:definition>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
abstract type Quantity alias QTY specializes ANY {
  BL   lessOrEqual(QTY x);
  BL   compares(QTY x);
  TYPE diffType;
  QTY  minus(QTY x);
  QTY  plus(QTY x);
  BL   isZero;
  BL   lessThan(QTY x);
  BL   greaterOrEqual(QTY x);
  BL   greaterThan(QTY x);
};
    </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="lessOrEqual" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Ordering: less-or-equal"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A predicate expressing an order relation that is reflexive, asymmetric
and transitive, between this quantity and another quantity.
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
The <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> relation is defined on any totally ordered partition
of the quantity data type. A totally ordered partition is a subset of
the data types's defined values where all elements have a defined
order (e.g., the integer and real numbers are totally ordered.)
      </mif:p>
                     <mif:p>
By contrast, a partially ordered set is a set where some, but not all
pairs of elements are comparable through the order relation (e.g., a
tree structure or the set of physical quantities is a partially
ordered set.)  Two data values <mif:b>x</mif:b> and <mif:b>y</mif:b> of an
ordered type are comparable (<mif:b>x</mif:b>.compares(<mif:b>y</mif:b>))
if the less-or-equal relation holds in either way (<mif:b>x</mif:b>
≤ <mif:b>y</mif:b> or <mif:b>y</mif:b> ≤ <mif:b>x</mif:b>).
      </mif:p>
                     <mif:p>
A partial order relation generates totally ordered subsets whose union
is the entire set (e.g., the set of all length is a totally ordered
subset of the set of all physical quantities.)
      </mif:p>
                     <mif:p>
For example, a tree structure is partially ordered, where the root is
considered less or equal to a leaf, but there may not be an order
among the leafs. Also, physical quantities are partially ordered,
since an order exists only among quantities of the same dimension
(e.g., between two lengths, but not between a length and a time.)  A
totally ordered subset of a tree is a path that transitively connects
a leaf to the root. The physical dimension of time is a totally
ordered subset of physical quantities.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QTY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="equal" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ANY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="compares" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Comparability"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A predicate indicating if this value and the operand can be compared
as to which is greater than the other.
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
Two quantities are comparable if they are both elements of a common
totally ordered partition of their data types' value space. The
definition is based on <mif:object name="propertyRef">
                           <mif:param name="datatypeName" value="QTY"/>
                           <mif:param name="propertyName" value="lessOrEqual"/>
                        </mif:object>.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QTY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="diffType" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="DifferenceDataType"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The type of the difference between 2 values of a specific QTY data type.
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
The type will be some data type that further specializes QTY
          </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="TYPE"/>
      </mif:property>
      <mif:property name="minus" sortKey="05" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Difference"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A quantity expressing the "distance" of this quantity from the operand
quantity, that must be comparable. The data type of the difference
quantity is related to the operand quantities but need not be the
same.
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
The result of minus has the data type returned by the
diffType property of the instance.
            </mif:p>
                     <mif:p>
A difference is defined in an ordered set if it is semantically
meaningful to state that Δ is the difference between the values
<mif:b>x</mif:b> and <mif:b>y</mif:b>. This difference Δ must be
meaningful independently from the values <mif:b>x</mif:b> and
<mif:b>y</mif:b>. This independence exists if for all values
<mif:b>u</mif:b> one can meaningfully derive a value <mif:b>v</mif:b> such
that Δ would also be the difference between <mif:b>u</mif:b> and
<mif:b>v</mif:b>. The judgment for what is <mif:b>meaningful</mif:b>
cannot be defined formally.<mif:object name="footnote">
The quantity data type abstraction corresponds to the notion of
difference scales in contrast to ordinal scales and ratio scales
(Guttman and Stevens). A data type with only the order requirement but
not the difference requirement would be an ordinal. Ordinals are not
currently defined with a special data type. Instead, ordinals are
usually coded values, where the underlying code system specifies
ordinal semantics. This ordinal semantics, however, is not reflected
in the HL7 data type semantics at this time.
          </mif:object>
						               </mif:p>
                     <mif:p>
The <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> has a data type that can express the difference between
two values for which the ordering relation is defined (i.e., two
elements of a common totally ordered subset.)  For example, the
difference data type of integer number is integer number, but the
difference type of point in time is a physical quantity in the
dimension of time. A difference data type is a totally ordered data
type.
      </mif:p>
                     <mif:p>
The difference between two values <mif:b>x</mif:b> minus <mif:b>y</mif:b>
must be defined for all <mif:b>x</mif:b> and <mif:b>y</mif:b> in a common
totally ordered subset of the data type's value set. Zero is the
difference between a value and itself.
      </mif:p>
                     <mif:p>
If x and y are not comparable, then the difference will be Null
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QTY"/>
         </mif:parameter>
         <mif:type name="QTY"/>
      </mif:property>
      <mif:property name="plus" sortKey="06" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Addition"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The sum of this quantity and its operand. The operand must be of a
data type that can express the difference between two values of this
quantity's data type.
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
Q: what is the relationship between
  {y.dataType.implies(x.diffType)}
and
  {x.compares(y)}?
      </mif:p>
                     <mif:p>
If <mif:var>y</mif:var> is not a valid type for the difference between two
values of the type of <mif:var>x</mif:var>, the the result of the operation
will be NULL.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QTY"/>
         </mif:parameter>
         <mif:type name="QTY"/>
      </mif:property>
      <mif:property name="isZero" sortKey="07" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="The Zero-Quantity"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The neutral element in the difference and addition operations, i.e.,
if a quantity is zero, addition to, or subtraction from any other
comparable quantity will result in that other quantity.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="lessThan" sortKey="08" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Ordering: less-than"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A predicate expressing an order relation that is asymmetric and
transitive, between this quantity and another quantity. The ordering
is the same as <mif:object name="propertyRef">
                        <mif:param name="datatypeName" value="QTY"/>
                        <mif:param name="propertyName" value="lessOrEqual"/>
                     </mif:object>, but irreflexive.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QTY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="greaterOrEqual" sortKey="09" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Ordering: greater-or-equal"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A predicate expressing an order relation that is reflexive, asymmetric
and transitive, between this quantity and another quantity. This is
the inverse order of <mif:object name="propertyRef">
                        <mif:param name="datatypeName" value="QTY"/>
                        <mif:param name="propertyName" value="lessOrEqual"/>
                     </mif:object>.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QTY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="greaterThan" sortKey="10" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Ordering: greater-than"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A predicate expressing an order relation that is asymmetric and
transitive, between this quantity and another quantity. This
is the invese of <mif:object name="propertyRef">
                        <mif:param name="datatypeName" value="QTY"/>
                        <mif:param name="propertyName" value="lessThan"/>
                     </mif:object>.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QTY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="INT" title="IntegerNumber" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QTY"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
Integer numbers (-1,0,1,2, 100, 3398129, etc.) are precise numbers
that are results of counting and enumerating. Integer numbers are
discrete, the set of integers is infinite but countable.  No arbitrary
limit is imposed on the range of integer numbers. Two NULL flavors are
defined for the positive and negative infinity.
    </mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
Since the integer number data type includes all of the semantics of
the mathematical integer number concept, the basic operations plus
(addition) and times (multiplication) are defined. These operations
are defined here as characterizing operations in the sense of ISO
11404, and because these operations are needed in other parts of this
specification, namely the semantics of the literal form.
    </mif:p>
                  <mif:p>
The traditional recursive definitions of addition and multiplication
are due to Grassmann, and use the notion of <mif:object name="propertyRef">
                        <mif:param name="datatypeName" value="INT"/>
                        <mif:param name="propertyName" value="successor"/>
                     </mif:object>.<mif:object name="footnote">
H. Grassman. Lehrbuch der Arithmetik. 1861. We prefer
Grassman's original axioms to the Peano axioms, because Grassman's
axioms work for all integers, not just for natural numbers. Also, "it
is rather well-known, through Peano's own acknowledgment, that Peano
borrowed his axioms from Dedekind and made extensive use of
Grassmann's work in his development of the axioms." (Hao Wang. The
Axiomatization of Arithmetic. J. Symb. Logic; 1957:22(2); p. 145.)
        </mif:object>
				              </mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type IntegerNumber alias INT specializes QTY {
          INT   successor;
          INT   plus(QTY x);
          INT   times(INT x);
          INT   predecessor;
          INT   negated;
          BL    nonNegative;
          BL    isNegative;
          INT   dividedBy(INT x);
          INT   remainder(INT x);
          BL    isOne;
  literal ST;
};
    </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="successor" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Successor"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> value that is greater than this <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> value but
where no <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> value exists between this value and its successor.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="diffType" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="DifferenceDataType"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
The difference between two <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> values is also a <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> value.
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:type name="TYPE"/>
      </mif:property>
      <mif:property name="plus" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Addition"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QTY"/>
         </mif:parameter>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="times" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Multiplication"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The result of multiplying this integer with the operand, equivalent to
repeated additions of this integer.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="INT"/>
         </mif:parameter>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="predecessor" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Predecessor"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The inverse of <mif:object name="propertyRef">
                        <mif:param name="datatypeName" value="INT"/>
                        <mif:param name="propertyName" value="successor"/>
                     </mif:object>.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="negated" sortKey="06" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Negation"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The inverse element of the <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> value, another <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> value,
which, when added to that value yields zero (the neutral element.)
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="nonNegative" sortKey="07" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Non-Negative"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A predicate indicating whether the <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> zero (neutral element) is
less or equal to this <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="isNegative" sortKey="08" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Negative"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A predicate indicating whether this <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> is less than zero (not
non-negative.)
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="dividedBy" sortKey="09" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Integer Division"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The integer division operation of this integer (dividend) with another
integer (divisor) is the integer number of times the divisor fits into
the dividend.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="INT"/>
         </mif:parameter>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="remainder" sortKey="10" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Remainder"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The remainder of the integer division.
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
This definition of the remainder matches the C and Java programming
languages.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="INT"/>
         </mif:parameter>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="isOne" sortKey="11" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Neutral Element of Multiplication"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A predicate indicating if this value is the number one, i.e., the
neutral element of multiplication. There is exactly one integer
that has this property.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="literal" sortKey="12" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
The literal form of an integer is a simple decimal number, i.e. a
string of decimal digits.
      </mif:p>
                  </mif:text>
               </mif:designComments>
               <mif:otherAnnotation type="LiteralFormat">
                  <mif:data>
INT.literal ST {
  INT digit : "0"         { $.isZero; }
            | "1"         { $.equal(0.successor); }
            | "2"         { $.equal(1.successor); }
            | "3"         { $.equal(2.successor); }
            | "4"         { $.equal(3.successor); }
            | "5"         { $.equal(4.successor); }
            | "6"         { $.equal(5.successor); }
            | "7"         { $.equal(6.successor); }
            | "8"         { $.equal(7.successor); }
            | "9"         { $.equal(8.successor); };

  INT uint : digit        { $.equal($1); }
           | uint digit   { $.equal($1.times(9.successor).plus($2)); };

  INT : uint              { $.equal($1); }
      | "+" uint          { $.equal($2); }
      | "-" uint          { $.equal($2.negated); };
};
      </mif:data>
               </mif:otherAnnotation>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="ST"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="REAL" title="RealNumber" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QTY"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
Fractional numbers. Typically used whenever quantities are measured,
estimated, or computed from other real numbers.  The typical
representation is decimal, where the number of significant decimal
digits is known as the precision.
    </mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
The term "Real number" in this specification is used to mean that
fractional values are covered without necessarily implying the full
set of the mathematical real numbers that would include irrational
numbers such as ρ, Euler's number, etc.<mif:object name="footnote">
The term "Real" for a fractional number data type originates and is
well established in the Algol, Pascal tradition of programming
languages.
        </mif:object>
				              </mif:p>
                  <mif:p>
This specification offers two choices for a number data type. The
choice is made as follows: Any number attribute is a real if it is not
known for sure that it is an integer. A number is an integer if it is
<mif:b>always</mif:b> counted, typically representing an ordinal
number. If there are conceivable use cases where such a number would
be estimated or averaged, it is not always an integer and thus should
use the Real data type.
    </mif:p>
                  <mif:p>
The algebraic operations are specified here as characterizing
operations in the sense of ISO 11404, and because these operations are
needed in other parts of this specification.
    </mif:p>
                  <mif:p>
Unlike the integer numbers, the real numbers semantics are not
inductively constructed but only intuitively described by their axioms
of their algebraic properties. The completeness axioms are
intentionally left out so as to make no statement about irrational
numbers.
    </mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type RealNumber alias REAL specializes QTY {
            REAL  negated;
            BL    isOne;
            REAL  times(REAL x);
            REAL  inverted;
            REAL  power(REAL x);
  literal   ST;
            INT   precision;
  demotion  INT;
  promotion REAL  (INT x);
};
    </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="compares" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Comparability"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
The value set of <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> is totally ordered.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QTY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="diffType" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="DifferenceDataType"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
The difference between two <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> values is also a <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> value.
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:type name="TYPE"/>
      </mif:property>
      <mif:property name="plus" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Addition"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QTY"/>
         </mif:parameter>
         <mif:type name="QTY"/>
      </mif:property>
      <mif:property name="negated" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Negation (Inverse Element of Addition)"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> value, which, when added to another <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> value yields
zero (the neutral element of addition.)
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="REAL"/>
      </mif:property>
      <mif:property name="isOne" sortKey="05" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Neutral Element of Multiplication"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A predicate indicating if this value is the number one, i.e., the
neutral element of multiplication. There is exactly one real number
that has this property.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="times" sortKey="06" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Multiplication"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
An operation in <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> that forms an abelian group and is related
to addition by the law of distribution.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="REAL"/>
         </mif:parameter>
         <mif:type name="REAL"/>
      </mif:property>
      <mif:property name="inverted" sortKey="07" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Inverse Element of Multiplication"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> value, which, when muliplied with another <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> value
yields one (the neutral element of multiplication). Zero (the neutral
element of addition) has no inverse element.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="REAL"/>
      </mif:property>
      <mif:property name="power" sortKey="08" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Exponentiation"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The basis of exponentiation is the iterative multiplication of a 
real number, and extended to rational exponents as the inverse
operation.
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
We only list certain common properties of exponentiation.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="REAL"/>
         </mif:parameter>
         <mif:type name="REAL"/>
      </mif:property>
      <mif:property name="literal" sortKey="09" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
The literal form of an real is a string of decimal digits with
optional leading "+" or "-" sign, and optional decimal point, and
optional exponential notation using a case insensitive "e" between the
mantissa and the exponent. The number of significant digits must
conform to the precision property.
      </mif:p>
                     <mif:p>
Examples of real literals for two thousand are 2000, 2000., 2e3,
2.0e+3, +2.0e+3.
      </mif:p>
                     <mif:p>
Note that the literal form does not carry type information. For
example, "2000" is a valid representation of both a real number and an
integer number. No trailing decimal point is used to disambiguate from
integer numbers. An ITS that uses this literal form must recover the
type information from other sources.
      </mif:p>
                  </mif:text>
               </mif:designComments>
               <mif:otherAnnotation type="LiteralFormat">
                  <mif:data>
REAL.literal ST {
  REAL : mantissa                   { $.equal($1); }
       | mantissa /[eE]/ INT        { $.equal($1
                                         .times(10.power($3)); };

  REAL mantissa
       : /0*/ 0                     { $.isZero; $.precision.equal(1); }
       | /0*/ "." /0*/              { $.isZero; $.precision.equal(
                                                  $3.length.successor); }
       | /0*/ "." /0*/ fractional   { $.equal($4);
                                      $.precision.equal($4.precision); }
       | integer                    { $.equal($1); }
       | integer "." fractional     { $.equal($1.plus($2));
                                      $.precision.equal($1.precision
                                        .plus($3.precision)); };

  REAL integer
       : uintval                    { $.equal($2); }
       | "+" uintval                { $.equal($1.times($2)); }
       | "-" uintval                { $.equal($1.times($2).negated); };

  REAL uintval : /0*/ uint          { $.equal($2); };

  REAL uint : digit                 { $.equal($1);
                                      $.precision.equal(1); }
            | uint digit            { $.equal($1.times(10).plus($2));
                                      $.precision.equal(
                                        $1.precision.successor; };

  REAL fractional
       : digit                      { $.equal($1.times(10.inverted));
                                      $.precision.equal(1); }
       | digit fractional           { $.equal(
                                        $1.plus($2.times(10.inverted));
                                      $.precision.equal(
                                        $1.precision.successor); };

  INT digit : /[0-9]/               { $.equal($1); }
};
      </mif:data>
               </mif:otherAnnotation>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="precision" sortKey="10" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Precision of the Decimal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The number of significant digits of the decimal representation.
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
Precision is formally defined based on the <mif:object name="propertyRef">
                           <mif:param name="datatypeName" value="REAL"/>
                           <mif:param name="propertyName" value="literal"/>
                        </mif:object>
						               </mif:p>
                     <mif:p>
The precision attribute is only the precision of a decimal digit
representation, <mif:b>not the accuracy of the real number
value</mif:b>.
      </mif:p>
                     <mif:p>
The purpose of the precision property for the real number data type is
to faithfully capture the whole information presented to humans in a
number. The amount of decimal digits shown conveys information about
the uncertainty (i.e., precision and accuracy) of a measured value.
      </mif:p>
                     <mif:p>
The rules for what digits are significant are as follows:
      </mif:p>
                     <mif:ol>
                        <mif:li>
                           <mif:p>
All non-zero digits are significant.
          </mif:p>
                        </mif:li>
                        <mif:li>
                           <mif:p>
All zeroes to the right of a significant digit are significant.
          </mif:p>
                        </mif:li>
                        <mif:li>
                           <mif:p>
When all digits in the number are zero the zero-digit immediately left
to the decimal point is significant (and because of rule 2, all
following zeroes are thus significant too.)
          </mif:p>
                        </mif:li>
                     </mif:ol>
                     <mif:table width="90%" hl7Id="table-REAL.precision.examples">
                        <mif:caption>Examples for the Precision of Real Number Literals.</mif:caption>
                        <mif:thead>
                           <mif:tr>
                              <mif:th>Literal</mif:th>
                              <mif:th>Number of Significant Digits</mif:th>
                           </mif:tr>
                        </mif:thead>
                        <mif:tbody>
                           <mif:tr>
                              <mif:td>2000</mif:td>
                              <mif:td>has 4 significant digits.</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>2e3</mif:td>
                              <mif:td>has 1 significant digit, used if one would naturally say 
                  "2000" but precision is only 1.</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>0.001</mif:td>
                              <mif:td>has 1 significant digit.</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>1e-3</mif:td>
                              <mif:td>has 1 significant digit, use this if one would naturally
                  say "0.001" but precision is only 1.</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>0</mif:td>
                              <mif:td>has 1 significant digit.</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>0.0</mif:td>
                              <mif:td>has 2 significant digits.</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>000.0</mif:td>
                              <mif:td>has 2 significant digits.</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>0.00</mif:td>
                              <mif:td>has 3 significant digits.</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>4.10</mif:td>
                              <mif:td>has 3 significant digits.</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>4.09</mif:td>
                              <mif:td> has 3 significant digits.</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>4.1</mif:td>
                              <mif:td>has 2 significant digits.</mif:td>
                           </mif:tr>
                        </mif:tbody>
                     </mif:table>
                     <mif:p>
The precision of the representation <mif:b>should</mif:b> match the
uncertainty of the value. However, precision of the representation and
uncertainty of the value are separate independent concepts. Refer to
<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="PPD_REAL"/>
                        </mif:object> for details about uncertain real numbers.
      </mif:p>
                     <mif:p>
For example "0.123" has 3 significant digits <mif:b>in the
representation</mif:b>, but the <mif:b>uncertainty of the value</mif:b>
may be in any digit shown or not shown, i.e., the uncertainty may be
0.123±0.0005, 0.123±0.005 or
0.123±0.00005, etc. Note that ITS representations
<mif:b>should</mif:b> adjust their representational precision with the
uncertainty of the value. However, since the precision in the digit
string is granular to 0.5 the least significant digit, while
uncertainty may be anywhere between these "grid lines",
0.123±0.005 would also be an adequate representation for the
value between 0.118 and 0.128.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="demotion" sortKey="11" propertyKind="demotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Demotion to INT"/>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="promotion" sortKey="01" propertyKind="promotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Homomorphism of INT and REAL"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="INT"/>
                        </mif:object> and <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> data types are related by a
						homomorphism that maps every value in <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="INT"/>
                        </mif:object> to a value
						in <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> whereby the algebraic properties of <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="INT"/>
                        </mif:object>
						are preserved. This means, an integer can be promoted to a real and a
						real can be demoted to an integer by means of rounding off the
						fractional part.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="INT"/>
         </mif:parameter>
         <mif:type name="REAL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="RTO" title="Ratio" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QTY"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
A quantity constructed as the quotient of a numerator quantity divided
by a denominator quantity. Common factors in the numerator and
denominator are not automatically cancelled out.  The <mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object> data
type supports titers (e.g., "1:128") and other quantities produced by
laboratories that truly represent ratios. Ratios are not simply
"structured numerics", particularly blood pressure measurements
(e.g. "120/60") are not ratios. In many cases the <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="REAL"/>
                  </mif:object>
should be used instead of the <mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object>.
    </mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
Ratios are different from rational numbers, i.e., in ratios common
factors in the numerator and denominator never cancel out.  A ratio of
two real or integer numbers is not automatically reduced to a real
number.
    </mif:p>
                  <mif:p>
The default value for both numerator and denominator is the integer
number 1 (one.) The denominator may not be zero.
    </mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;QTY N, QTY D&gt;
type Ratio&lt;N, D&gt; alias RTO&lt;N, D&gt; specializes QTY {
  N numerator;
  D denominator;
 literal ST;
};
    </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="N" sortKey="1">
         <mif:type name="QTY"/>
      </mif:parameter>
      <mif:parameter name="D" sortKey="2">
         <mif:type name="QTY"/>
      </mif:parameter>
      <mif:property name="numerator" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="1"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Numerator"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The quantity that is being divided in the ratio.  The default is the
integer number 1 (one.)
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="N" qualifier="parameter"/>
      </mif:property>
      <mif:property name="denominator" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="1"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Denominator"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The quantity that devides the numerator in the ratio.  The default is
the integer number 1 (one.)  The denominator must not be zero.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="D" qualifier="parameter"/>
      </mif:property>
      <mif:property name="literal" sortKey="03" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
A ratio literal form exists for all ratios where both numerator and
denominators have literal forms. A ratio is simply the numerator
literal a colon as separator followed by the denominator literal. When
the colon and denominator are missing, the integer number 1 is assumed
as the denominator.
     </mif:p>
                     <mif:p>
For example, the rubella virus antibody titer value 1:64 could be
represented using the literal "1:64".
     </mif:p>
                  </mif:text>
               </mif:designComments>
               <mif:otherAnnotation type="LiteralFormat">
                  <mif:data>
RTO.literal ST {
  RTO : QTY          { $.numerator.equal($1);
                       $.denominator.equal((INT)1); };
      | QTY ":" QTY  { $.numerator.equal($1);
                       $.denominator.equal($3); };
};
     </mif:data>
               </mif:otherAnnotation>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="ST"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="PQ" title="PhysicalQuantity" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QTY"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
A dimensioned quantity expressing the result of measuring.
    </mif:text>
            </mif:definition>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type PhysicalQuantity alias PQ specializes QTY {
            REAL  value;
            CS    unit;
	    SET&lt;PQR&gt; translation;
            PQ    canonical;
            BL    isOne;
            PQ    times(PQ x);
            PQ    times(REAL x);
            PQ    inverted;
            PQ    power(INT x);
            PQ plus(QTY x);
  literal   ST;
  demotion  REAL;
};
    </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="value" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Maginitude Value"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The magnitude of the quantity measured in terms of the unit.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="REAL"/>
      </mif:property>
      <mif:property name="unit" sortKey="02" propertyKind="variableProperty" visibility="public"
                    defaultValue="1"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Unit of Measure"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The unit of measure specified in the Unified Code for Units of Measure
(UCUM) [<mif:a href="http://aurora.rg.iupui.edu/UCUM"/>].
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="UCUM"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="translation" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:businessName name="Translation"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
An alternative representation of the same physical quantity expressed
in a different unit, of a different unit code system and possibly with
a different value.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="SET">
            <mif:argumentDatatype name="PQR"/>
         </mif:type>
      </mif:property>
      <mif:property name="canonical" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Canonical Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A physical quantity expressed in a canonical unit. In any given unit
system has every physical dimension can be assigned one canonical unit
Defining the canonical unit is not subject of this specification, only
asserting that such a canonical unit exists (and can be arbitrarily
chosen) for every physical quantity. An abstract physical quantity is
equal to its canonical form.
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
For example, for a unit system based on the Système
International (SI) one can define the canonical form as (a) the
product of only the base units; (b) without prefixes; where (c) only
multiplication and exponents are used (no division operation); and (d)
where the seven base units appear in a defined ordering (e.g., m, s,
g...) Thus, 1 mm Hg would be expressed as 133322 m<mif:sup>-1</mif:sup>
s<mif:sup>-2</mif:sup>. As can be seen, the rules how to build the canonical
form of units may be quite complex. However, for the semantic
specification it doesn't matter how the canonical form is built, nor
what specific canonical form is chosen, only that <mif:b>some</mif:b>
canonical form <mif:b>could</mif:b> be defined.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="PQ"/>
      </mif:property>
      <mif:property name="equal" sortKey="05" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
Two physical quantities are equal if each their values and their units
of their canonical forms are equal.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ANY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="compares" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Comparability"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
Two physical quantities compare each other (and have an ordering and
difference) if the units of their canonical forms are equal.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QTY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="diffType" sortKey="07" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="DifferenceDataType"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
The difference between 2 Physical Quantities is another Physical Quantity with
the same units
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:type name="TYPE"/>
      </mif:property>
      <mif:property name="isOne" sortKey="08" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Neutral Element of Multiplication"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A predicate indicating if this value is the number one, i.e., the
neutral element of multiplication. There is exactly one physical
quantity that has this property and is called <mif:b>the unity</mif:b>.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="times" sortKey="09" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Multiplication"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The product of two physical quantities is the product of their values
times the product of their units.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="PQ"/>
         </mif:parameter>
         <mif:type name="PQ"/>
      </mif:property>
      <mif:property name="times" sortKey="10" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Real Multiplication"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
Multiplication with a real number forms a scaled quantity. A scaled
quantity is comparable to its original quantity.
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
If two quantities <mif:b>Q</mif:b>
							                 <mif:sub>1</mif:sub> and
<mif:b>Q</mif:b>
							                 <mif:sub>2</mif:sub> compare each other, there
exists a real number <mif:b>r</mif:b> such that <mif:b>r</mif:b>
							                 <mif:b>1</mif:b> = <mif:b>Q</mif:b>
							                 <mif:sub>1</mif:sub> /
<mif:b>Q</mif:b>
							                 <mif:sub>2</mif:sub>.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="REAL"/>
         </mif:parameter>
         <mif:type name="PQ"/>
      </mif:property>
      <mif:property name="inverted" sortKey="11" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Inverse Element of Multiplication"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> value, which, when muliplied with another <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> value
yields one (the neutral element of multiplication). Zero (the neutral
element of addition) has no inverse element.  The quotient of two
comparable quantities is comparable to the unity (the unit 1).
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="PQ"/>
      </mif:property>
      <mif:property name="power" sortKey="12" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Exponentiation"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A physical quantity can be raised to an integer power.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="INT"/>
         </mif:parameter>
         <mif:type name="PQ"/>
      </mif:property>
      <mif:property name="plus" sortKey="13" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Addition"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
Two physical quantities that compare each other can be added.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QTY"/>
         </mif:parameter>
         <mif:type name="PQ"/>
      </mif:property>
      <mif:property name="literal" sortKey="14" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
The literal form for a physical quantity is a real number literal
followed by optional whitespace and a character string representing a
valid code in the Unified Code for Units of Measure (UCUM)
[<mif:a href="http://aurora.rg.iupui.edu/UCUM"/>].
      </mif:p>
                     <mif:p>
For example 20 minutes is "20 min".
      </mif:p>
                  </mif:text>
               </mif:designComments>
               <mif:otherAnnotation type="LiteralFormat">
                  <mif:data>
PQ.literal ST {
  PQ : REAL unit { $.value.equal($1);
                   $.unit.equal($2); }
  CS unit : ST   { $.value.equal($1);
                   $.codeSystem.equal(2.16.840.1.113883.6.8); };
};
      </mif:data>
               </mif:otherAnnotation>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="demotion" sortKey="15" propertyKind="demotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Demotion to REAL"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
A <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="REAL"/>
                        </mif:object> value can be converted to a <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> value
with the unity, i.e. the unit <mif:b>1</mif:b> (one).
Likewise, a physical quantity that compares the unity can be converted
to a real number.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="REAL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="PQR" title="PhysicalQuantityRepresentation" datatypeKind="Definition"
                 visibility="protected">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="CV"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
An extension of the coded value data type representating a physical
quantity using a unit from any code system. Used to show alternative
representation for a physical quantity.
    </mif:text>
            </mif:definition>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
protected type PhysicalQuantityRepresentation alias PQR specializes CV {
  REAL value;
};
    </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="value" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Value"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The magnitude of the measurement value in terms of the unit
specified by this code.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="REAL"/>
      </mif:property>
      <mif:property name="code" sortKey="02" propertyKind="variableProperty" visibility="public"
                    defaultValue="NullFlavor.NI"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Code"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="CV"/>
         </mif:derivedFrom>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="codeSystem" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Code System"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="CV"/>
         </mif:derivedFrom>
         <mif:type name="UID"/>
      </mif:property>
      <mif:property name="codeSystemName" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="NullFlavor.NI"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Code System Name"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="CV"/>
         </mif:derivedFrom>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="codeSystemVersion" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="NullFlavor.NI"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1">
         <mif:businessName name="Code System Version"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="CV"/>
         </mif:derivedFrom>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="displayName" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="NullFlavor.NI"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Display Name"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="CV"/>
         </mif:derivedFrom>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="originalText" sortKey="07" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="NullFlavor.NI"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Original Text"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="CV"/>
         </mif:derivedFrom>
         <mif:type name="ED"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="MO" title="MonetaryAmount" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QTY"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
A monetary amount is a quantity expressing the amount of money in some
currency. Currencies are the units in which monetary amounts are
denominated in different economic regions. While the monetary amount
is a single kind of quantity (money) the exchange rates between the
different units are variable.  This is the principle difference
between physical quantity and monetary amounts, and the reason why
currency units are not physical units.
    </mif:text>
            </mif:definition>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type MonetaryAmount alias MO specializes QTY {
          REAL value;
          CS   currency;
          MO plus(MO x);
          MO   times(REAL x);
  literal ST;
};
    </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="value" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Value"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The magnitude of the monetary amount in terms of the currency unit.
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
The precision attribute of the real number type is the precision of
the decimal representation, not the precision of the value. The real
number type has no notion of uncertainty or accuracy. For example,
"1.99 USD" (precision 3) times 7 is "13.93 USD" (precision 4) and
should not be rounded to "13.9" to keep the precision constant.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="REAL"/>
      </mif:property>
      <mif:property name="currency" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Currency"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The currency unit as defined in ISO 4217.
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
This table only shows a representative subset of the 
codes defined by ISO 4217. All codes from ISO 4127 are 
valid for this attribute
</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="Currency"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="equal" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
Two <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> values are equal if each their values and their
currency units are equal.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ANY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="compares" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Comparability"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
Two <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> values compare each other (and have an ordering and
difference) if their currency units are equal.
      </mif:p>
                     <mif:p>
If the currencies are not equal, the amounts cannot be
compared. Conversion between the currencies is outside the scope of
this specification. In practice, foreign exchange rates are highly
variable not only over long and short amounts of time, but also
depending on location and access to currency trade markets.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QTY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="diffType" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="DifferenceDataType"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
      The difference between 2 monetary amounts is another monetary amount
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:type name="TYPE"/>
      </mif:property>
      <mif:property name="plus" sortKey="06" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Addition"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
Two monetary amounts can be added if they are denominated in the same
currency.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="MO"/>
         </mif:parameter>
         <mif:type name="MO"/>
      </mif:property>
      <mif:property name="times" sortKey="07" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Real Multiplication"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
Multiplication with a real number to forms a scaled quantity. A scaled
quantity is comparable to its original quantity.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="REAL"/>
         </mif:parameter>
         <mif:type name="MO"/>
      </mif:property>
      <mif:property name="literal" sortKey="08" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
The literal form for a monetary amount consists of the currency code string,
optional whitespace, and <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="REAL"/>
                        </mif:object> literal amount.
      </mif:p>
                     <mif:p>
For example, "USD189.95" is the literal for 189.95 U.S. Dollar.
      </mif:p>
                  </mif:text>
               </mif:designComments>
               <mif:otherAnnotation type="LiteralFormat">
                  <mif:data>
MO.literal ST {
  MO : currency value  { $.currency.equal($1); }
                         $.value.equal($2);
  CS currency : ST     { $.currency.value.equal($1);
                         $.currency.codeSystem
                            .equal(2.16.840.1.113883.6.9); }
  REAL value : REAL    { $.value.equal($1); }
};
      </mif:data>
               </mif:otherAnnotation>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="ST"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="CAL" title="Calendar" datatypeKind="Definition" visibility="private">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="SET">
            <mif:argumentDatatype name="CLCY"/>
         </mif:targetDatatype>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
A calendar is a concept of measuring time in various cycles. Such
cycles are years, months, days, hours, minutes, seconds, and
weeks. Some of these cycles are synchronized and some are not (e.g.,
weeks and months are not synchronized.)
      </mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
After "rolling the time axis" into these cycles (See the figure)
a calendar expresses a point in time as a sequence
of integer counts of cycles, e.g., for year, month, day, hour,
etc. The calendar is rooted in some conventional start point, called
the "epoch."
      </mif:p>
                  <mif:img imageType="application/jpeg" hl7Id="CAL" src="datyp2fig9.jpg"
                           alt="Calendar Cycle"/>
                  <mif:p>
A calendar "rolls" the time axis into a complex convolute according to
the calendar periods year (blue), month (yellow), day (green), hour
(red), etc. The cycles need not be aligned, for example, the week (not
shown) is not aligned to the month.<mif:object name="footnote">
Imagine a special clock that measures those cycles, where the pointers
are not all stacked on a common axis but each pointer is attached to
the end of the pointer measuring the next larger cycle.
            </mif:object>
                  </mif:p>
                  <mif:p>
Calendar is defined as a set of calendar cycles, and has a name and a
code. The head of the Calendar is the largest CalendarCycle appearing
right most in the calendar expression. The epoch is the beginning of
that calendar, i.e., the point in time where all calendar cycles are
zero.
      </mif:p>
                  <mif:p>
The calendar definition can be shown as in <mif:object name="conceptDomainRef">
                        <mif:param name="name" value="CalendarCycle"/>
                     </mif:object>
for the modern Gregorian calendar. The calendar definition table lists a
calendar cycle in each row. The calendar units are dependent on each other and
defined in the value column. The sequence column shows the relationship through
the next property. The other columns are as in the formal calendar cycle
definition.<mif:object name="footnote"> 
At present, the CalendarCycle properties sum and value are not
formally defined. The computation of calendar digits involves some
complex computation which to specify here would be hard to understand
and evaluate for correctness. Unfortunately, no standard exists that
would formally define the relationship between calendar expressions
and elapsed time since an epoch. ASN.1, the XML Schema Data Type
specification and SQL92 all refer to ISO 8601, however, ISO 8601 does
only specify the syntax of Gregorian calendar expressions, but not
their semantics. In this standard, we define the syntax and semantics
formally, however, we presume the semantics of the sum-, and
value-properties to be defined elsewhere.  
          </mif:object>
				              </mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
private type Calendar alias CAL specializes SET&lt;CLCY&gt;  {
  CS   name;
  CLCY head;
  TS   epoch;
};
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="name" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="true"
                    minimumMultiplicity="1"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Name"/>
         <mif:type name="CS"/>
      </mif:property>
      <mif:property name="head" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Head"/>
         <mif:type name="CLCY"/>
      </mif:property>
      <mif:property name="epoch" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Epoch"/>
         <mif:type name="TS"/>
      </mif:property>
      <mif:property name="equal" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The definition of equality for <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> is taken from the <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="DSET"/>
                        <mif:param name="isDatatypeQualifier" value="true"/>
                     </mif:object> data type.<mif:object name="footnote">
								This means that values of the type CAL and DSET&lt;CLCY&gt; may be equal.
							</mif:object>
					             </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="CAL"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="CLCY" title="CalendarCycle" datatypeKind="Definition"
                 visibility="private">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ANY"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>    
A calendar cycle defines one group of decimal digits in the calendar
expression. Examples for calendar cycles are year, month, day, hour,
minute, second, and week.
      </mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
A calendar cycle has a name and two codes, a one-letter code and a
two-letter code. The property <mif:b>ndigits</mif:b> is the number of
decimal digits occupied in the calendar expression. The property
<mif:b>start</mif:b> specifies where counting starts (i.e., at 0 or 1.)
The <mif:b>next</mif:b> property is the next lower cycle in the order of
the calendar expression. The max(<mif:b>t</mif:b>) property is the
maximum number of cycles at time <mif:b>t</mif:b> (max depends on the
time <mif:b>t</mif:b> to account for leap years and leap seconds.)  The
property value(<mif:b>t</mif:b>) is the integer number of cycles shown
in the calendar expression of time <mif:b>t</mif:b>. The property
sum(<mif:b>t</mif:b>, <mif:b>n</mif:b>) is the sum of <mif:b>n</mif:b>
calendar cycles added to the time <mif:b>t</mif:b>.
      </mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
private type CalendarCycle alias CLCY specializes ANY {
  CE    name;
  INT   ndigits;
  INT   start;
  CLCY next;
  INT   max(TS t);
  TS    sum(TS t, REAL r);
  INT   value(TS t);
};
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="name" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="true"
                    minimumMultiplicity="1"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Name"/>
         <mif:type name="CE"/>
      </mif:property>
      <mif:property name="ndigits" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Number Of Digits"/>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="start" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Start"/>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="next" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Next"/>
         <mif:type name="CLCY"/>
      </mif:property>
      <mif:property name="max" sortKey="05" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Maximum"/>
         <mif:parameter name="t" sortKey="1">
            <mif:type name="TS"/>
         </mif:parameter>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="sum" sortKey="06" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Sum"/>
         <mif:parameter name="t" sortKey="1">
            <mif:type name="TS"/>
         </mif:parameter>
         <mif:parameter name="r" sortKey="2">
            <mif:type name="REAL"/>
         </mif:parameter>
         <mif:type name="TS"/>
      </mif:property>
      <mif:property name="value" sortKey="07" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Value"/>
         <mif:parameter name="t" sortKey="1">
            <mif:type name="TS"/>
         </mif:parameter>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="equal" sortKey="08" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						Two nonNull <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>s are equal if they have the same ndigits, start, and next.
					</mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="CLCY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="TS" title="PointInTime" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QTY"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
A quantity specifying a point on the axis of natural time. A point
in time is most often represented as a calendar expression.
    </mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
Semantically, however, time is independent from calendars and best
described by its relationship to elapsed time (measured as a physical
quantity in the dimension of time.)  A point in time plus an elapsed
time yields another point in time.  Inversely, a point in time minus
another point in time yields an elapsed time.
    </mif:p>
                  <mif:p>
As nobody knows when time began, a point in time is conceptualized as
the amount of time that has elapsed from some arbitrary zero-point,
called an epoch.  Because there is no absolute zero-point on the time
axis natural time is a difference-scale quantity, where only
differences are defined but no ratios. (For example, no point in time
is — absolutely speaking — "twice as late" as another
point in time.)
    </mif:p>
                  <mif:p>
Given some arbitrary zero-point, one can express any point in time as
an elapsed time measured from that offset. Such an arbitrary
zero-point is called an epoch. This epoch-offset form is used as a
semantic representation here, without implying that any system would
have to implement the TS data type in that way. Systems that do not
need to compute distances between points in time will not need any
other representation than a calendar expression literal.
    </mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type PointInTime alias TS specializes QTY {
            PQ  offset;
            CS  calendar;
            INT precision;
            PQ  timezone;
            TS plus(QTY x);
     literal   ST;
};
    </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="offset" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Offset from Epoch"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The elapsed time since any constant epoch, measured as a physical
quantity in the dimension of time (i.e., comparable to one second.)
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
It is not necessary for this specification to define a canonical
epoch; the semantics is the same for any epoch, as long as the epoch
is constant.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="PQ"/>
      </mif:property>
      <mif:property name="equal" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
Two point-in-time values are equal if and only if their offsets
(relative to the same epoch) are equal.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ANY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="calendar" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="GREG"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Calendar"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A code specifying the calendar used in the literal representation of
this point in time.<mif:object name="footnote">
At this time, no other calendars than the Gregorian calendar are
defined. However, the notion of a calendar as an arbitrary convention
to specify absolute time is important to properly define the semantics
of time and time-related data types. Furthermore, other calendars
might be supported when needed to facilitate HL7's use in other
cultures.
          </mif:object>
						            </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
The purpose of this property is mainly to faithfully convey what has
been entered or seen by a user in a system originating such a
point-in-time value. The calendar property also advises any system
rendering a point-in-time value into a literal form of which calendar
to use. However, this is only advice; any system that renders
point-in-time values to users may choose to use the calendar and
literal form demanded by its users rather than the calendar mentioned
in the calendar property. Hence, the calendar property is not constant
in communication between systems, the calendar is not part of the
equality test.
      </mif:p>
                     <mif:p>
For the purpose of defining the relationship between calendar
expression and epoch/offset form, two private data types, Calendar
(CAL) and CalendarCycle (CLCY,) are defined. These calendar data types
exist only for defining this specification. These private data types
may not be used at all outside this specification.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="Calendar"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="precision" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Precision of the Calendar Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The number of significant digits of the calendar expression
representation.
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
Precision is formally defined based on the <mif:object name="propertyRef">
                           <mif:param name="datatypeName" value="TS"/>
                           <mif:param name="propertyName" value="literal"/>
                        </mif:object>
						               </mif:p>
                     <mif:p>
The precision attribute is only the precision of a decimal digit
representation, <mif:b>not the accuracy of the point in time
value</mif:b>.
      </mif:p>
                     <mif:p>
The purpose of the precision property for the point in time data type
is to faithfully capture the whole information presented to humans in
a calendar expression. The number of digits shown conveys information
about the uncertainty (i.e., precision and accuracy) of a measured
point in time.
      </mif:p>
                     <mif:p>
The precision property is dependent on the calendar. A given precision
value relative to one calendar does not mean the same in another
calendar with different periods.
      </mif:p>
                     <mif:p>
For example "20000403" has 8 significant digits <mif:b>in the
representation</mif:b>, but the <mif:b>uncertainty of the value</mif:b>
may be in any digit shown or not shown, i.e., the uncertainty may be
to the day, to the week, or to the hour. Note that external
representations <mif:b>should</mif:b> adjust their representational
precision with the uncertainty of the value. However, since the
precision in the digit string depends on the calendar and is granular
to the calendar periods, uncertainty may not fall into that grid
(e.g., 2000040317 is an adequate representation for the value between
2000040305 and 2000040405.)
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="timezone" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1">
         <mif:businessName name="Timezone Offset"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The difference between the local time in that time zone and Universal
Coordinated Time (UTC, formerly called Greenwich Mean Time, GMT). The
time zone is a physical quantity in the dimension of time (i.e.,
comparable to one second.)  A zero time zone value specifies UTC. The
time zone value does not permit conclusions about the geographical
longitude or a conventional time zone name.
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
For example, 200005121800-0500 may be eastern standard time (EST) in
Indianapolis, IN, or central daylight savings time (CDT) in Decatur,
IL. Furthermore in other countries having other latitude the time
zones may be named differently.
      </mif:p>
                     <mif:p>
When the time zone is NULL (unknown), "local time" is
assumed. However, "local time" is always local to some place, and
without knowledge of that place, the time zone is unknown. Hence, a
local time cannot be converted into UTC. The time zone should be
specified for all point in time values in order to avoid a significant
loss of precision when points in time are compared. The difference of
two local times where the locality is unknown has an error of
±12 hours.
      </mif:p>
                     <mif:p>
In administrative data context, some time values do not carry a time
zone. For a date of birth in administrative data, for example, it
would be incorrect to specify a time zone, since this may effectively
change the date of birth when converted into other time zones. For
such administrative data the time zone is NULL (not applicable.)
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="PQ"/>
      </mif:property>
      <mif:property name="diffType" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="DifferenceDataType"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
The difference between 2 points in time is a physical quantity.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:type name="TYPE"/>
      </mif:property>
      <mif:property name="plus" sortKey="07" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Addition"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A point in time plus an elapsed time (i.e., physical quantity in the
dimension of time) is a point in time.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QTY"/>
         </mif:parameter>
         <mif:type name="TS"/>
      </mif:property>
      <mif:property name="minus" sortKey="08" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Difference"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The difference between two points in time is an elapsed time.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="TS"/>
         </mif:parameter>
         <mif:type name="QTY"/>
      </mif:property>
      <mif:property name="literal" sortKey="09" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
Point-in-time literals are simple calendar expressions, as defined by
the calendar definition table. By default, the western (Gregorian)
calendar shall be used (<mif:object name="conceptDomainRef">
                           <mif:param name="name" value="CalendarCycle"/>
                        </mif:object>).
      </mif:p>
                     <mif:p>
For the default Gregorian calendar the calendar expression literals of
this specification conform to the constrained ISO 8601 that is defined
in ISO 8824 (ASN.1) under clause 32 (generalized time) and to the HL7
version 2 <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="TS"/>
                        </mif:object> data format.
      </mif:p>
                     <mif:p>
Calendar expression literals are sequences of integer numbers ordered
according to the "Counter/ord." column of <mif:object name="conceptDomainRef">
                           <mif:param name="name" value="CalendarCycle"/>
                        </mif:object>.
Periods with lower order numbers stand to the left of periods with higher order
numbers. Periods with no assigned order number cannot occur in the calendar
expression for points in time.
      </mif:p>
                     <mif:p>
The "Counter/digits" column of <mif:object name="conceptDomainRef">
                           <mif:param name="name" value="CalendarCycle"/>
                        </mif:object>
specifies the exact number of digits for the counter number for any
period.
      </mif:p>
                     <mif:p>
Thus, <mif:object name="conceptDomainRef">
                           <mif:param name="name" value="CalendarCycle"/>
                        </mif:object> specifies that western
calendar expressions begin with the 4-digit year (beginning counting
at zero); followed by the 2-digit month of the year (beginning
counting at one); followed by the 2-digit day of the month (beginning
with one); followed by the 2-digit hour of the day (beginning with
zero); and so forth. For example, "200004010315" is a valid expression
for April 1, 2000, 3:15 am.
      </mif:p>
                     <mif:p>
A calendar expression can be of variable precision, omitting parts
from the right.
      </mif:p>
                     <mif:p>
For example, "20000401" is precise only to the day of the month.
      </mif:p>
                     <mif:p>
The least defined calendar period (i.e. the second) may be written as
a real number, with the number of integer digits specified, followed
by the decimal point and any number of fractional digits.
      </mif:p>
                     <mif:p>
For example, "20000401031520.34" means April 1, 2000, 3:15 and 20.34
seconds.
      </mif:p>
                     <mif:p>
When other calendars will be used in the future, a prefix "GREG:" can
be placed before the western (Gregorian) calendar expression to
disambiguate from other calendars. Each calendar shall have its own
prefix. However, the western calendar is the default if no prefix is
present.
      </mif:p>
                     <mif:p>
In the modern Gregorian calendars (and all calendars where time of day
is based on UTC,) the calendar expression may contain a time zone
suffix. The time zone suffix begins with a plus (+) or minus (-)
followed by digits for the hour and minute cycles. UTC is designated
as offset "+00" or "-00"; the ISO 8601 and ISO 8824 suffix "Z" for UTC
is not permitted.
      </mif:p>
                  </mif:text>
               </mif:designComments>
               <mif:otherAnnotation type="LiteralFormat">
                  <mif:data>
TS.literal ST {
  TS : cal timestamp($1)              { $.equal($2); }
     | timestamp(GREG)                { $.equal($1); };

  TS timestamp(Calendar C)
  : cycles(C.head, C.epoch) zone(C)   { $.equal($1.minus($2)); }
                                        $.timezone.equal($2); }
  | cycles(C.head, C.epoch)           { $.equal($1);
                                        $.timezone.unknown; };
  Calendar cal
  : /[a-zA-Z_][a-zA-Z0-9_]*:/         { $.equal($1); };
  TS cycles(CalendarCycle c, TS t)
  : cycle(c, t) cycles(c.next, $1)    { $.equal($2); }
  | cycle(c, t) "." REAL.fractional   { $.equal(c.sum($1, $3));
                                        $.precision.equal(
                                          t.precision.plus($3.precision)); }
  | cycle(c, t)                       { $.equal($1); };
  TS cycle(CalendarCycle c, TS t)
  : /[0-9]{c.ndigits}/                { $.equal(c.sum(t, $1));
                                        $.precision.equal(
                                          t.precision.plus(c.ndigits)); };
  PQ zone(Calendar C)
  : "+" cycles(C.zonehead, C.epoch)   { $.equal($2.minus(C.epoch)); }
  | "-" cycles(C.zonehead, C.epoch)   { $.equal(C.epoch.minus($2)); };
};
      </mif:data>
               </mif:otherAnnotation>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="ST"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="SET" title="Set" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ANY"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
A value that contains other distinct values in no particular order.
    </mif:text>
            </mif:definition>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;ANY T&gt;
type Set&lt;T&gt; alias SET&lt;T&gt; specializes ANY {
            BL      contains(T element);
            BL      contains(SET&lt;T&gt; subset);
            BL      isEmpty;
            BL      notEmpty;
            INT     cardinality;
            SET&lt;T&gt;  union(SET&lt;T&gt; otherset);
            SET&lt;T&gt;  union(T element);
            SET&lt;T&gt;  except(T element);
            SET&lt;T&gt;  except(SET&lt;T&gt; otherset);
            SET&lt;T&gt;  intersection(SET&lt;T&gt; otherset);
  literal   ST;
  promotion SET&lt;T&gt;  (T x);
            IVL&lt;T&gt;  hull;
};
    </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="ANY"/>
      </mif:parameter>
      <mif:property name="contains" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Contains Element"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A relation of the set with its elements, true if the given value is an
element of the set.
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
This is the primitive semantic property of a set, based on which all
other properties are defined.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text>
A set may only contain distinct non-NULL elements. Exceptional values
(NULL-values) cannot be elements of a set.
        </mif:text>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(SET&lt;T&gt; s, T n) where s.nonNull.and(n.isNull) {
  s.contains(n).not;
};
        </mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="element" sortKey="1">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="contains" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Contains Subset"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The relation between a set and its subsets, where each element in the
subset is also an element of the superset.
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
This implies that the empty set is a subset of every set including
itself.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="subset" sortKey="1">
            <mif:type name="SET">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:type>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="isEmpty" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="The Empty Set"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>          
A predicate indicating that this set has no elements (negation of the
<mif:object name="propertyRef">
                        <mif:param name="datatypeName" value="SET"/>
                        <mif:param name="propertyName" value="notEmpty"/>
                     </mif:object>. The
empty set is a proper set value, <mif:b>not</mif:b> an exceptional
(NULL) value.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="notEmpty" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Not-Empty"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text> 
A predicate indicating that this set contains elements.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="cardinality" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Cardinality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>      
The cardinality of a set is the number of distinct elements in the set.    
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
The cardinality definition is not sufficient since it doesn't converge
for uncountably infinite sets (<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="REAL"/>
                        </mif:object>, <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="PQ"/>
                        </mif:object>, 
etc.) and it doesn't terminate for infinite sets. In
addition, the definition of integer number type in this specification
is incomplete for these cases, as it doesn't account for
infinities. Finally the cardinality value is an example where it would
be necessary to distinguish the cardinality ℵ<mif:sub>0</mif:sub> 
(<mif:b>aleph</mif:b>
							                 <mif:sub>0</mif:sub>) of
countably infinite sets (e.g., <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="INT"/>
                        </mif:object>) from
ℵ<mif:sub>1</mif:sub> (<mif:b>aleph</mif:b>
							                 <mif:sub>1</mif:sub>), the cardinality of uncountable sets 
              (e.g., <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="REAL"/>
                        </mif:object>, <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="PQ"/>
                        </mif:object>).
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="union" sortKey="06" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:businessName name="Union"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>          
A union of two sets (component sets) is a set where each of the
union's elements also is an element of either one component set.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="otherset" sortKey="1">
            <mif:type name="SET">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:type>
         </mif:parameter>
         <mif:type name="SET">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="union" sortKey="07" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:businessName name="Include Element"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>          
A union of a set and an element.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="element" sortKey="1">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:type name="SET">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="except" sortKey="08" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:businessName name="Exclude Element"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>          
The difference between this set and an element value is the set
that contains all elements of this set except for the subtracting
element value. If the element value is not contained in this set,
the difference is equal to this set.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="element" sortKey="1">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:type name="SET">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="except" sortKey="09" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:businessName name="Set Difference"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The difference of this set and its subtracting set is the set that
contains all elements of this set that are not elements of the
subtracting set.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="otherset" sortKey="1">
            <mif:type name="SET">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:type>
         </mif:parameter>
         <mif:type name="SET">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="intersection" sortKey="10" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:businessName name="Intersection"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>          
The intersection between two sets is a set containing all and only
those elements that are contained in both of the operand sets.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="otherset" sortKey="1">
            <mif:type name="SET">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:type>
         </mif:parameter>
         <mif:type name="SET">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="literal" sortKey="11" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
When the element type T has a literal form, the set of T elements has
a literal form, wherein the elements of the set are enumerated within
curly braces and separated by semicolon characters.
      </mif:p>
                     <mif:table width="90%" hl7Id="table-SET.literal.example">
                        <mif:caption>Example</mif:caption>
                        <mif:thead>
                           <mif:tr>
                              <mif:th>literal</mif:th>
                              <mif:th>meaning</mif:th>
                           </mif:tr>
                        </mif:thead>
                        <mif:tbody>
                           <mif:tr>
                              <mif:td>{1; 3; 5; 7; 19}</mif:td>
                              <mif:td>a set of integer numbers or real numbers</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>{3; 1; 5; 19; 7}</mif:td>
                              <mif:td>the same set of integer numbers or real numbers</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>{1.2 m; 2.67 m; 17.8 m}</mif:td>
                              <mif:td>a set of discrete physical quantities</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>{apple; orange; banana}</mif:td>
                              <mif:td>a set of character strings</mif:td>
                           </mif:tr>
                        </mif:tbody>
                     </mif:table>
                  </mif:text>
               </mif:designComments>
               <mif:otherAnnotation type="LiteralFormat">
                  <mif:data>
SET&lt;T&gt;.literal ST {
  SET&lt;T&gt; : "{" elements "}"   { $.equal($2); };
  SET&lt;T&gt; elements
        : elements ";" T      { $.except($2).equal($1); }
        | T                   { $.contains($1);
                                $.except($1).isEmpty; };
};
      </mif:data>
               </mif:otherAnnotation>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="promotion" sortKey="12" propertyKind="promotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:businessName name="Promotion of Element Values to Sets"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
A data value of type T can be promoted into a trivial set of T with
that data value as its only element.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:type name="SET">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="hull" sortKey="13" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Convex Hull of Totally Ordered Sets"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
Sets of quantities may be totally ordered sets when there is an order
relationship defined between any two elements in the set. Note that
"ordered set" does not mean the same as Sequence (<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="LIST"/>
                        </mif:object>). 
For example, the set {3; 2; 4; 88; 1} is an ordered
set. The ordering of the elements in the set notation is still
irrelevant, but elements can be compared to establish an order (1; 2;
4; 88).
      </mif:p>
                     <mif:p>
Totally ordered sets have convex hull. A convex hull of a totally
ordered set <mif:b>S</mif:b> is the smallest interval that is a superset
of <mif:b>S</mif:b>. This concept is going to be important later on.
      </mif:p>
                     <mif:p>
Note that hull is defined if and only if the <mif:b>actual</mif:b> set
is a totally ordered set. The data type of the elements itself need
not be totally ordered. For example, the data type <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="PQ"/>
                        </mif:object> is 
only partially ordered (since only quantities of the
same kind can be compared), but a 
<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="SET"/>
                        </mif:object>&lt;<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="PQ"/>
                        </mif:object>&gt; may still be totally 
ordered (if it contains only
comparable quantities.) For example, the convex hull of {4 s, 20 s, 55
s} is [4 s;55 s]; the convex hull of {"apples"; "oranges"; "bananas"}
is undefined because the elements have no order relationship among
them; and the convex hull of {2 m; 4 m; 8 s} is likewise undefined,
because it is not <mif:b>totally</mif:b> ordered (seconds are not
comparable with meters.)
</mif:p>
                     <mif:img imageType="application/jpeg" src="datyp2fig11.jpg"
                              alt="Convex Hull of a Totally Ordered Set"/>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="IVL">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="LIST" title="Sequence" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ANY"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
A value that contains other discrete (but not necessarily distinct) values in a defined sequence. 
    </mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
A sequence may contain NULL values as items.
    </mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;ANY T&gt;
type Sequence&lt;T&gt; alias LIST&lt;T&gt; specializes ANY {
            T         head;
            LIST&lt;T&gt;   tail;
            BL        isEmpty;
            BL        notEmpty;
	    T         item(INT index);
            BL        contains(T item);
            INT       length;
  literal   ST;
  promotion LIST&lt;T&gt;   (T x);
};
    </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="ANY"/>
      </mif:parameter>
      <mif:property name="head" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Head Item"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The first item in this sequence. The <mif:object name="itemName">
                        <mif:param name="item" value="property"/>
                     </mif:object> is a definitional
property for the semantics of the sequence.  
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="T" qualifier="parameter"/>
      </mif:property>
      <mif:property name="tail" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:businessName name="Tail Sequence"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The sequence following the first item in this sequence. The
<mif:object name="itemName">
                        <mif:param name="item" value="property"/>
                     </mif:object> is a definitional property for the semantics of the
sequence.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="LIST">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="isEmpty" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Empty Sequence"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A predicate that is <mif:b>true</mif:b> if this sequence is an empty
sequence, i.e., if it contains no items.
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
Notice the difference between empty-sequence and NULL: an empty
sequence is a proper sequence, not a null-value.  

						</mif:p>
                     <mif:p>
Notice that head and tail being NULL is only a necessary condition but
not sufficient for determining an empty list, since a sequence may
contain NULL-values as items, this condition can mean that this list
has only a head item that happens to be NULL.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="notEmpty" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Not-Empty Sequence"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A predicate that is <mif:b>true</mif:b> if this sequence is
not-empty. Negation of <mif:object name="propertyRef">
                        <mif:param name="datatypeName" value="LIST"/>
                        <mif:param name="propertyName" value="isEmpty"/>
                     </mif:object>.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="item" sortKey="05" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Item by Index"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The item at the given sequential position (index) in the sequence. The
index zero refers to the first element (head) of the sequence.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="index" sortKey="1">
            <mif:type name="INT"/>
         </mif:parameter>
         <mif:type name="T" qualifier="parameter"/>
      </mif:property>
      <mif:property name="contains" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Contains Item"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A predicate that is <mif:b>true</mif:b> if this sequence contains the
given item value.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="item" sortKey="1">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="length" sortKey="07" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Length"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The number of elements in the sequence. NULL elements are counted as
regular sequence elements.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="equal" sortKey="08" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
Two lists are equal if and only if they are both empty, or if both
their head and their tail are equal.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ANY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="literal" sortKey="09" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
When the element type T has a literal form, the sequence <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="LIST"/>
                        </mif:object>&lt;T&gt; has a literal form. List elements
are enumerated, separated by semicolon, and enclosed in parentheses.
      </mif:p>
                     <mif:table width="90%" hl7Id="table-LIST.literal.example">
                        <mif:caption>Examples</mif:caption>
                        <mif:thead>
                           <mif:tr>
                              <mif:th>literal</mif:th>
                              <mif:th>meaning</mif:th>
                           </mif:tr>
                        </mif:thead>
                        <mif:tbody>
                           <mif:tr>
                              <mif:td>(1; 3; 5; 7; 19)</mif:td>
                              <mif:td>a sequence of integer numbers or real numbers</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>(3; 1; 5; 19; 7)</mif:td>
                              <mif:td>a different sequence of integer numbers or real numbers</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>(1.2 m; 17.8 m; 2.67 m)</mif:td>
                              <mif:td>a sequence of discrete physical quantities</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>(apple; orange; banana)</mif:td>
                              <mif:td>a sequence of character strings</mif:td>
                           </mif:tr>
                        </mif:tbody>
                     </mif:table>
                  </mif:text>
               </mif:designComments>
               <mif:otherAnnotation type="LiteralFormat">
                  <mif:data>
LIST&lt;T&gt;.literal ST {
  LIST&lt;T&gt;
  : "(" elements ")"        { $.equal($2); }
  | "(" ")"         { $.isEmpty; };
  LIST&lt;T&gt; elements
         : T ";" elements     { $.head.equal($1);
            $.tail.equal($3); }
         | T          { $.head.equal($1);
            $.tail.isEmpty; };
};
      </mif:data>
               </mif:otherAnnotation>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="promotion" sortKey="10" propertyKind="promotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:businessName name="Promotion of Item Values to Sequences"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
A data value of type T can be promoted into a trivial sequence of T with
that data value as its only item.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:type name="LIST">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="GLIST" title="GeneratedSequence" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="LIST"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
A periodic or monotone sequence of values generated from a few
parameters, rather than being enumerated. Used to specify regular
sampling points for biosignals.
    </mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
The item at a certain index in the list is calculated by performing an
integer division on the index (<mif:var>i</mif:var>) with the
<mif:object name="propertyRef">
                        <mif:param name="datatypeName" value="GLIST"/>
                        <mif:param name="propertyName" value="denominator"/>
                     </mif:object> (<mif:var>d</mif:var>) and then take that
value's remainder with the <mif:object name="propertyRef">
                        <mif:param name="datatypeName" value="GLIST"/>
                        <mif:param name="propertyName" value="period"/>
                     </mif:object>
(<mif:var>p</mif:var>). Multiply this value with the
<mif:object name="propertyRef">
                        <mif:param name="datatypeName" value="GLIST"/>
                        <mif:param name="propertyName" value="increment"/>
                     </mif:object> (<mif:var>Δx</mif:var>) and add to the
<mif:object name="propertyRef">
                        <mif:param name="datatypeName" value="GLIST"/>
                        <mif:param name="propertyName" value="head"/>
                     </mif:object> (<mif:var>x</mif:var>
					                <mif:sub>0</mif:sub>.)
    </mif:p>
                  <mif:blockquote>
                     <mif:p>
						                  <mif:var>x</mif:var>
						                  <mif:sub>
							                    <mif:var>i</mif:var>
						                  </mif:sub>
=
<mif:var>x</mif:var>
						                  <mif:sub>0</mif:sub>
+
<mif:var>Δx</mif:var>
×
(<mif:var>i</mif:var>/<mif:var>d</mif:var>)
mod <mif:var>p</mif:var>
					                </mif:p>
                  </mif:blockquote>
                  <mif:table width="90%" hl7Id="table-GLIST.example">
                     <mif:caption>Examples for Generated Sequences</mif:caption>
                     <mif:thead>
                        <mif:tr>
                           <mif:th>head</mif:th>
                           <mif:th>increment</mif:th>
                           <mif:th>denominator</mif:th>
                           <mif:th>period</mif:th>
                           <mif:th>meaning</mif:th>
                        </mif:tr>
                     </mif:thead>
                     <mif:tbody>
                        <mif:tr>
                           <mif:td>0</mif:td>
                           <mif:td>1</mif:td>
                           <mif:td>1</mif:td>
                           <mif:td>∞</mif:td>
                           <mif:td>The identity-sequence where each item is equal to its index.</mif:td>
                        </mif:tr>
                        <mif:tr>
                           <mif:td>198706052000</mif:td>
                           <mif:td>2 hour</mif:td>
                           <mif:td>1</mif:td>
                           <mif:td>∞</mif:td>
                           <mif:td>Sequence starting on June 5, 1987 at 7 PM and
          incrementing every two hours: 9 PM, 11 PM, 1 AM (June 6), 3
          AM, 5 AM, and so on.</mif:td>
                        </mif:tr>
                        <mif:tr>
                           <mif:td>0 V</mif:td>
                           <mif:td>1 mV</mif:td>
                           <mif:td>1</mif:td>
                           <mif:td>100</mif:td>
                           <mif:td>The x-wave of a digital oscillograph scanning between
          0 and 100 mV in 100 steps of 1 mV. The frequency is unknown
          from these data as we do not know how much time elapses
          between each step of the index.</mif:td>
                        </mif:tr>
                        <mif:tr>
                           <mif:td>2002072920300</mif:td>
                           <mif:td>100
          us</mif:td>
                           <mif:td>1</mif:td>
                           <mif:td>∞</mif:td>
                           <mif:td>A timebase from June 29,
          2002 at 8:30 PM with 100 us between each steps of the
          index. If combined with the previous generator as a second
          sampling dimension this would now describe our digital
          oscilloscope's x-timebase as 1 mV per 100 us. At 100 steps
          per period, the period is 10 ms, which is equal to a
          frequency of 100 Hz.</mif:td>
                        </mif:tr>
                        <mif:tr>
                           <mif:td>0 V</mif:td>
                           <mif:td>1 mV</mif:td>
                           <mif:td>100</mif:td>
                           <mif:td>100</mif:td>
                           <mif:td>Combining this generator to the previous two generators
          could describe a three-dimensional sampling space with two
          voltages and time. This generator also steps at 1 mV and has
          100 steps per period, however, it only steps every 100 index
          increments, so, the first voltage generator makes one full
          cycle before this generator is incremented. One can think of
          the two voltages as "rows" and "columns" of a "sampling
          frame". With the previous generator as the timebase, this
          results in a scan of sampling frames of 100 mV × 100
          mV with a framerate of 1 Hz.</mif:td>
                        </mif:tr>
                     </mif:tbody>
                  </mif:table>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;QTY T&gt;
type GeneratedSequence&lt;T&gt; alias GLIST&lt;T&gt; specializes LIST&lt;T&gt; {
        QTY     increment;
        INT     period;
	    INT     denominator;
};
    </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="QTY"/>
      </mif:parameter>
      <mif:property name="head" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Head Item"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
This is the start-value of the generated list.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="LIST"/>
         </mif:derivedFrom>
         <mif:type name="T" qualifier="parameter"/>
      </mif:property>
      <mif:property name="increment" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Increment"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The difference between one value and its previous different value.
For example, to generate the sequence (1; 4; 7; 10; 13; ...) the
increment is 3; likewise to generate the sequence (1; 1; 4; 4; 7; 7;
10; 10; 13; 13; ...) the increment is also 3.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="QTY"/>
      </mif:property>
      <mif:property name="period" sortKey="03" propertyKind="variableProperty" visibility="public"
                    defaultValue="∞"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Period Step Count"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
If non-NULL, specifies that the sequence alternates, i.e., after this
many increments, the sequence item values roll over to start from the
initial sequence item value. For example, the sequence (1; 2; 3; 1; 2;
3; 1; 2; 3; ...) has period 3; also the sequence (1; 1; 2; 2; 3; 3; 1;
1; 2; 2; 3; 3; ...) has period 3 too.
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
The period allows to repeatedly sample the same sample space.  The
"waveform" of this periodic generator is always a "saw", just like the
x-function of your oscilloscope.<mif:object name="footnote">
Note the difference to the . The  is
a generator for a &lt;&gt; not for a
&lt;&gt;.  A sequence of discrete
values from a continuous domain makes not much sense other than in sampling
applications. The &lt;&gt;, however,
can be thought of as a sequence of 
&lt;&gt;, which still is different from a
&lt;&gt;.
          ]
        </mif:object>
					                </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="denominator" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="1"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Denominator"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The the integer by which the index for the sequence is divided,
effectively the number of times the sequence generates the same
sequence item value before incrementing to the next sequence item
value. For example, to generate the sequence (1; 1; 1; 2; 2; 2; 3; 3;
3; ...)  the denominator is 3.
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
The use of the denominator is to allow multiple generated sequences to
periodically scan a multidimensional space. For example, an (abstract)
TV screen uses 2 such generators for the columns and rows of
pixels. For instance, if there are 200 scan lines and 320 raster
colunmns, the column-generator would have denominator 1 and the
line-generator would have denominator 320.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="INT"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="SLIST" title="SampledSequence" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="LIST"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
A sequence of sampled values scaled and translated from a list of
integer values.  Used to specify sampled biosignals.
    </mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
The item at a certain index (<mif:var>i</mif:var>) in the list is calculated
by multiplying the item at the same index in the
<mif:object name="propertyRef">
                        <mif:param name="datatypeName" value="SLIST"/>
                        <mif:param name="propertyName" value="digits"/>
                     </mif:object> sequence
(<mif:var>d</mif:var>
					                <mif:sub>
						                  <mif:var>i</mif:var>
					                </mif:sub>) with the <mif:object name="propertyRef">
                        <mif:param name="datatypeName" value="SLIST"/>
                        <mif:param name="propertyName" value="scale"/>
                     </mif:object> (<mif:var>s</mif:var>)
          and then add that value to the <mif:object name="propertyRef">
                        <mif:param name="datatypeName" value="SLIST"/>
                        <mif:param name="propertyName" value="origin"/>
                     </mif:object>
(<mif:var>x</mif:var>
					                <mif:sub>
						                  <mif:var>o</mif:var>
					                </mif:sub> ).
    </mif:p>
                  <mif:blockquote>
                     <mif:p>
						                  <mif:var>x</mif:var>
						                  <mif:sub>
							                    <mif:var>i</mif:var>
						                  </mif:sub>
=
<mif:var>x</mif:var>
						                  <mif:sub>
							                    <mif:var>o</mif:var>
						                  </mif:sub>
+
<mif:var>s</mif:var>
×
<mif:var>d</mif:var>
						                  <mif:sub>
							                    <mif:var>i</mif:var>
						                  </mif:sub>
					                </mif:p>
                  </mif:blockquote>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;QTY T&gt;
type SampledSequence&lt;T&gt; alias SLIST&lt;T&gt; specializes LIST&lt;T&gt; {
  T         origin;
  QTY       scale;
  LIST&lt;INT&gt; digits;
};
    </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="QTY"/>
      </mif:parameter>
      <mif:property name="origin" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Scale Origin"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The origin of the list item value scale, i.e., the physical quantity
that a zero-digit in the sequence would represent.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="T" qualifier="parameter"/>
      </mif:property>
      <mif:property name="scale" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Scale Factor"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A ratio-scale quantity that is factored out of the digit sequence.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="QTY"/>
      </mif:property>
      <mif:property name="digits" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:businessName name="Sampled Digits"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
Ah sequence of raw digits for the sample values. This is typically the
raw output of an A/D converter.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="LIST">
            <mif:argumentDatatype name="INT"/>
         </mif:type>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="BAG" title="Bag" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ANY"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
An unordered collection of values, where each value can be contained
more than once in the collection.
    </mif:text>
            </mif:definition>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;ANY T&gt;
type Bag&lt;T&gt; alias BAG&lt;T&gt; specializes ANY {
            INT     contains(T kind);
            BL      isEmpty;
	    BL	    notEmpty;
            BAG&lt;T&gt;  plus(BAG&lt;T&gt; x);
            BAG&lt;T&gt;  minus(BAG&lt;T&gt; x);
  promotion BAG&lt;T&gt;  (T x);
};
    </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="ANY"/>
      </mif:parameter>
      <mif:property name="contains" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Contains Item"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>  
The number of items in this bag with the given item value.
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
This is the primitive semantic property of a bag, based on which all
other properties are defined. 
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="kind" sortKey="1">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="isEmpty" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="The Empty Bag"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>          
A predicate indicating that this bag has no elements (negation of the
<mif:object name="propertyRef">
                        <mif:param name="datatypeName" value="BAG"/>
                        <mif:param name="propertyName" value="notEmpty"/>
                     </mif:object> predicate. The empty bag is a
proper set value, <mif:b>not</mif:b> an exceptional (NULL) value.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="notEmpty" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Not-Empty"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text> 
A predicate indicating that this bag contains item.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="plus" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:businessName name="Addition"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>          
A bag that contains all items of the operand bags, i.e. the number of
items of each item value are added.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="BAG">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:type>
         </mif:parameter>
         <mif:type name="BAG">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="minus" sortKey="05" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:businessName name="Subtraction"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>          
A bags that contains all items of this bag (minuend) diminished by the
items in the other bag (subtrahend). Bags cannot carry deficits. When
the subtrahend contains more items of one value than the minuend, the
difference contais zero items of that value.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="BAG">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:type>
         </mif:parameter>
         <mif:type name="BAG">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="promotion" sortKey="06" propertyKind="promotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:businessName name="Promotion of Item Values to Bags"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
A data value of type T can be promoted into a trivial bag of type T
with that data value as its only item.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:type name="BAG">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="IVL" title="Interval" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="SET"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
A set of consecutive values of an ordered base data type.
    </mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
Any ordered type can be the basis of an interval; it does not matter
whether the base type is discrete or continuous. If the base data type
is only partially ordered, all elements of the interval must be
elements of a totally ordered subset of the partially ordered data
type.
    </mif:p>
                  <mif:p>
For example, physical quantities are considered ordered. However the
ordering of physical quantities is only partial; a total order is only
defined among comparable quantities (quantities of the same physical
dimension.)  While intervals between 2 and 4 meter exists, there is no
interval between 2 meters and 4 seconds.
    </mif:p>
                  <mif:p>
Intervals are sets and have all the properties of sets. However, union
and differences of intervals may not be intervals any more, since the
elements of these union and difference sets might not be
contiguous. Intersections of intervals are always intervals.
    </mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;QTY T&gt;
type Interval&lt;T&gt; alias IVL&lt;T&gt; specializes SET&lt;T&gt; {
            T       low;
            BL      lowClosed;
            T       high;
            BL      highClosed;
            QTY     width;
            T       center;
            IVL&lt;T&gt;  hull(IVL&lt;T&gt; x);
  literal   ST;
  promotion IVL&lt;T&gt;  (T x);
  demotion  T;
};
    </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="QTY"/>
      </mif:parameter>
      <mif:property name="low" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Low Boundary"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
This is the low limit of the interval.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="T" qualifier="parameter"/>
      </mif:property>
      <mif:property name="lowClosed" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="true"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Low Boundary Closed"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
Specifies whether the low limit is included in the interval
(interval is closed) or excluded from the interval (interval is open).
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="high" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="High Boundary"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
This is the high limit of the interval.
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="T" qualifier="parameter"/>
      </mif:property>
      <mif:property name="highClosed" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="true"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="High Boundary Closed"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
Specifies whether the high limit is included in the interval
(interval is closed) or excluded from the interval (interval is open).
      </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="width" sortKey="05" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Width"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The difference between high and low boundary. The purpose of
distinguishing a width property is to handle all cases of incomplete
information symmetrically. In any interval representation only two of
the three properties high, low, and width need to be stated and the
third can be derived.
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
When both boundaries are known, width can be derived as high minus
low. When one boundary and the width is known, the other boundary is
also known. When no boundary is known, the width may still be
known. For example, one knows that an activity takes about 30 minutes,
but one may not yet know when that activity is started.
      </mif:p>
                     <mif:p>
Note that the data type of the width is not always the same as for the
boundaries. For ratio scale quantities (REAL, PQ, MO) it is the
same. For difference scale quantities (e.g., TS) is the data type
of the difference (e.g., PQ in the dimension of time for TS). For
discrete elements (INT) the width may be a REAL indicating the number
of elements in the interval divided by 2.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="QTY"/>
      </mif:property>
      <mif:property name="center" sortKey="06" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Central Value"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The arithmetic mean of the interval (low plus high divided by 2). The
purpose of distinguishing the center as a semantic property is for
conversions of intervals from and to point values.
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
Note that a center doesn't always exist for every interval.
Notably intervals that are infinite on one side do not have
a center. Also intervals of discrete base types with an
even number of elements do not have a center. If an interval
is unknown on one (or both) boundaries, the center can still
be asserted. In fact, the main use case for the center is
to be asserted when no boundary is known.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="T" qualifier="parameter"/>
      </mif:property>
      <mif:property name="hull" sortKey="07" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Convex Hull"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							A convex hull or "interval hull" of two <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>s is the least
							<mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> that is a superset of its operands.
						</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:img imageType="application/jpeg" src="datyp2fig12.jpg"
                              alt="Convex Hull of two Intervals"/>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="IVL">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:type>
         </mif:parameter>
         <mif:type name="IVL">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="literal" sortKey="08" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
The literal form for the interval data type is defined such that it is
as intuitive to humans as possible. Five different forms are
defined:<mif:object name="footnote">
The presence of so many options deserves explanation. In principle,
the interval form together with the width-only form would be
sufficient. However, the interval form is felt alien to many in the
field of medical informatics. One important purpose of the literal
forms is to eradicate non-compliance through making compliance easy,
without compromising on the soundness of the concepts.
          
Furthermore, the different literal forms all have strength and
weaknesses. The interval and center-width forms' strength is that they
are most exact, showing closed and open boundaries. The interval
form's weakness, however, is that infinite boundaries require special
symbols for infinities, not necessary in the "comparator" form. The
center-width form cannot specify intervals with an infinite boundary
at all. The "comparator" form, however, can only represent
single-bounded intervals (i.e., where the other boundary is infinite
or unknown.)  The dash form, while being the weakest of all, is the
most intuitive form for double bounded intervals.
          </mif:object>
						               </mif:p>
                     <mif:ol>
                        <mif:li>
                           <mif:p>
the interval form using square brackets, e.g., "[3.5; 5.5[";
          </mif:p>
                        </mif:li>
                        <mif:li>
                           <mif:p>
the dash-form, e.g., "3.5-5.5";
          </mif:p>
                        </mif:li>
                        <mif:li>
                           <mif:p>
the "comparator" form, using relational operator symbols, e.g., "&lt;5.5";
          </mif:p>
                        </mif:li>
                        <mif:li>
                           <mif:p>
the center-width form, e.g., "4.5[2.0[".
          </mif:p>
                        </mif:li>
                        <mif:li>
                           <mif:p>
the width-only form using square brackets, e.g., "[2.0[".
          </mif:p>
                        </mif:li>
                     </mif:ol>
                  </mif:text>
               </mif:designComments>
               <mif:otherAnnotation type="LiteralFormat">
                  <mif:data>
IVL&lt;T&gt;.literal ST {
  IVL&lt;T&gt; range
  : interval                { $.equal($1); }
  | dash                    { $.equal($1); }
  | comparator              { $.equal($1); }
  | center_width            { $.equal($1); }
  | width                   { $.equal($1); };

  IVL&lt;T&gt; interval
  : open T ";" T close;     { $.low.equal($2);
                              $.high.equal($4);
                              $.lowClosed.equal($1);
                              $.highClosed.equal($5); };
  BL open : "["             { $.equal(true); }
          | "]"             { $.equal(false); };
  BL close : "]"            { $.equal(true); }
           | "["            { $.equal(false); };
  IVL&lt;T&gt; width
     : open T.diffType close   { $.width.equal($2);
                              $.lowClosed.equal($1);
                              $.highClosed.equal($3); };
  IVL&lt;T&gt; center_width
  : T width                 { $.center.equal($1);
                              $.width.equal($2.width);
                              $.lowClosed.equal($2.lowClosed);
                              $.highClosed.equal($2.highClosed); };
  IVL&lt;T&gt; dash : T "-" T;    { $.low.equal($2);
                              $.high.equal($4);
                              $.lowClosed.equal(true);
                              $.highClosed.equal(true); };
  IVL&lt;TS&gt; comparator
  : "&lt;"  T                  { $.high.equal(T);
                              $.high.closed(false);
                              $.low.negativelyInfinite; }
  | "&gt;"  T                  { $.low.equal(T);
                              $.low.closed(false);
                              $.high.positivelyInfinite; }
  | "&lt;=" T                  { $.high.equal(T);
                              $.high.closed(true);
                              $.low.negativelyInfinite; }
  | "&gt;=" T                  { $.low.equal(T);
                              $.low.closed(true);
                            $.high.positivelyInfinite; };
};
      </mif:data>
               </mif:otherAnnotation>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="promotion" sortKey="09" propertyKind="promotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Promotion of Element Values to Intervals"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
A quantity of type T can be promoted into a trivial interval of T
where low and high boundaries are equal and boundaries closed.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:type name="IVL">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="demotion" sortKey="10" propertyKind="demotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Demotion of Intervals to a Representative Element Value"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
An interval of T can be demoted to a simple quantity of type T that is
representative for the whole interval. If both boundaries are finite,
this is the <mif:object name="propertyRef">
                           <mif:param name="datatypeName" value="IVL"/>
                           <mif:param name="propertyName" value="center"/>
                        </mif:object>. If one boundary is
infinite, the representative value is the other boundary. If both
boundaries are infinite, the conversion to a point value is not
applicable.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="T" qualifier="parameter"/>
      </mif:property>
      <mif:property name="hull" sortKey="11" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Convex Hull"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A convex hull or "interval hull" of two intervals is the least
interval that is a superset of its operands. This concept will play an
important role later on.
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:img imageType="application/jpeg" src="datyp2fig12.jpg"
                              alt="Convex Hull of two Intervals"/>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="SET"/>
         </mif:derivedFrom>
         <mif:type name="IVL">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="IVL_PQ" title="Interval&lt;PhysicalQuantity&gt;" datatypeKind="Binding"
                 visibility="public">
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
A set of consecutive values of physical quantities.
    </mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
An interval of physical quantities is constructed from the generic
interval type. However, recognizing that the unit can be factored from
the boundaries, we add additional semantics and a separate literal
form. The additional view of an interval of physical quantities is an
interval of real numbers with one unit.
      </mif:p>
                  <mif:p>
The unit applies to both low and high boundary.
      </mif:p>
                  <mif:p>
The special literal form is simply an interval of real numbers a space
and the unit.
      </mif:p>
                  <mif:p>
For example: "[0;5] mmol/L" or "&lt;20 mg/dL" are valid literal forms
of intervals of physical quantities. The generic interval form, e.g.,
"[50 nm; 2 m]" is also allowed.
      </mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type Interval&lt;PhysicalQuantity&gt; alias IVL&lt;PQ&gt; specializes IVL&lt;T&gt; {
  IVL&lt;REAL&gt; value;
  CS  unit;
};
      </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:binding>
         <mif:targetDatatype name="IVL"/>
         <mif:argumentDatatype name="PQ"/>
      </mif:binding>
      <mif:property name="value" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Value"/>
         <mif:type name="IVL">
            <mif:argumentDatatype name="REAL"/>
         </mif:type>
      </mif:property>
      <mif:property name="unit" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Unit"/>
         <mif:type name="CS"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="IVL_TS" title="Interval&lt;PointInTime&gt;" datatypeKind="Binding"
                 visibility="public">
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
A set of consecutive values of time-stamps.
    </mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
The generic interval data type defines the interval of points in time
too. However, there are some special considerations about literal
representations and conversions of intervals of point in time, which
are specified in this section.
      </mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type Interval&lt;PointInTime&gt; alias IVL&lt;TS&gt; specializes IVL&lt;T&gt; {
  promotion IVL&lt;TS&gt; (TS x);
};
      </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:binding>
         <mif:targetDatatype name="IVL"/>
         <mif:argumentDatatype name="TS"/>
      </mif:binding>
      <mif:property name="literal" sortKey="01" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
The literal form for interval of point in time is exceptional.
        </mif:p>
                     <mif:ul>
                        <mif:li>
                           <mif:p>The "dash form" is not allowed for intervals of point in time</mif:p>
                        </mif:li>
                        <mif:li>
                           <mif:p>A "hull form" is defined instead</mif:p>
                        </mif:li>
                     </mif:ul>
                     <mif:p>
In order to avoid syntactic conflicts with the timezone and slightly
different usage profiles of the ISO 8601 that occur on some ITS
platforms, <mif:b>the dash form of the interval is not
permitted for </mif:b>
						                  <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="IVL"/>
                        </mif:object>&lt;<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="TS"/>
                        </mif:object>&gt;. The
interval-form using square brackets is preferred.
        </mif:p>
                     <mif:p>
Example: May 12, 1987 from 8 to 9:30 PM is 
"<mif:code>[198705122000;198705122130]</mif:code>".
        </mif:p>
                     <mif:p>
The "hull-form" of the literal is defined as the convex hull (see
<mif:object name="propertyRef">
                           <mif:param name="datatypeName" value="IVL"/>
                           <mif:param name="propertyName" value="hull"/>
                        </mif:object>) of interval-promotions from two time
stamps.
        </mif:p>
                     <mif:p>
For example, "<mif:code>19870901..19870930</mif:code>" is a valid literal
using the hull form. The value is equivalent to the interval form
"<mif:code>[19870901;19871001[</mif:code>".  <mif:object name="footnote"> 
The hull form may appear superfluous for the simple interval all by
itself. However, the hull form will become important for the periodic
interval notation as it shortens the notation and (perhaps arguably)
makes the notation of more complex timing structures more intuitive.
            </mif:object>
					                </mif:p>
                     <mif:p>
The hull-form further allows an abbreviation, where the higher
timestamp literal does not need to repeat digits on the left that are
the same as for the lower timestamp literal. The two timestamps are
right-aligned and the digits to the left copied from the lower to the
higher timestamp literal. This is a simple string operation and is not
formally defined here.
        </mif:p>
                     <mif:p>
Example: May 12, 1987 to May, 23, 1987 is
"<mif:code>19870512..23</mif:code>". However, note that May 12, 1987 to June
2, 1987 is "<mif:code>19870512..0602</mif:code>", and not
"<mif:code>20000512..02</mif:code>".
        </mif:p>
                  </mif:text>
               </mif:designComments>
               <mif:otherAnnotation type="LiteralFormat">
                  <mif:data>
  IVL&lt;TS&gt; hull : TS ".." TS
    { $.equal(((IVL&lt;TS&gt;)$1)
        .hull((IVL&lt;TS&gt;)$3)); };
        </mif:data>
               </mif:otherAnnotation>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="IVL"/>
         </mif:derivedFrom>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="promotion" sortKey="02" propertyKind="promotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Promotion of Points in Time Values to Intervals"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
A <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="TS"/>
                        </mif:object> can be promoted to an <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="IVL"/>
                        </mif:object>
&lt;<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="TS"/>
                        </mif:object>&gt; whereby the low boundary is
the <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="TS"/>
                        </mif:object> value itself, and the width is inferred from
the precision of the <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="TS"/>
                        </mif:object> and the duration of the
least significant calendar period specified. The high boundary is
open. For example, the <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="TS"/>
                        </mif:object> literal "200009" is
converted to an <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="IVL"/>
                        </mif:object>&lt;<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="TS"/>
                        </mif:object>&gt; with low
boundary 200009 and width 30 days, which is the interval
"[200009;200010[".
        </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:type name="IVL">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:type>
            <mif:targetDatatype name="IVL"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="TS"/>
         </mif:parameter>
         <mif:type name="IVL">
            <mif:argumentDatatype name="TS"/>
         </mif:type>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="HXIT" title="HistoryItem" datatypeKind="Definition"
                 visibility="protected">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="T" qualifier="parameter"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
A generic data type extension that tags a time range to any data value
of any data type.  The time range is the time in which the information
represented by the value is (was) valid.
    </mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
If the base type T does not possess a validTime property, the
<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="HXIT"/>
                     </mif:object> adds that property to the base type. If, however,
the base type T does have a valid time property (currently only EN),
that property is mapped to the valid time property of the
<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="HXIT"/>
                     </mif:object>.<mif:object name="footnote">
Note that data types are specifications of abstract properties of
values. This specification does not mandate how these values are
represented in an ITS or implemented in an application. Specifically,
it does not mandate how the represented components are named or
positioned. In addition, the semantic generalization hierarchy may be
different from a class hierarchy chosen for implementation (if the
implementation technology has inheritance.)  Keep the distinction
between a type (interface) and an implementation (concrete data
structure, class) in mind. The ITS must contain a mapping of ITS
defined features of any data type to the semantic properties defined
here.</mif:object>
				              </mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;ANY T&gt;
protected type HistoryItem&lt;T&gt; alias HXIT&lt;T&gt; specializes T {
    IVL&lt;TS&gt; validTime;
};
    </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="ANY"/>
      </mif:parameter>
      <mif:property name="validTime" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Valid Time"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The time interval during which the given information was, is, or is
expected to be valid. The interval can be open or closed infinite or
undefined on either side.
        </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="IVL">
            <mif:argumentDatatype name="TS"/>
         </mif:type>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="HIST" title="History" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="SET">
            <mif:argumentDatatype name="HXIT">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:argumentDatatype>
         </mif:targetDatatype>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
A set of data values that have a a valid-time property and thus
conform to the history item (HXIT) type. The history information is
not limited to the past; expected future values can also appear.
      </mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
The intent of the HIST data type is to capture the true historical
(and future) values of an item, rather than the audit trail of
values any given system has held for the item
      </mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;ANY T&gt;
type History&lt;T&gt; alias HIST&lt;T&gt; specializes SET&lt;HXIT&lt;T&gt;&gt; {
             HXIT&lt;T&gt;   earliest;
             HIST&lt;T&gt;      exceptEarliest;
             HXIT&lt;T&gt;   latest;
             HIST&lt;T&gt;      exceptLatest;
  demotion   HXIT&lt;T&gt;;
};
      </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="ANY"/>
      </mif:parameter>
      <mif:property name="earliest" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Earliest Item"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The item in the set whose valid time's low boundary (validity start
time) is less or equal (i.e. before) that of any other history item in
the set.
        </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="HXIT">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="exceptEarliest" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Except Earliest Item"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>	  
The derived history that has the earliest item excluded.
        </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="HIST">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="latest" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Latest Item"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The item in the set whose valid time's high boundary (validity end
time) is greater or equal (i.e. after) that of any other history item
in the set.
        </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="HXIT">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="exceptLatest" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Except Latest Item"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>	  
The derived history that has the latest item excluded.
        </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="HIST">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="demotion" sortKey="05" propertyKind="demotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Demotion of a History to a Single History Item"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
A type conversion between an entire history <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="HIST"/>
                        </mif:object>&lt;T&gt;
and a single history item <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="HXIT"/>
                        </mif:object>&lt;T&gt;. This conversion
takes the latest data from the history.
        </mif:p>
                     <mif:p>
The purpose of this conversion is to allow an information producer to
produce a history of any value instead of sending just one value. An
information-consumer, who does not expect a history but a simple
value, will convert the history to the latest value.
        </mif:p>
                     <mif:p>
Note from the definition of history item (<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="HXIT"/>
                        </mif:object>) that
<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="HXIT"/>
                        </mif:object> semantically specializes T. This means, that the
information-consumer expecting a T but given an <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="HXIT"/>
                        </mif:object>
extension of T will not recognize any difference (substitutability of
specializations.)
        </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="HXIT">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="UVP" title="UncertainValueProbabilistic" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="T" qualifier="parameter"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
A generic data type extension used to specify a probability expressing
the information producer's belief that the given value holds.
    </mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
How the probability number was arrived at is outside the scope of this
specification.
    </mif:p>
                  <mif:p>
Probabilities are subjective and (as any data value) must be
interpreted in their individual context, for example, when new
information is found the probability might change. Thus, for any
message (document, or other information representation) the
information — and particularly the probabilities — reflect
what the information producer believed was appropriate for the purpose
and at the time the message (document) was created.
    </mif:p>
                  <mif:p>
For example, at the beginning of the 2000 baseball season (May), the
Las Vegas odds makers may have given the New York Yankees a
probability of 1 in 10 (0.100) of winning the World Series. At the
time of this writing, the Yankees and Mets have won their respective
pennants, but the World Series has yet to begin. The probability of
the Yankees winning the World Series is obviously significantly
greater at this point in time, perhaps 6 in 10 (0.600). The context,
and in particular the time of year, made all the difference in the
world.
    </mif:p>
                  <mif:p>
Since probabilities are subjective measures of belief, they can be
stated without being "correct" or "incorrect" per se, let alone
"precise" or "imprecise". Notably, one does not have to conduct
experiments to measure a frequency of some outcome in order to specify
a probability. In fact, whenever statements about individual people or
events are made, it is not possible to confirm such probabilities with
"frequentists" experiments.
    </mif:p>
                  <mif:p>
Returning to our example, the Las Vegas odds makers can not insist on
the Yankees and Mets playing 1000 trial games prior to the Series;
even if they could, they would not have the fervor of the real Series
and therefore not be accurate. Instead, the odds makers must derive
the probability from past history, player statistics, injuries, etc.
    </mif:p>
                  <mif:p>
The type T is not formally constrained. In theory, discrete
probabilities can only be stated for discrete data values. Thus,
generally <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> should not be used with <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="REAL"/>
                     </mif:object>,
<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="PQ"/>
                     </mif:object>, or <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="MO"/>
                     </mif:object> values. 
    </mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;ANY T&gt;
type UncertainValueProbabilistic&lt;T&gt; alias UVP&lt;T&gt; specializes T {
    REAL  probability;
};
    </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="ANY"/>
      </mif:parameter>
      <mif:property name="probability" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Probability"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The probability assigned to the value, a decimal number between 0
(very uncertain) and 1 (certain).
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
There is no "default probability" that one can assume when the
probability is unstated. Therefore, it is impossible to make any
semantic difference between an <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> of T without probability and
a simple T. <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> of T does not mean "uncertain", and a simple T
does not mean "certain". In fact, the probability of the <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>
could be 0.999 or 1, which is quite certain, where a simple T value
could be a very vague guess.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="REAL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="NPPD" title="NonParametricProbabilityDistribution"
                 datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="SET">
            <mif:argumentDatatype name="UVP">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:argumentDatatype>
         </mif:targetDatatype>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
A set of uncertain values with probabilities (also known as
histogram.) All the elements in the set are considered alternatives
and are rated each with its probability expressing the belief (or
frequency) that each given value holds.
    </mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
The purpose of the non-parametric probability distribution is chiefly
to support statistical data reporting as it occurs in measurements
taken from many subjects and consolidated in a histogram. This occurs
in epidemiology, veterinary medicine, laboratory medicine, but also in
cost controlling and business process engineering.
    </mif:p>
                  <mif:p>
Semantically, the information of a stated value exists in contrast to
the complement set of unstated possible values. Thus, semantically, a
non-parametric probability distribution contains <mif:b>all</mif:b>
possible values and assigns probabilities to each of them.
    </mif:p>
                  <mif:p>
The easiest way to visualize this is a bar chart as shown in
    </mif:p>
                  <mif:img imageType="image/gif" src="DT-NPPD-ex1.gif" alt="Example of a Histogram"/>
                  <mif:p>
This example illustrates the probability of selected major league
baseball teams winning the World Series (prior to the season
start). Each team is mutually exclusive, and were we to include all of
the teams, the sum of the probabilities would equal 1 (i.e., it is
certain that one of the teams will win).
    </mif:p>
                  <mif:p>
Just as with <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="UVP"/>
                     </mif:object>, the type T is not formally
constrained, even though there are reasonable and unreasonable
uses. Typically one would use the <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> for unordered types, if
only a "small" set of possible values is assigned explicit
probabilities, or if the probability distribution cannot (or should
not) be approximated with parametric methods. For other cases, one may
prefer <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="PPD"/>
                     </mif:object>.
    </mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;ANY T&gt;
type NonParametricProbabilityDistribution&lt;T&gt; alias NPPD&lt;T&gt;
              specializes SET&lt;UVP&lt;T&gt;&gt; {
    UVP&lt;T&gt; mostLikely(INT n);
};
    </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="ANY"/>
      </mif:parameter>
      <mif:property name="mostLikely" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Most Likely"/>
         <mif:parameter name="n" sortKey="1">
            <mif:type name="INT"/>
         </mif:parameter>
         <mif:type name="UVP">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="PIVL" title="PeriodicIntervalOfTime" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="SET"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
An interval of time that recurs periodically. Periodic intervals have
two properties, phase and period. The phase specifies the "interval
prototype" that is repeated every period.
    </mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
For example, "every eight hours for two minutes" is a periodic
interval where the interval's width equals 2 minutes and the period
at which the interval recurs equals 8 hours.
    </mif:p>
                  <mif:p>
The phase also marks the anchor point in time for the entire series of
periodically recurring intervals. The recurrence of a periodic interval has no
beginning or ending, but is infinite in both future and past.
    </mif:p>
                  <mif:p>
A periodic interval is fully specified when both the period and the
phase are fully specified. The interval may be only partially
specified where either only the width or only one boundary is
specified.
    </mif:p>
                  <mif:p>
For example: "every eight hours for two minutes" specifies only the
period and the phase's width but no boundary of the phase. Conversely,
"every eight hours starting at 4 o'clock" specifies only the period
and the phase's low boundary but not the phase's high boundary. "Every
eight hours for two minutes starting at 4 o'clock" is fully specified
since the period, and both the phase's low boundary and width are
specified (low boundary and width implies the high boundary.)
    </mif:p>
                  <mif:p>
The periodic interval of time is a generic type extension whose type
parameter T is restricted to the point in time (<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="TS"/>
                     </mif:object>)
data type and its extensions. The parametric probability distribution
of point in time (<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="PPD"/>
                     </mif:object>&lt;<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="TS"/>
                     </mif:object>&gt;) is
an extension of point in time and therefore can be used to form
periodic intervals of probability distributions of point in time
(<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="PIVL"/>
                     </mif:object>&lt;<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="PPD"/>
                     </mif:object>
&lt;<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="TS"/>
                     </mif:object>&gt;&gt;) values (uncertain periodic interval.)
    </mif:p>
                  <mif:p>
Oftentimes repeating schedules are only approximately specified. For
instance "three times a day for ten minutes each" does not usually
mean a period of precisely 8 hours and does often not mean exactly 10
minutes intervals. Rather the distance between each occurrence may
vary as much as between 3 and 12 hours and the width of the interval
may be less than 5 minutes or more than 15 minutes. An uncertain
periodic interval can be used to indicate how much leeway is allowed
or how "timing-critical" the specification is.
    </mif:p>
                  <mif:div title="Periodic Intervals as Sets">
The essential property of a set is that it contains elements. For
non-aligned periodic intervals, the contains-property is
defined as follows. A point in time t is contained in the
periodic interval of time if and only if there is an integer
i for which t plus the period times
i is an element of the phase interval.
      
invariant (PIVL&lt;TS&gt; x, TS t)
    where x.nonNull.and(x.alignment.isNull) {
  x.contains(t).equal(exists(INT i) {
       x.phase.contains(t.plus(x.period.times(i)));
     });
};
      
For calendar-aligned periodic intervals the contains
property is defined using the calendar-cycle's sum(t,
n) property that adds n such calendar cycles
to the time t.
      
invariant (PIVL&lt;TS&gt; x, TS t, CalendarCycle c)
    where x.nonNull.and(c.equal(x.alignment)) {
  x.contains(t).equal(exists(INT i) {
        x.phase.contains(c.sum(t, i));
     });
};
      </mif:div>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;TS T&gt;
type PeriodicIntervalOfTime&lt;T&gt; alias PIVL&lt;T&gt; specializes SET&lt;T&gt; {
            IVL&lt;T&gt;  phase;
            PQ      period;
            CS      alignment;
            BL      institutionSpecifiedTime;
  literal   ST;
};
    </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="TS"/>
      </mif:parameter>
      <mif:property name="phase" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Phase"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A prototype of the repeating interval, specifying the duration of
each occurrence and anchors the periodic interval sequence at a
certain point in time.
        </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
The phase also marks the anchor point in time for the entire series of
periodically recurring intervals. The recurrence of a periodic
interval has no begin or end but is infinite in both future and
past. The width of the phase must be less or equal the period.
        </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="IVL">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="period" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Period"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A time duration specifying as a reciprocal measure of the frequency at
which the periodic interval repeats.
        </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
The period is a physical quantity in the dimension of time (TS.diffType.)
For an uncertain periodic interval the period is a probability
distribution over elapsed time.
        </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="PQ"/>
      </mif:property>
      <mif:property name="alignment" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1">
         <mif:businessName name="Alignment to the Calendar"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
Specifies if and how the repetitions are aligned to the cycles 
of the underlying calendar (e.g., to distinguish every 30 days
from "the 5th of every month".) A non-aligned periodic interval recurs
independently from the calendar. An aligned periodic interval is
synchronized with the calendar.
        </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
For example, "every 5th of the month" is a calendar aligned periodic
interval. The period spans 28 to 31 days depending on the calendar
month. Conversely, "every 30 days" is an independent period that will
fall on a different date each month.
        </mif:p>
                     <mif:p>
The calendar alignment specifies a calendar cycle to which the
periodic interval is aligned. The even flow of time will then be
partitioned by the calendar cycle. The partitioning is called the
calendar "grid" generated by the aligned-to calendar cycle. The
boundaries of each occurrence interval will then have equal distance
from the earliest point in each partition. In other words, the
distance from the next lower grid-line to the beginning of the
interval is constant.
        </mif:p>
                     <mif:p>
For example, with “every 5th of the month” the alignment
calendar cycle would be month of the year (<mif:code>MY</mif:code>).  The even
flow of time is partitioned in months of the year. The distance
between the beginning of each month and the beginning of its
occurrence interval is 4 days (4 days because day of month (DM) starts
counting with 1.)  Thus, as months differ in their number of days, the
distances between the recurring intervals will vary slightly, so that
the interval occurs always on the 5th.
        </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="CalendarCycle"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="institutionSpecifiedTime" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Institution Specified Timing"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
Indicates whether the exact timing is up to the party executing the
schedule (e.g., to distinguish "every 8 hours" from "3 times a day".)
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
For example, with a schedule "three times a day" the average time
between repetitions is 8 hours, however, with institution specified
time indicator <mif:b>true</mif:b>, the timing could follow some rule
made by the executing person or organization ("institution"), that,
e.g., three times a day schedules are executed at 7 am, noon, and 7
pm.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="literal" sortKey="05" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							                 <mif:b>Generic Literal Form</mif:b>. The generic 
literal form for periodic intervals of time is as follows:
      </mif:p>
                     <mif:p>
(<mif:b>phase</mif:b> : IVL&lt;T&gt;( <mif:b>/</mif:b>
(<mif:b>period</mif:b> : QTY  ( [ <mif:b>@</mif:b>
(<mif:b>alignment</mif:b>( ] [ <mif:b>IST</mif:b> ].
      </mif:p>
                     <mif:p>
For example, "<mif:code>[200004181100;200004181110]/(7 d)@DW</mif:code>"
specifies every Tuesday from 11:00 to 11:10 AM. Conversely,
"<mif:code>[200004181100;200004181110]/(1 mo)@DM</mif:code>" specifies every
18th of the month 11:00 to 11:10 AM.
      </mif:p>
                     <mif:p>
See <mif:object name="conceptDomainRef">
                           <mif:param name="name" value="CalendarCycle"/>
                        </mif:object> for calendar-period codes
defined for the Gregorian calendar. There are 1-character and
2-character symbols. The 2-character symbols are preferred for the
alignment period identifier.
      </mif:p>
                     <mif:p>
							                 <mif:b>Calendar Pattern Form</mif:b>. This form is
used to specify calendar-aligned timing more intuitively using "calendar
patterns."  The calendar pattern syntax is (semi-formally) defined as
follows:
      </mif:p>
                     <mif:p>
(<mif:b>anchor</mif:b>( [ (<mif:b>calendar digits</mif:b>(
 [ <mif:b>..</mif:b> (<mif:b>calendar digits</mif:b>( ]]
<mif:b>/</mif:b> (<mif:b>number</mif:b>
 : INT( [ <mif:b>IST</mif:b> ]
      </mif:p>
                     <mif:p>
A calendar pattern is a calendar date where the higher significant
digits (e.g., year and month) are omitted. In order to interpret the
digits, a period identifier is prefixed that identifies the calendar
period of the left-most digits. This calendar period identifier
<mif:b>anchors</mif:b> the calendar digits following to the right.
      </mif:p>
                     <mif:p>
See <mif:object name="conceptDomainRef">
                           <mif:param name="name" value="CalendarCycle"/>
                        </mif:object> for calendar-period codes
defined for the Gregorian calendar. There are 1-character and
2-character symbols. The 1-character symbols are preferred for the
calendar pattern anchor.
      </mif:p>
                     <mif:p>
For example: "<mif:code>M0219</mif:code>" is February 19 the entire day every
year. This periodic interval has the February 19 of any year as its
phase (e.g., "<mif:code>[19690219;19690220[</mif:code>" ), a period of one
year, and alignment month of the year (M). The alignment
calendar-cycle is the same as the anchor (e.g., in this example, month
of the year.)
      </mif:p>
                     <mif:p>
The calendar digits may also omit digits on the right. When digits are
omitted on the right, this means the interval from lowest to highest
for these digits. For example, "<mif:code>M0219</mif:code>" is February 19 the
entire day; "<mif:code>M021918</mif:code>" is February 19, the entire hour
between 6 and 7 PM.
      </mif:p>
                     <mif:p>
In absence of a formal definition for this, the rules for parsing a
calendar pattern are as follows (example is "<mif:code>M021918..21</mif:code>")
      </mif:p>
                     <mif:ol>
                        <mif:li>
                           <mif:p>
Read the anchoring period identifier (e.g. "<mif:code>M</mif:code>")
          </mif:p>
                        </mif:li>
                        <mif:li>
                           <mif:p>
the PIVL's alignment is equal to this calendar period (e.g. month of
the year)
          </mif:p>
                        </mif:li>
                        <mif:li>
                           <mif:p>
use the current point in time and format a literal exact to the next
higher significant calendar period from the anchoring calendar period
(e.g. year, "<mif:code>2000</mif:code>", constructing
"<mif:code>2000021918</mif:code>"); this is the "stem literal"
          </mif:p>
                        </mif:li>
                        <mif:li>
                           <mif:p>
Read this constructed literal (e.g., "<mif:code>2000021918</mif:code>") into a
<mif:object name="datatypeRef">
                                 <mif:param name="datatypeName" value="TS"/>
                              </mif:object> value and convert that value to an interval
according to <mif:object name="propertyRef">
                                 <mif:param name="datatypeName" value="IVL_TS"/>
                                 <mif:param name="propertyName" value="promotion"/>
                                 <mif:object name="propertyParameterTypeRef">
                                    <mif:param name="datatypeName" value="TS"/>
                                 </mif:object>
                              </mif:object> (e.g.,
"[2000021918;2000021919[") this is the "low interval."
          </mif:p>
                        </mif:li>
                        <mif:li>
                           <mif:p>
If the hull-operator token ".." follows, read the following calendar
digits (e.g., "21")
          </mif:p>
                        </mif:li>
                        <mif:li>
                           <mif:p>
Right-align the stem literal and the calendar digits just read
								</mif:p>
                        </mif:li>
                        <mif:li>
                           <mif:p>
and copy all digits from the stem literal that are missing to the left
of the calendar digits just read (e.g., yields "<mif:code>2000021921</mif:code>".)
          </mif:p>
                        </mif:li>
                        <mif:li>
                           <mif:p>
Read this constructed literal (e.g., "<mif:code>2000021918</mif:code>") into a
<mif:object name="datatypeRef">
                                 <mif:param name="datatypeName" value="TS"/>
                              </mif:object> value and convert that value to an <mif:object name="datatypeRef">
                                 <mif:param name="datatypeName" value="IVL"/>
                              </mif:object>
&lt;<mif:object name="datatypeRef">
                                 <mif:param name="datatypeName" value="TS"/>
                              </mif:object>&gt; according to <mif:object name="propertyRef">
                                 <mif:param name="datatypeName" value="IVL_TS"/>
                                 <mif:param name="propertyName" value="promotion"/>
                                 <mif:object name="propertyParameterTypeRef">
                                    <mif:param name="datatypeName" value="TS"/>
                                 </mif:object>
                              </mif:object>
(e.g., "<mif:code>[2000021921;2000021922[</mif:code>") this is the "high interval."
          </mif:p>
                        </mif:li>
                        <mif:li>
                           <mif:p>
The phase interval is the convex hull of the low interval and the high
interval (e.g., "<mif:code>[2000021918;2000021922[</mif:code>").
          </mif:p>
                        </mif:li>
                        <mif:li>
                           <mif:p>
If the hull-operator was not present, the phase is simply the low interval.
          </mif:p>
                        </mif:li>
                     </mif:ol>
                     <mif:p>
							                 <mif:b>Interleave.</mif:b> A calendar pattern
followed by a slash and an integer number <mif:b>n</mif:b> indicates that the
given calendar pattern is to apply every nth time.
      </mif:p>
                     <mif:p>
For example: "<mif:code>D19/2</mif:code>" is the 19th of every second month.
      </mif:p>
                     <mif:p>
A calendar pattern expression is evaluated at the time the pattern is
first enacted. At this time, the calendar digits missing from the left
are completed using the earliest date matching the pattern (and
following a preceding pattern in a combination of time sets).
      </mif:p>
                     <mif:p>
For example: "<mif:code>D19/2</mif:code>" is the 19th of every second
month. If this expression is evaluated on March 14, 2000 the phase is
completed to: "<mif:code>[20000319;20000320[/(2 mo)@DM</mif:code>" and thus
the two-months cycle begins with March 19, followed by May 19, etc. If
the expression were evaluated by March 20, the cycle would begin at
April 19, followed by June 19, etc.
      </mif:p>
                     <mif:p>
If no calendar digits follow after the calendar period identifier, the
pattern matches any date. The integer number following the slash
indicates the length of the cycle. The phase interval in these cases
has only the width specified to be the duration of the anchoring
calendar-cycle (e.g., in this example 1 day.)
      </mif:p>
                     <mif:p>
For example: "<mif:code>CD/2</mif:code>" is every other day,
"<mif:code>H/8</mif:code>" is every 8th hour, for the duration of one hour.
      </mif:p>
                     <mif:p>
							                 <mif:b>Institution Specified Time.</mif:b> Both a 
generic periodic interval literal and a calendar pattern may be followed by
the three letters "IST" to indicate that within the larger calendar
cycle (e.g., for "hour of the day" the larger calendar cycle is "day")
the repeating events are to be appointed at institution specified
times. This is used to specify such schedules as "three times a day"
where the periods between two subsequent events may vary well between
4 hours (between breakfast and lunch) and 10 hours (over night.)
      </mif:p>
                     <mif:table width="90%" hl7Id="examples-PIVL.literal">
                        <mif:caption>Examples for literal expressions for periodic intervals 
              of time</mif:caption>
                        <mif:col width="258" span="1"/>
                        <mif:col width="137" span="1"/>
                        <mif:col width="513" span="1"/>
                        <mif:thead>
                           <mif:tr>
                              <mif:th>Generic Form</mif:th>
                              <mif:th>Calendar Pattern Form</mif:th>
                              <mif:th>Description</mif:th>
                           </mif:tr>
                        </mif:thead>
                        <mif:tbody>
                           <mif:tr>
                              <mif:td>[198709;198710[/(1 a)@MY</mif:td>
                              <mif:td>M09</mif:td>
                              <mif:td>September, the entire month, every year (note that in 
                  the year 1987 in the generic form is irrelevant since the
                  periodic interval recurs every year past and future.)</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[19870915;19870916[/(1 a)@DM</mif:td>
                              <mif:td>M0915</mif:td>
                              <mif:td>September 15, the entire day, every year</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[1987091516;1987091517[/(1 a)@DM</mif:td>
                              <mif:td>M091516</mif:td>
                              <mif:td>September 15 at 4 PM, the entire hour, every year</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[198709151630;198709151710]/(1 a)@DM</mif:td>
                              <mif:td>M09151630..1710</mif:td>
                              <mif:td>September 15 at 4:30 5:10 PM, every year</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[1987091516;[/(1 a)@DM</mif:td>
                              <mif:td> </mif:td>
                              <mif:td>September 15 at 4 PM, end time explicitly unknown, every 
                  year</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[198709151630;198709151631[/(1 a)@DM</mif:td>
                              <mif:td>M09151630</mif:td>
                              <mif:td>September 15 at 4:30 PM, the entire minute, every year</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[1987091516;1987091517[/(1 mo)@DM</mif:td>
                              <mif:td>D1516..17</mif:td>
                              <mif:td>every 15th day of the month at 4 to 5 PM</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[1987091516;1987091517[/(1 mo)</mif:td>
                              <mif:td> </mif:td>
                              <mif:td>September 15, 1987 from 4 to 5 PM and then every 730.5 
                  hours continuously (this example has little practical value 
                  beyond comparing the unaligned with the aligned form in the 
                  preceding row.)</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[1987091516;1987091517[/(1 mo)@HD</mif:td>
                              <mif:td> </mif:td>
                              <mif:td>September 15, 1987 from 4 to 5 PM and then every 30.4375
                  days, but aligned to the hour of the day.</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[1 mo]/(2 mo)@MY</mif:td>
                              <mif:td>M/2</mif:td>
                              <mif:td>every other month of the year; (Jan, Mar, ...) vs. (Feb, 
                  Apr, ...) is undefined</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[198701;197502[/(2 mo)@MY</mif:td>
                              <mif:td>M01..12/2</mif:td>
                              <mif:td>every other month of the year, Jan, Mar, ...</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[198702;197503[/(2 mo)@MY</mif:td>
                              <mif:td>M02..12/2</mif:td>
                              <mif:td>every other month of the year, Feb, Apr, ...</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[19870401;19870930[/(1 a)@DM</mif:td>
                              <mif:td>M04..09</mif:td>
                              <mif:td>April 1until (and including) September 30</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>19870401-0930/(1 a)@DM</mif:td>
                              <mif:td>M0401..0930</mif:td>
                              <mif:td>April 1 to September 30 (the generic form uses the 
                  dash-form for the phase interval)</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[20001202;20001203[/(1 wk)@DW</mif:td>
                              <mif:td>J6</mif:td>
                              <mif:td>every Saturday</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[20001202;20001203[/(2 wk)@DW</mif:td>
                              <mif:td>J6/2</mif:td>
                              <mif:td>every other Saturday</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[20001202;20001203[/(3 wk)@DW</mif:td>
                              <mif:td>J6/3</mif:td>
                              <mif:td>every third Saturday</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[1 d]/(2 d)@DW</mif:td>
                              <mif:td>J/2</mif:td>
                              <mif:td>every other day of the week; (Mon, Wed, Fri, ...) vs. 
                  (Tue, Thu, Sat, ...)  is undefined</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[20001204;20001205[/(2 d)@DW</mif:td>
                              <mif:td>J2..6/2</mif:td>
                              <mif:td>every other day of the week (Tue, Thu, Sat, Tue, Thu, 
                  Sat, ...)</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[20001204;20001205[/(2 d)</mif:td>
                              <mif:td>D/2</mif:td>
                              <mif:td>every other day (Tue, Thu, Sat, Mon, Wed, Fri, Sun, 
                  Tue, ...)</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[19870601;19870606[/(1 wk)@DW</mif:td>
                              <mif:td>J1..5</mif:td>
                              <mif:td>Monday to Friday every week</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[19870601;19870608[/(2 wk)</mif:td>
                              <mif:td>W/2</mif:td>
                              <mif:td>every other week (continuous)</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[19870101;19870105[/(2 wk)@WY</mif:td>
                              <mif:td>WY/2</mif:td>
                              <mif:td>every other week of the year (a blunt example on the 
                  impact of the calendar alignment: the phase interval spans 
                  only 4 days and yet it represents an entire week in the 
                  calendar alignment "week of the year".)</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[19870406;19870413[/(1 a)@WY</mif:td>
                              <mif:td>WY15</mif:td>
                              <mif:td>the 15th calendar week of every year</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[19870105;19870112[/(1 mo)@WM</mif:td>
                              <mif:td>WM2</mif:td>
                              <mif:td>the second week of the month, every month</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[19870508;19870509[/(1 a)@DY</mif:td>
                              <mif:td>DY128</mif:td>
                              <mif:td>the 128th day of the year, every year</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[10 min]/(2 d)</mif:td>
                              <mif:td> </mif:td>
                              <mif:td>every other day for 10 minutes (only width of repeating 
                  interval is known)</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[1 h]/(8 h)</mif:td>
                              <mif:td>H/8</mif:td>
                              <mif:td>every eighth hour (each time a 60 minutes interval)</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[1 h]/(8 h) IST</mif:td>
                              <mif:td>H/8 IST</mif:td>
                              <mif:td>three times a day at institution specified times (each 
                  time a 60 minutes interval)</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>/(8 h) IST</mif:td>
                              <mif:td> </mif:td>
                              <mif:td>three times a day at institution specified times. 
                  Nothing about the repeating interval is known i.e., this 
                  includes only a period (frequency), while the phase is left 
                  undefined</mif:td>
                           </mif:tr>
                        </mif:tbody>
                     </mif:table>
                  </mif:text>
               </mif:designComments>
               <mif:otherAnnotation type="LiteralFormat">
                  <mif:data>
PIVL&lt;T&gt;.literal ST {
  PIVL&lt;T&gt;
  : S2                     { $.equal($1); }
  | S2 "IST"               { $.phase.equal($1.phase);
                             $.period.equal($1.period);
                             $.institutionSpecified.equal(true); };
  PIVL&lt;T&gt; S2
  : S1                     { $.equal($1); }
  | S1 "@" "(" ST ")"      { $.phase.equal($1.phase);
                             $.period.equal($1.period);
                             $.alignment.equal($4); };
  PIVL&lt;T&gt; S1
  : IVL&lt;T&gt; "/" "(" QTY ")" { $.phase.equal($1);
                                $.period.equal($3); }
  |        "/" "(" QTY ")" { $.period.equal($2); };
};
      </mif:data>
               </mif:otherAnnotation>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="ST"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="EIVL" title="EventRelatedPeriodicInterval" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="SET"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
Specifies a periodic interval of time where the recurrence is based on
activities of daily living or other important events that are
time-related but not fully determined by time.
    </mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
For example, "one hour after breakfast" specifies the beginning of the
interval at one hour after breakfast is finished. Breakfast is assumed
to occur before lunch but is not determined to occur at any specific
time.
    </mif:p>
                  <mif:div title="Resolving the Event-Relatedness">
An event-related periodic interval of time is a set of time, that is,
one can test whether a particular time or time interval is an element
of the set. Whether an event-related periodic interval of time
contains a given interval of time is decided using a relation event
χ time referred to as EVENT(event,
time). The property occurrenceAt(t) is the
occurrence interval that would exist if the event occurred at time
t.
      
invariant(EIVL&lt;T&gt; x, T eventTime, IVL&lt;T&gt; v)
     where v.equal(x.occurrenceAt(eventTime)) {
  v.low.equal(eventTime.plus(x.offset.low));
  v.high.equal(eventTime.plus(x.offset.high));
  v.lowClosed.equal(x.offset.lowClosed);
  v.highClosed.equal(x.offset.highClosed);
};
      
Thus, an event related interval of time contains a point in time
t if there is an event time e with an
occurrence interval v such that v contains
t.
      
invariant(EIVL&lt;T&gt; x, T y) {
  x.contains(y).equal(exists(T e, IVL&lt;T&gt; v)
                           where EVENT(x.event, y)
                            .and(v.resolvedAt(y)) {
                         v.contains(y);
                       });
};
      </mif:div>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;TS T&gt;
type EventRelatedPeriodicInterval&lt;T&gt; alias EIVL&lt;T&gt;
         specializes SET&lt;T&gt; {
            CS          event;
            IVL&lt;PQ&gt; offset;
            IVL&lt;T&gt;      occurrenceAt(TS eventTime);
  literal   ST;
};
    </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="TS"/>
      </mif:parameter>
      <mif:property name="event" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Event"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A code for a common (periodical) activity of daily living based on
which the event related periodic interval is specified.
        </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
Such events qualify for being adopted in the domain of this
attribute for which all of the following is true:
        </mif:p>
                     <mif:ul>
                        <mif:li>
                           <mif:p>the event commonly occurs on a regular basis,</mif:p>
                        </mif:li>
                        <mif:li>
                           <mif:p>the event is being used for timing activities, and</mif:p>
                        </mif:li>
                        <mif:li>
                           <mif:p>the event is not entirely determined by time.</mif:p>
                        </mif:li>
                     </mif:ul>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="CE"/>
      </mif:property>
      <mif:property name="offset" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Offset"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
An interval of elapsed time (duration, not absolute point in time)
that marks the offsets for the beginning, width and end of
the event-related periodic interval measured from the time each such
event actually occurred.
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
For example: if the specification is "one hour before breakfast for 10
minutes" the offset's low boundary is (1 h and the offset's width is
10 min (consequently the offset's high boundary is (50 min.)
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="IVL">
            <mif:argumentDatatype name="PQ"/>
         </mif:type>
      </mif:property>
      <mif:property name="occurrenceAt" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Interval At"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							The <mif:b>intervalAt</mif:b>- property maps value <mif:b>x</mif:b> to
							the greatest continuous subset <mif:b>v</mif:b> (an "occurrence interval") of
							the <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> value <mif:b>S</mif:b>, where <mif:b>v</mif:b> includes <mif:b>x</mif:b>.
							If there is no occurrence interval that includes v, intervalAt(x) will be null.
						</mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="eventTime" sortKey="1">
            <mif:type name="TS"/>
         </mif:parameter>
         <mif:type name="IVL">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="literal" sortKey="04" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
The literal form for an event related interval begins with the event
code followed by an optional interval of the time-difference.
      </mif:p>
                     <mif:p>
For example, one hour after meal would be
"<mif:code>PC+[1h;1h]</mif:code>". One hour before bedtime for 10 minutes:
"<mif:code>HS-[50min;1h]</mif:code>".
      </mif:p>
                  </mif:text>
               </mif:designComments>
               <mif:otherAnnotation type="LiteralFormat">
                  <mif:data>
EIVL&lt;TS&gt;.literal ST {
  EIVL&lt;TS&gt; : event    { $.event.equal($1); }
  | event offset      { $.event.equal($1); $.offset.equal($2); };
  CS event : ST       { $.code.equal($1);
                        $.codeSystem.equal(2.16.840.1.113883.5.1019); }
  IVL&lt;PQ&gt; offset
  : "+" IVL&lt;PQ&gt;  { $.equal($2); }
  | "-" IVL&lt;PQ&gt;  { $.low.equal($2.high.negate);
                        $.high.equal($2.low.negate);
                        $.width.equal($2.width);
                        $.lowClosed($2.highClosed);
                        $.highClosed($2.lowClosed); };
};
      </mif:data>
               </mif:otherAnnotation>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="ST"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="GTS" title="GeneralTimingSpecification" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="SET">
            <mif:argumentDatatype name="TS"/>
         </mif:targetDatatype>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
A set of points in time, specifying the timing of events and actions
and the cyclical validity-patterns that may exist for certain kinds of
information, such as phone numbers (evening, daytime), addresses (so
called "snowbirds," residing closer to the equator during winter and
farther from the equator during summer) and office hours.
    </mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
The GTS data type has the following aspects:
    </mif:p>
                  <mif:ul>
                     <mif:li>
                        <mif:p>
GTS as a general set of points in time (<mif:object name="datatypeRef">
                              <mif:param name="datatypeName" value="SET"/>
                           </mif:object>
&lt;<mif:object name="datatypeRef">
                              <mif:param name="datatypeName" value="TS"/>
                           </mif:object>&gt;). From this aspect GTS answers
whether any given point in time falls in the schedule described by the
GTS value.
        </mif:p>
                     </mif:li>
                     <mif:li>
                        <mif:p>
GTS as the combination of multiple periodic intervals of time. This
aspect describes how both simple and complex repeat-patterns are
specified with the GTS.
        </mif:p>
                     </mif:li>
                     <mif:li>
                        <mif:p>
GTS as a generator of a sequence of intervals of point in time
(<mif:object name="datatypeRef">
                              <mif:param name="datatypeName" value="LIST"/>
                           </mif:object>&lt;<mif:object name="datatypeRef">
                              <mif:param name="datatypeName" value="IVL"/>
                           </mif:object>
&lt;<mif:object name="datatypeRef">
                              <mif:param name="datatypeName" value="TS"/>
                           </mif:object>&gt;&gt;).
From this aspect, GTS can generate all occurrence intervals of an event or
action, or all validity periods for a fact.
        </mif:p>
                     </mif:li>
                     <mif:li>
                        <mif:p>
GTS as an expression-syntax defined for a calendar. This aspect is the
GTS literal form.
        </mif:p>
                     </mif:li>
                  </mif:ul>
                  <mif:p>
In all cases the GTS is defined as a set of point in time (<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="SET"/>
                     </mif:object>
&lt;<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="TS"/>
                     </mif:object>&gt;). Using the set operations,
union, intersection and difference, more complex sets of time can be
constructed from simpler ones. Ultimately the building blocks from
which all GTS values are constructed are interval, periodic interval,
and event-related periodic interval. The construction of the GTS can
be specified in the literal form. No special data type structure is
defined that would generate a combination of simpler time-sets from a
given GTS value. While any implementation would have to contain such a
structured representation, it is not needed in order to exchange GTS
values given the literal form.<mif:object name="footnote"> 
The GTS is an example of a data type that is only defined
algebraically without giving any definition of a data structure that
might implement the behavior of such a data type. The algebraic
definition looks extremely simple, so that one might assume it is
incomplete. Since at this point we are relying entirely on the literal
form to represent GTS values, all the definition of data structur
        </mif:object>
				              </mif:p>
                  <mif:p>
The GTS data type is defined as using intervals, periodic intervals,
and event-related periodic intervals. Intervals of time have been
defined above
    </mif:p>
                  <mif:div title="Convex Hull">
A convex hull is the least interval that is a superset of all
occurrence intervals. As noted in , all
totally ordered sets have a convex hull. Because a GTS is a 
&lt;&gt; and because a 
&lt;&gt; is a totally ordered set, all
GTS values have a convex hull.
      
The convex hull of a GTS can less formally be called "outer bound
interval". Thus, the convex hull of a GTS describes the absolute
beginning and end of the repeating schedule. For infinite repetitions
(e.g., a simple periodic interval) the convex hull has infinite
bounds.
      
						
						Convex Hull of a Schedule
					</mif:div>
                  <mif:div title="GTS as a Sequence of Occurrence Intervals">
A  value is a generator of a sequence of time
intervals during which an event or activity occurs, or during which a
state is effective.
      
The nextTo-property maps to every point in
time t the greatest continuous subset (an "occurrence
interval") v of the  value
S, where v is the interval closest to
t that begins later than t or that contains
t.
      
invariant(GTS S, TS t, IVL&lt;TS&gt; v) {
  v.equal(S.nextTo(t)).equal(
         S.contains(o)
    .and(forall(IVL&lt;TS&gt; u) where x.contains(u) {
           u.contains(v).implies(u.equal(v)); })
    .and(    v.contains(t)
         .or(forall(TS i) where t.lessOrEqual(i)
                           .and(i.lessThan(v.low)) {
               S.conatins(i).not; })));
};
      
The nextAfter-property maps to every point
in time t the greatest continuous subset (an "occurrence
interval") v of the  value
S, where v is the interval closest to
t that begins later than t.
      
invariant(GTS S, TS t) where {
  S.contains(t).not
     .implies(S.nextAfter(t).equal(S.nextTo(t)));
  S.contains(t)
     .implies(S.nextAfter(t).equal(
            S.except(nextTo(t)).nextTo(t)));
};
      
A  value can be converted into a generic Sequence
of time intervals (&lt;&gt;)
of occurrence intervals.
      
invariant(GTS x) where x.isEmpty { ((LIST&lt;IVL&lt;TS&gt;&gt;)x).isEmpty; };

invariant(GTS x, IVL&lt;TS&gt; first)
    where x.notEmpty
     .and(x.hull.low.nonNull)
     .and(first.equal(x.nextTo(x.hull.low))
{
  ((LIST&lt;IVL&lt;TS&gt;&gt;)x).head.equal(first);
  ((LIST&lt;IVL&lt;TS&gt;&gt;)x).tail.equal(
             (LIST&lt;IVL&lt;TS&gt;&gt;)x.except(first));
};
      </mif:div>
                  <mif:div title="Interleaving Schedules and Periodic Hull">
						
						Interleaving Schedules and Periodic Hull
					
For two  values A and B we
say that A interleaves B if their occurrence
intervals interleave on the time line. This concept is visualized in
Figure 15.
      
For the  values A and B
to interleave the occurrence intervals of both groups can be arranged
in pairs of corresponding occurrence intervals. It must further hold
that for all corresponding occurrence intervals a
⊆ A and b ⊆ B,
a starts before b starts (or at the same
time) and b ends after a ends (or at the
same time).
      
The interleaves-relation holds when two schedules have the same
average frequency, and when the second schedule never "outpaces" the
first schedule. That is, no occurrence interval in the second schedule
may start before its corresponding occurrence interval in the first
schedule.
      
With two interleaving  values one can derive a
periodic hull such that the occurrence intervals of the periodic hull
is the convex hull of the corresponding occurrence intervals.
      
The periodic hull is important to construct two schedules by combining
 expressions. For example, to construct the periodic
interval from Memorial Day to Labor Day every year, one first needs to
set up the schedules M for Memorial Day (the last Monday
in May) and L for Labor Day (the first Monday in
September) and then combine these two schedules using the periodic
hull of M and L.
      
invariant(GTS A, B) where x.nonNull.and(y.nonNull) {
  A.interleaves(B).equal(
    forall(IVL&lt;TS&gt; a, b, c; TS t)
        where a.equal(A.nextTo(t))
         .and(b.equal(B.nextTo(a.low)))
         .and(c.equal(A.nextTo(b.high))) {
      b.equal(B.nextTo(a.high));
      a.low.lessOrEqual(b.low);
      c.equal(A.nextTo(b.high));
      c.equal(a).or(c.equal(A.nextAfter(a.high)));
    });
};
      
For two  values A and B
where A interleaves B, a periodic hull is
defined as the pair wise convex hull of the corresponding occurrence
intervals of A and B.
      
invariant(GTS A, B, C) where A.interleaves(B) {
  A.periodicHull(B).equal(C).equal(
    forall(IVL&lt;TS&gt; a, b; TS t)
        where a.equal(A.nextTo(t))
         .and(b.equal(B.nextTo(a.low))) {
      C.contains(c).equal(c.equal(a.hull(b)));
    });
};
      
The interleaves-relation is reflexive, asymmetric, and
intransitive. The periodic hull operation is non-commutative and
non-associative.
The interleaves property may appear overly constrained. However, these
constraints are reasonable for the use case for which the interleaves
and periodic hull properties are defined. To safely and predictably
combine two schedules one would want to know which of the operands
sets the start points and which sets the endpoints of the periodic
hull's occurrence intervals.
          
					</mif:div>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type GeneralTimingSpecification alias GTS specializes SET&lt;TS&gt; {
            IVL&lt;TS&gt;   hull;
            IVL&lt;TS&gt;   nextTo(TS x);
            IVL&lt;TS&gt;   nextAfter(TS x);
            GTS       periodicHull(GTS x);
            BL        interleaves(GTS x);
  demotion  LIST&lt;IVL&lt;TS&gt;&gt;;
  literal   ST;
};
    </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="hull" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Convex Hull of Totally Ordered Sets"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="SET"/>
         </mif:derivedFrom>
         <mif:type name="IVL">
            <mif:argumentDatatype name="TS"/>
         </mif:type>
      </mif:property>
      <mif:property name="nextTo" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Interval At"/>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="TS"/>
         </mif:parameter>
         <mif:type name="IVL">
            <mif:argumentDatatype name="TS"/>
         </mif:type>
      </mif:property>
      <mif:property name="nextAfter" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Interval After"/>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="TS"/>
         </mif:parameter>
         <mif:type name="IVL">
            <mif:argumentDatatype name="TS"/>
         </mif:type>
      </mif:property>
      <mif:property name="periodicHull" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Periodic Hull"/>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="GTS"/>
         </mif:parameter>
         <mif:type name="GTS"/>
      </mif:property>
      <mif:property name="interleaves" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Interleaves"/>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="GTS"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="demotion" sortKey="06" propertyKind="demotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:businessName name="Demotion of GTS to LIST"/>
         <mif:type name="LIST">
            <mif:argumentDatatype name="IVL">
               <mif:argumentDatatype name="TS"/>
            </mif:argumentDatatype>
         </mif:type>
      </mif:property>
      <mif:property name="literal" sortKey="07" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
The <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="GTS"/>
                        </mif:object> literal allows specifying combinations of
intervals, periodic intervals, and event related periodic intervals of
time using the set operations, unions and intersection. This literal
form is specified based on the simpler time set data types interval,
periodic interval, and event related periodic interval.<mif:object name="footnote">
This literal specification again looks surprisingly simple, so one
might assume it is incomplete. However, the 
literal is based on the , ,
PIVL, and  literals and does also imply the
literals for the extensions of , notably the
. The  literal 
specification itself only needs to tie the other literal forms together, which 
is indeed a fairly simple task by itself.
           </mif:object>
					                </mif:p>
                     <mif:p>
Unions are speechified by a semicolon-separated list. Intersections
are specified by a whitespace separated list. Intersection has higher
priority than union. Exclusions (set differences) can be specified
using a backslash; exclusions have an intermediate priority,
i.e. weaker than intersection but stronger than union.
      
Also parentheses can be used to overcome operator precedence when
necessary.
      </mif:p>
                     <mif:p>
The following table contains paradigmatic examples for complex
<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="GTS"/>
                        </mif:object> literals. For simpler examples confer to the literal
forms for interval, periodic interval, and event related interval.
      </mif:p>
                     <mif:table width="90%" hl7Id="examples-GTS.literal">
                        <mif:caption>Examples for Literal Expressions for Generic Timing
            Specifications</mif:caption>
                        <mif:col width="168" span="1"/>
                        <mif:col width="407" span="1"/>
                        <mif:thead>
                           <mif:tr>
                              <mif:th>Literal Expression</mif:th>
                              <mif:th>Meaning</mif:th>
                           </mif:tr>
                        </mif:thead>
                        <mif:tbody>
                           <mif:tr>
                              <mif:td>M09 D15 H16 N30 S34.12</mif:td>
                              <mif:td>September 15 at 4:30:34.12 PM as the intersection of
                multiple periodic intervals of times (calendar patterns)</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>M0915163034.12</mif:td>
                              <mif:td>September 15 at 4:30:34.12 PM as one simple periodic
                interval of time (calendar pattern)</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>M01; M03; M07</mif:td>
                              <mif:td>January, March, and July (a union of three periodic 
                intervals of time)</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>M04..09 M/2</mif:td>
                              <mif:td>Every second month from April to September (April, June, 
                August)</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>J1; J2; J4</mif:td>
                              <mif:td>Monday, Tuesday, Thursday</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>W/2 J2</mif:td>
                              <mif:td>every other Tuesday (intersection of every other week and 
                every Tuesday)</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>1999 WY15</mif:td>
                              <mif:td>the 15th calendar week in 1999 (period code is optional 
                for the highest calendar unit)</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>WM2 J6</mif:td>
                              <mif:td>Saturday of the 2nd week of the month</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>M05 WM2 J6</mif:td>
                              <mif:td>Saturday of the 2nd week of May</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>M05 DM08..14 J7</mif:td>
                              <mif:td>Mother's day (second Sunday in May.)</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>J1..5 H0800..1600</mif:td>
                              <mif:td>Monday to Friday from 8 AM to 4 PM</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>
              J1..4 H0800..1600;<mif:br/>
              J5    H0800..1200
            </mif:td>
                              <mif:td>Monday to Thursday 8 AM to 4 PM and Friday 8 AM to 12
                noon.</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[10 d] H/8</mif:td>
                              <mif:td>Three times a day over 10 days (each time a 60 minutes
                interval).</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>H0800..1600 \J3</mif:td>
                              <mif:td>Every day from 8 AM to 4 PM, except Wednesday.</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>(M0825..31 J1)..M0831</mif:td>
                              <mif:td>The last calendar week of August.</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>JHNUSMEM..JHNUSLBR</mif:td>
                              <mif:td>The season from the U.S. holidays Memorial Day to Labor
                Day</mif:td>
                           </mif:tr>
                        </mif:tbody>
                     </mif:table>
                     <mif:div title="Symbolic Abbreviations for GTS expressions.">datyp2gtslitsym
The following  defines symbolic
abbreviations for  values that can be used in
 literals instead of their equivalent 
term. Abbreviations are defined for common periods of the day (AM, PM),
for periods of the week (business day, weekend), and for holidays.
The computation for the dates of some holidays, namely
the Easter holiday, involve some sophistication that goes beyond what
one would represent in a  literal term. It is
assumed that the dates of these holidays are drawn from some table or
some generator module that is outside the scope of this specification.
        
These abbreviations are named  values and they
can in turn be a factor of a  term. For example,
one can say "JHCHRXME H08..12" to indicate that the office hours on
Christmas Eve is from 8 AM to 1PM only. And one can say
"JHNUSMEM..JHNUSLBR" for the typical midwestern swimming pool season
from Memorial Day to Labor Day.
        
							
								
								
								
							
							
							
							
								
              Two times a day at institution specified time.
	    
							
							
								
              Three times a day at institution specified time.
	    
							
							
								
              Four times a day at institution specified time.
	    
							
							
							
							
								
									
									
									
									
									
									
								
								
									
									
									
									
									
									
									
									
									
									
									
									
									
								
							
						
this table is not complete. Neither does it include religious holidays
other than Christian (of the Gregorian (western) tradition), nor does
it contain national holidays on other countries. This is a limitation
to be remedied by subsequent additions.
          
holidays are locale-specific. Exactly which religious holidays are
subsumed under JH depends on the locale and other tradition. For
global interoperability, using constructed 
expressions is safer than named holidays. However, some holidays that
depend on moon phases (e.g., Easter) or ad-hoc decree cannot be easily
expressed in a  form.
          </mif:div>
                  </mif:text>
               </mif:designComments>
               <mif:otherAnnotation type="LiteralFormat">
                  <mif:data>
GTS.literal ST {
  GTS symbol
      : union                      { $.equal($1); }
  | exclusion                 { $.equal($1); };
  SET&lt;TS&gt; union
      : symbol ";" intersection    { $.equal($1.union($3)); }
  | intersection              { $.equal($1); };
  SET&lt;TS&gt; exclusion
      : symbol "\" intersection    { $.equal($1.except($3)); }
      | intersection               { $.equal($1); };
  SET&lt;TS&gt; intersection
      : hull intersection          { $.equal($1.intersection($2)); }
      | hull                       { $.equal($1); };
  SET&lt;TS&gt; hull
      : hull ".." factor           { $.equal($1.periodicHull($3)); }
      | factor                     { $.equal($1); };
SET&lt;TS&gt; factor
  : IVL&lt;TS&gt;                   { $.equal($1); }
  | PIVL&lt;TS&gt;                  { $.equal($1); }
  | EIVL&lt;TS&gt;                  { $.equal($1); }
  | "(" GTS ")"               { $.equal($1); };
};
      </mif:data>
               </mif:otherAnnotation>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="ST"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="PPD" title="ParametricProbabilityDistribution" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="T" qualifier="parameter"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
A generic data type extension specifying uncertainty of quantitative
data using a distribution function and its parameters. Aside from the 
specific parameters of the distribution, a mean (expected value) and 
standard deviation is always given to help maintain a minimum layer
of interoperability if receiving applications cannot deal with a
certain probability distribution.
    </mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
For example, the most common college entrance exam in the United
States is the SAT, which is comprised of two parts: verbal and
math. Each part has a minimum score of 400 (no questions answered
correctly) and a perfect score of 800. In 1998, according to the
College Board, 1,172,779 college-bound seniors took the test. The mean
score for the math portion of the test was 512, and the standard
deviation 112. These parameter values (512, 112), tagged as the normal
distribution parameters, paint a pretty good picture of test score
distribution. In most cases, there is no need to specify all
1-million+ points of data when just 2 parameters will do!
    </mif:p>
                  <mif:img imageType="image/gif" hl7Id="PPD.example" src="DT-PPD-ex1.gif"
                           alt="Example for a parametric probability distribution"/>
                  <mif:p>
Note that the normal distribution is only one of several distributions
defined for HL7.
    </mif:p>
                  <mif:p>Since a <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> specializes its parameter type T, a simple T value is
the mean (expected value or first moment) of the probability
distribution. Applications that cannot deal with distributions will
take the simple T value neglecting the uncertainty. That simple value
of type T is also used to standardize the data for computing the
distribution.
    </mif:p>
                  <mif:p>
Probability distributions are defined over integer or real numbers and
normalized to a certain reference point (typically zero) and reference
unit (e.g., standard deviation = 1). When other quantities defined in
this specification are used as base types, the mean and the standard
deviation are used to scale the probability distribution. For example,
if a <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> of PQ for a length is given with mean 20 ft
and a standard deviation of 2 in, the normalized distribution function
<mif:var>f</mif:var>(<mif:var>x</mif:var>) that maps a real number <mif:var>x</mif:var>
to a probability density would be translated to
<mif:var>f</mif:var>′(<mif:var>x</mif:var>′) that maps a length
<mif:var>x</mif:var>′ to a probability density as
<mif:var>f</mif:var>′(<mif:var>x</mif:var>′) =
<mif:var>f</mif:var>((<mif:var>x</mif:var>′ - μ ) / σ).
    </mif:p>
                  <mif:p>
Where applicable, the <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="PPD"/>
                     </mif:object> specification conforms to
the ISO <mif:b>Guide to the Expression of Uncertainty in
Measurement</mif:b> (GUM) as reflected by NIST publication 1297
<mif:b>Guidelines for Evaluating and Expressing the Uncertainty of NIST
Measurement Results</mif:b>. The <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> specification does not
describe how uncertainty is to be evaluated but only how it is
expressed. The concept of "standard uncertainty" as set forth by the
ISO GUM corresponds to the "standard deviation" property of the <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>.
    </mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;QTY T&gt;
type ParametricProbabilityDistribution&lt;T&gt; alias PPD&lt;T&gt;
                 specializes T {
            QTY     standardDeviation;
            CS      distributionType;
    literal ST;
};
    </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="QTY"/>
      </mif:parameter>
      <mif:property name="standardDeviation" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Standard Deviation"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
The primary measure of variance/uncertainty of the value (the square
root of the sum of the squares of the differences between all data
points and the mean). The standard deviation is used to normalize the
data for computing the distribution function. Applications that cannot
deal with probability distributions can still get an idea about the
confidence level by looking at the standard deviation.
        </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
The standard deviation of a probability distribution over a type T is
a specialisation of QTY (from T.diffType) that expresses differences
between values of type T. If T is <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="REAL"/>
                        </mif:object> or <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="INT"/>
                        </mif:object>,
T.diffType is also <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="REAL"/>
                        </mif:object> or <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="INT"/>
                        </mif:object>
respectively. However if T is a point in time (<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="TS"/>
                        </mif:object>),
T.diffType is a physical quantity (<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="PQ"/>
                        </mif:object>) in the dimension
of time.
        </mif:p>
                     <mif:p>
The standard deviation is what ISO GUM calls "standard uncertainty."
        </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="QTY"/>
      </mif:property>
      <mif:property name="distributionType" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Probability Distribution Type"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
A code specifying the type of probability distribution. Possible
values are as shown in the attached table. The NULL value (unknown)
for the type code indicates that the probability distribution type is
unknown. In that case, the standard deviation has the meaning of an
informal guess.
      </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							                 <mif:object name="conceptDomainRef">
                           <mif:param name="name" value="ProbabilityDistributionType"/>
                        </mif:object> 
lists the defined
probability distributions. Many distribution types are defined in
terms of special parameters (e.g., the parameters α and β
for the γ-distribution, number of degrees of freedom for the
<mif:b>t</mif:b>-distribution, etc.)  For all distribution types,
however, the mean and standard deviation are defined. 

						</mif:p>
                     <mif:p>
The three distribution-types <mif:b>unknown</mif:b> (NULL),
<mif:b>uniform</mif:b> and <mif:b>normal</mif:b> must be supported by
every system that claims to support <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>. All other distribution
types are optional. When a system interpreting a <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>
representation encounters a distribution type that it does not
recognize, it maps this type to the unknown (NULL) distribution-type.
      </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="ProbabilityDistributionType"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="literal" sortKey="03" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
The parametric probability distribution has a literal form. The
general syntax is as follows:
      </mif:p>
                     <mif:p>
Examples: an example for a <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="PPD"/>
                        </mif:object>&lt;<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="REAL"/>
                        </mif:object>&gt;
is "1.23(N0.005)" for a normal distribution of a real
number around 1.23 with a standard deviation of 0.005. An example for
a <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="PPD"/>
                        </mif:object>&lt;<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="PQ"/>
                        </mif:object>&gt; is "1.23 m (5 mm)" for
a distribution of unknown type around the length 1.23 meter with a
standard deviation of 5 millimeter. An example for a <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="PPD"/>
                        </mif:object>
&lt;<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="TS"/>
                        </mif:object>&gt; is "2000041113(U4 h)" for a
uniform distribution around April 11, 2000 at 1pm with standard
deviation of 4 hours.
      </mif:p>
                  </mif:text>
               </mif:designComments>
               <mif:otherAnnotation type="LiteralFormat">
                  <mif:data>
PPD&lt;T&gt;.literal ST {
  PPD&lt;T&gt; : T "(" type QTY ")"  { ((T)$).equal($1);
                                    $.distributionType.equal($3);
                                    $.standardDeviation.equal($4); };
  CV type : ST     { $.value.equal($1);
                     $.codeSystem.equal(2.16.840.1.113883.5.1020); };
};
      </mif:data>
               </mif:otherAnnotation>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="ST"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="PPD_REAL" title="ParametricProbabilityDistribution&lt;RealNumber&gt;"
                 datatypeKind="Binding"
                 visibility="public">
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text/>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
The parametric probability distribution of real numbers is fully defined by
the generic data type.
</mif:p>
                  <mif:p>
However, there are some special considerations about literal representations
and conversions of probability distributions over real numbers, which are
specified in this section.
</mif:p>
                  <mif:div title="Converting a real number (REAL) to an uncertain real number&#xA;          (PPD&lt;REAL&gt;)">
When converting a  into a ,
the standard deviation is calculated from the  value's
order of magnitude and precision (number of significant digits).
Let x be a real number with precision n. We can
determine the order of magnitude e of x as
e = log10 |x| where e is rounded to
the next integer that is closer to zero (special case: if x
is zero, e is zero.)  The value of least significant digit
l is then l = 10e-n
and the standard deviation σ is σ = l /
2.
Examples of standard deviations computed from precision p and order of magnitude eRepresentationxepe - p + 1lσ00(0)1010.51101010.52201010.59901010.5101012010.510010023010.51e+1101111051e+21002121005010e+11002211051.11.102-10.10.0510.110.113-10.10.051.1e+21102211051.1e-20.011-22-30.0010.00051.1e-40.00011-42-50.000010.00000510.1e-40.00101-33-50.000010.0000050.1e-10.01-21-20.010.0050.01e-10.001-31-30.0010.00050.01e-20.0001-41-40.00010.000050.000(0)3-20.010.005</mif:div>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type ParametricProbabilityDistribution&lt;RealNumber&gt; alias PPD&lt;REAL&gt; specializes PPD&lt;T&gt;;
      </mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:binding>
         <mif:targetDatatype name="PPD"/>
         <mif:argumentDatatype name="REAL"/>
      </mif:binding>
      <mif:property name="literal" sortKey="01" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Concise Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
Besides the generic literal form of the <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="PPD"/>
                        </mif:object>, a
concise literal form is defined for <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="PPD"/>
                        </mif:object> over real
numbers. This concise literal form is defined such that the standard
deviation can be expressed in terms of the least significant digit in
the mantissa. This literal is defined as an extension of the <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="REAL"/>
                        </mif:object> literal:
        </mif:p>
                     <mif:p>
Examples: "1.23e-3 (U5e-6)" is the uniform distribution around 1.23
× 10<mif:sup>-3</mif:sup> with 5 × 10<mif:sup>-6</mif:sup> standard
deviation in generic literal form. "1.230(U5)e-3" is the same value in
concise literal form.
</mif:p>
                  </mif:text>
               </mif:designComments>
               <mif:otherAnnotation type="LiteralFormat">
                  <mif:data>
PPD&lt;REAL&gt;.literal ST {
  PPD&lt;REAL&gt; mantissa
  : REAL.mantissa "(" type QTY ")" { ((T)$).equal($1);
                                        $.distributionType.equal($3);
                                        $.standardDeviation.equal($4); }
  | REAL.mantissa                     { $.equal($1);
                                        $.distributionType.equal($3);
       $.standardDeviation.equal($1.leastSignificantDigit.times(0.5)); };
  CS type : ST                        { $.value.equal($1);
       $.system.equal(2.16.840.1.113883.5.1019); };
};
        </mif:data>
               </mif:otherAnnotation>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="PPD"/>
         </mif:derivedFrom>
         <mif:type name="ST"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="PPD_PQ" title="ParametricProbabilityDistribution&lt;PhysicalQuantity&gt;"
                 datatypeKind="Binding"
                 visibility="public">
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text/>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
A parametric probability distribution over physical quantities is
constructed from the generic <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="PPD"/>
                     </mif:object> type. However,
recognizing that the unit can be factored from the boundaries, we add
additional semantics and a separate literal form. The additional view
of a probability distribution over physical quantities is a
probability distribution over real numbers with one unit.
</mif:p>
                  <mif:p>
The unit applies to both mean and standard deviation.
</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type ParametricProbabilityDistribution&lt;PhysicalQuantity&gt; alias PPD&lt;PQ&gt; specializes PPD&lt;T&gt; {
   PPD&lt;REAL&gt; value;
   CS  unit;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:binding>
         <mif:targetDatatype name="PPD"/>
         <mif:argumentDatatype name="PQ"/>
      </mif:binding>
      <mif:property name="value" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Value"/>
         <mif:type name="PPD">
            <mif:argumentDatatype name="REAL"/>
         </mif:type>
      </mif:property>
      <mif:property name="unit" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Unit"/>
         <mif:type name="CS"/>
      </mif:property>
      <mif:property name="literal" sortKey="03" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Concise Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
A concise literal form for probability distributions of physical
quantities is defined based on the concise literal form of <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="PPD"/>
                        </mif:object>
&lt;<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="REAL"/>
                        </mif:object>&gt; where <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="REAL"/>
                        </mif:object> is the value. This
literal is defined as an extension of the <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="PQ"/>
                        </mif:object> literal.
        </mif:p>
                     <mif:p>
Examples: "1.23e-3 m (N5e-6 m)" is the normal-distributed length of
1.23 × 10<mif:sup>-3</mif:sup> m with 5 × 10<mif:sup>-6</mif:sup> m
standard deviation in generic literal
form. "1.230(N5)e-3 m" is the same value in concise literal
form. "1.23e-3(N0.005e-3) m " is also valid; it is the concise literal
form for <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="PPD"/>
                        </mif:object>&lt;<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="PQ"/>
                        </mif:object>&gt; combined with the
generic literal form for <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="PPD"/>
                        </mif:object>&lt;<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="REAL"/>
                        </mif:object>&gt;.
</mif:p>
                  </mif:text>
               </mif:designComments>
               <mif:otherAnnotation type="LiteralFormat">
                  <mif:data>
PPD&lt;PQ&gt;.literal ST {
  PPD&lt;PQ&gt; : PPD&lt;REAL&gt; " " unit  { $.value.equal($1);
            $.unit.equal($3); }
};
        </mif:data>
               </mif:otherAnnotation>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="PPD"/>
         </mif:derivedFrom>
         <mif:type name="ST"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="PPD_TS" title="ParametricProbabilityDistribution&lt;PointInTime&gt;"
                 datatypeKind="Binding"
                 visibility="public">
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text/>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
The parametric probability distribution over time points is fully defined by
the generic data type.
</mif:p>
                  <mif:p>
The standard deviation is of type TS.diffType, which is a duration (a physical
quantity in the dimension of time.)
</mif:p>
                  <mif:div title="Converting a point in time (TS) to an uncertain point in&#xA;          time">
When converting a  into a 
&lt;&gt;, the standard deviation is
calculated from the  value's order of magnitude
and precision (number of significant digits) such that two standard
deviations span the maximal time range of the digits not
specified. For example, in 20000609 the unspecified digits are hour of
the day and lower. All these digits together span a duration of 24
hours, and thus, the standard deviation ( is( = 12 h from
20000609000000.0000... up to 20000609999999.9999... (= 20000610)

This rule is different from real numbers in that the range of uncertainty lies 
above the time value specified. This is to go with the common sense judgment 
that June 9th spans all day of June 9th with noon as the center, not midnight.
</mif:div>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type ParametricProbabilityDistribution&lt;PointInTime&gt; alias PPD&lt;TS&gt; specializes PPD&lt;T&gt;;</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:binding>
         <mif:targetDatatype name="PPD"/>
         <mif:argumentDatatype name="TS"/>
      </mif:binding>
   </mif:datatype>
</mif:datatypeModelLibrary>